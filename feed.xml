<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://saeed1262.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://saeed1262.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2025-09-08T14:02:13+00:00</updated><id>https://saeed1262.github.io/feed.xml</id><title type="html">Saeed Ghorbani</title><subtitle>Research Scientist at Amazon Games specializing in machine learning, computer vision, computer graphics, and computer animation. Expert in probabilistic motion modeling and deep learning for human motion synthesis. </subtitle><entry><title type="html">BVH Collision Detection &amp;amp; Correction</title><link href="https://saeed1262.github.io/blog/2025/layout-designer-bvh-collision/" rel="alternate" type="text/html" title="BVH Collision Detection &amp;amp; Correction"/><published>2025-09-05T00:00:00+00:00</published><updated>2025-09-05T00:00:00+00:00</updated><id>https://saeed1262.github.io/blog/2025/layout-designer-bvh-collision</id><content type="html" xml:base="https://saeed1262.github.io/blog/2025/layout-designer-bvh-collision/"><![CDATA[<p>Modern layout tools nee d to keep hundreds of items responsive without letting them overlap. In one of my projects, collision detection and correction are handled by a dynamic Bounding Volume Hierarchy (BVH) built over axis‑aligned bounding boxes (AABBs). This post explains how the BVH is constructed, updated, queried for overlaps, and how overlaps are corrected reliably and fast.</p> <h2 id="why-bvh-and-not-a-grid">Why BVH (and not a grid)?</h2> <ul> <li>Uniform grids shine with similarly sized objects. Layouts often have mixed sizes and clustered elements, where grids either over‑bucket or under‑bucket.</li> <li>BVH adapts to spatial distribution: nearby items share tight parent AABBs; far items barely interact during traversal.</li> <li>Dynamic refitting makes per‑frame updates cheap: when an item moves, only O(log n) parent AABBs update.</li> </ul> <h2 id="objects-and-bounds">Objects and Bounds</h2> <ul> <li>Item shape: treated as rectangles aligned to the canvas axes (AABBs). Rotations, if present visually, use their axis‑aligned bounding box for broad‑phase.</li> <li>Node: either a leaf (stores one item index) or an internal node with two children and an AABB enclosing them.</li> </ul> <div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Pseudocode/TypeScript‑ish for clarity</span>
<span class="kd">type</span> <span class="nx">AABB</span> <span class="o">=</span> <span class="p">{</span> <span class="na">minX</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span> <span class="nl">minY</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span> <span class="nl">maxX</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span> <span class="nl">maxY</span><span class="p">:</span> <span class="kr">number</span> <span class="p">};</span>

<span class="kd">type</span> <span class="nx">Node</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">aabb</span><span class="p">:</span> <span class="nx">AABB</span><span class="p">;</span>
  <span class="nl">left</span><span class="p">?:</span> <span class="kr">number</span><span class="p">;</span>  <span class="c1">// index into nodes array</span>
  <span class="nl">right</span><span class="p">?:</span> <span class="kr">number</span><span class="p">;</span> <span class="c1">// index into nodes array</span>
  <span class="nl">parent</span><span class="p">?:</span> <span class="kr">number</span><span class="p">;</span>
  <span class="nl">item</span><span class="p">?:</span> <span class="kr">number</span><span class="p">;</span>  <span class="c1">// leaf: index into items array</span>
  <span class="nl">height</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span> <span class="c1">// leaf = 0, internal = 1 + max(children)</span>
<span class="p">};</span>
</code></pre></div></div> <h2 id="building-the-bvh">Building the BVH</h2> <p>For static scenes, a top‑down build using a surface‑area heuristic (SAH) is ideal. LD V2 prioritizes dynamic interaction, so it uses a fast incremental insertion with periodic rebuilds:</p> <ul> <li>Initial build: sort items along the longer world axis, recursively split by median; compute AABBs bottom‑up.</li> <li>Incremental insert: new item picks a leaf that minimizes the growth in parent surface area; split leaf into a new internal node with two children.</li> <li>Refit: when an item moves, update its leaf AABB, then recompute ancestors’ AABBs up to the root.</li> <li>Rebalance: occasionally rotate local subtrees (AVL‑like) or trigger a full rebuild if the tree gets too tall (e.g., <code class="language-plaintext highlighter-rouge">height &gt; 2 * log2(n) + c</code>).</li> </ul> <div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">merge</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="nx">AABB</span><span class="p">,</span> <span class="nx">b</span><span class="p">:</span> <span class="nx">AABB</span><span class="p">):</span> <span class="nx">AABB</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">{</span>
    <span class="na">minX</span><span class="p">:</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">min</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">minX</span><span class="p">,</span> <span class="nx">b</span><span class="p">.</span><span class="nx">minX</span><span class="p">),</span> <span class="na">minY</span><span class="p">:</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">min</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">minY</span><span class="p">,</span> <span class="nx">b</span><span class="p">.</span><span class="nx">minY</span><span class="p">),</span>
    <span class="na">maxX</span><span class="p">:</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">max</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">maxX</span><span class="p">,</span> <span class="nx">b</span><span class="p">.</span><span class="nx">maxX</span><span class="p">),</span> <span class="na">maxY</span><span class="p">:</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">max</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">maxY</span><span class="p">,</span> <span class="nx">b</span><span class="p">.</span><span class="nx">maxY</span><span class="p">)</span>
  <span class="p">};</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nf">perimeter</span><span class="p">(</span><span class="nx">b</span><span class="p">:</span> <span class="nx">AABB</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">((</span><span class="nx">b</span><span class="p">.</span><span class="nx">maxX</span> <span class="o">-</span> <span class="nx">b</span><span class="p">.</span><span class="nx">minX</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">maxY</span> <span class="o">-</span> <span class="nx">b</span><span class="p">.</span><span class="nx">minY</span><span class="p">));</span> <span class="p">}</span>

<span class="c1">// Greedy insertion: choose the subtree that minimally increases perimeter</span>
<span class="kd">function</span> <span class="nf">chooseInsertion</span><span class="p">(</span><span class="nx">node</span><span class="p">:</span> <span class="kr">number</span><span class="p">,</span> <span class="nx">box</span><span class="p">:</span> <span class="nx">AABB</span><span class="p">):</span> <span class="kr">number</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">n</span> <span class="o">=</span> <span class="nx">node</span><span class="p">;</span>
  <span class="k">while </span><span class="p">(</span><span class="o">!</span><span class="nx">nodes</span><span class="p">[</span><span class="nx">n</span><span class="p">].</span><span class="nx">item</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">L</span> <span class="o">=</span> <span class="nx">nodes</span><span class="p">[</span><span class="nx">nodes</span><span class="p">[</span><span class="nx">n</span><span class="p">].</span><span class="nx">left</span><span class="o">!</span><span class="p">],</span> <span class="nx">R</span> <span class="o">=</span> <span class="nx">nodes</span><span class="p">[</span><span class="nx">nodes</span><span class="p">[</span><span class="nx">n</span><span class="p">].</span><span class="nx">right</span><span class="o">!</span><span class="p">];</span>
    <span class="kd">const</span> <span class="nx">costL</span> <span class="o">=</span> <span class="nf">perimeter</span><span class="p">(</span><span class="nf">merge</span><span class="p">(</span><span class="nx">L</span><span class="p">.</span><span class="nx">aabb</span><span class="p">,</span> <span class="nx">box</span><span class="p">))</span> <span class="o">-</span> <span class="nf">perimeter</span><span class="p">(</span><span class="nx">L</span><span class="p">.</span><span class="nx">aabb</span><span class="p">);</span>
    <span class="kd">const</span> <span class="nx">costR</span> <span class="o">=</span> <span class="nf">perimeter</span><span class="p">(</span><span class="nf">merge</span><span class="p">(</span><span class="nx">R</span><span class="p">.</span><span class="nx">aabb</span><span class="p">,</span> <span class="nx">box</span><span class="p">))</span> <span class="o">-</span> <span class="nf">perimeter</span><span class="p">(</span><span class="nx">R</span><span class="p">.</span><span class="nx">aabb</span><span class="p">);</span>
    <span class="nx">n</span> <span class="o">=</span> <span class="nx">costL</span> <span class="o">&lt;=</span> <span class="nx">costR</span> <span class="p">?</span> <span class="nx">nodes</span><span class="p">[</span><span class="nx">n</span><span class="p">].</span><span class="nx">left</span><span class="o">!</span> <span class="p">:</span> <span class="nx">nodes</span><span class="p">[</span><span class="nx">n</span><span class="p">].</span><span class="nx">right</span><span class="o">!</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">n</span><span class="p">;</span> <span class="c1">// leaf index</span>
<span class="p">}</span>
</code></pre></div></div> <h2 id="broadphase-overlap-query">Broad‑Phase Overlap Query</h2> <p>Traversal uses a stack (or small array) and prunes subtrees whose AABBs don’t intersect the query box. Two common queries:</p> <p>1) All pairs (global): enumerate every overlapping pair once. 2) Single item: find overlaps against one moving item to resolve on the fly.</p> <div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">aabbOverlap</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="nx">AABB</span><span class="p">,</span> <span class="nx">b</span><span class="p">:</span> <span class="nx">AABB</span><span class="p">):</span> <span class="nx">boolean</span> <span class="p">{</span>
  <span class="k">return</span> <span class="o">!</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">maxX</span> <span class="o">&lt;=</span> <span class="nx">b</span><span class="p">.</span><span class="nx">minX</span> <span class="o">||</span> <span class="nx">b</span><span class="p">.</span><span class="nx">maxX</span> <span class="o">&lt;=</span> <span class="nx">a</span><span class="p">.</span><span class="nx">minX</span> <span class="o">||</span>
           <span class="nx">a</span><span class="p">.</span><span class="nx">maxY</span> <span class="o">&lt;=</span> <span class="nx">b</span><span class="p">.</span><span class="nx">minY</span> <span class="o">||</span> <span class="nx">b</span><span class="p">.</span><span class="nx">maxY</span> <span class="o">&lt;=</span> <span class="nx">a</span><span class="p">.</span><span class="nx">minY</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// 1) Global pairs via self‑overlap traversal</span>
<span class="kd">function</span> <span class="nf">collectPairs</span><span class="p">(</span><span class="nx">root</span><span class="p">:</span> <span class="kr">number</span><span class="p">):</span> <span class="p">[</span><span class="kr">number</span><span class="p">,</span> <span class="kr">number</span><span class="p">][]</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">out</span><span class="p">:</span> <span class="p">[</span><span class="kr">number</span><span class="p">,</span> <span class="kr">number</span><span class="p">][]</span> <span class="o">=</span> <span class="p">[];</span>
  <span class="kd">const</span> <span class="nx">stack</span><span class="p">:</span> <span class="p">[</span><span class="kr">number</span><span class="p">,</span> <span class="kr">number</span><span class="p">][]</span> <span class="o">=</span> <span class="p">[[</span><span class="nx">root</span><span class="p">,</span> <span class="nx">root</span><span class="p">]];</span>
  <span class="k">while </span><span class="p">(</span><span class="nx">stack</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="p">[</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span><span class="p">]</span> <span class="o">=</span> <span class="nx">stack</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span><span class="o">!</span><span class="p">;</span>
    <span class="k">if </span><span class="p">(</span><span class="nx">i</span> <span class="o">===</span> <span class="nx">j</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">const</span> <span class="nx">n</span> <span class="o">=</span> <span class="nx">nodes</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
      <span class="k">if </span><span class="p">(</span><span class="o">!</span><span class="nx">n</span><span class="p">.</span><span class="nx">item</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">stack</span><span class="p">.</span><span class="nf">push</span><span class="p">([</span><span class="nx">n</span><span class="p">.</span><span class="nx">left</span><span class="o">!</span><span class="p">,</span> <span class="nx">n</span><span class="p">.</span><span class="nx">left</span><span class="o">!</span><span class="p">]);</span>
        <span class="nx">stack</span><span class="p">.</span><span class="nf">push</span><span class="p">([</span><span class="nx">n</span><span class="p">.</span><span class="nx">right</span><span class="o">!</span><span class="p">,</span> <span class="nx">n</span><span class="p">.</span><span class="nx">right</span><span class="o">!</span><span class="p">]);</span>
        <span class="nx">stack</span><span class="p">.</span><span class="nf">push</span><span class="p">([</span><span class="nx">n</span><span class="p">.</span><span class="nx">left</span><span class="o">!</span><span class="p">,</span> <span class="nx">n</span><span class="p">.</span><span class="nx">right</span><span class="o">!</span><span class="p">]);</span>
      <span class="p">}</span>
      <span class="k">continue</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kd">const</span> <span class="nx">A</span> <span class="o">=</span> <span class="nx">nodes</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">B</span> <span class="o">=</span> <span class="nx">nodes</span><span class="p">[</span><span class="nx">j</span><span class="p">];</span>
    <span class="k">if </span><span class="p">(</span><span class="o">!</span><span class="nf">aabbOverlap</span><span class="p">(</span><span class="nx">A</span><span class="p">.</span><span class="nx">aabb</span><span class="p">,</span> <span class="nx">B</span><span class="p">.</span><span class="nx">aabb</span><span class="p">))</span> <span class="k">continue</span><span class="p">;</span>
    <span class="k">if </span><span class="p">(</span><span class="nx">A</span><span class="p">.</span><span class="nx">item</span> <span class="o">&amp;&amp;</span> <span class="nx">B</span><span class="p">.</span><span class="nx">item</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// two leaves</span>
      <span class="nx">out</span><span class="p">.</span><span class="nf">push</span><span class="p">([</span><span class="nx">A</span><span class="p">.</span><span class="nx">item</span><span class="p">,</span> <span class="nx">B</span><span class="p">.</span><span class="nx">item</span><span class="p">]);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if </span><span class="p">(</span><span class="nx">A</span><span class="p">.</span><span class="nx">item</span> <span class="o">||</span> <span class="p">(</span><span class="o">!</span><span class="nx">B</span><span class="p">.</span><span class="nx">item</span> <span class="o">&amp;&amp;</span> <span class="nx">A</span><span class="p">.</span><span class="nx">aabbArea</span> <span class="o">&lt;=</span> <span class="nx">B</span><span class="p">.</span><span class="nx">aabbArea</span><span class="p">))</span> <span class="p">{</span>
      <span class="c1">// descend the non‑leaf or the larger box</span>
      <span class="nx">stack</span><span class="p">.</span><span class="nf">push</span><span class="p">([</span><span class="nx">A</span><span class="p">.</span><span class="nx">item</span> <span class="p">?</span> <span class="nx">i</span> <span class="p">:</span> <span class="nx">A</span><span class="p">.</span><span class="nx">left</span><span class="o">!</span><span class="p">,</span> <span class="nx">j</span><span class="p">]);</span>
      <span class="nx">stack</span><span class="p">.</span><span class="nf">push</span><span class="p">([</span><span class="nx">A</span><span class="p">.</span><span class="nx">item</span> <span class="p">?</span> <span class="nx">i</span> <span class="p">:</span> <span class="nx">A</span><span class="p">.</span><span class="nx">right</span><span class="o">!</span><span class="p">,</span> <span class="nx">j</span><span class="p">]);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="nx">stack</span><span class="p">.</span><span class="nf">push</span><span class="p">([</span><span class="nx">i</span><span class="p">,</span> <span class="nx">B</span><span class="p">.</span><span class="nx">left</span><span class="o">!</span><span class="p">]);</span>
      <span class="nx">stack</span><span class="p">.</span><span class="nf">push</span><span class="p">([</span><span class="nx">i</span><span class="p">,</span> <span class="nx">B</span><span class="p">.</span><span class="nx">right</span><span class="o">!</span><span class="p">]);</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">out</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 2) Single item query</span>
<span class="kd">function</span> <span class="nf">queryOverlaps</span><span class="p">(</span><span class="nx">root</span><span class="p">:</span> <span class="kr">number</span><span class="p">,</span> <span class="nx">box</span><span class="p">:</span> <span class="nx">AABB</span><span class="p">,</span> <span class="nx">hits</span><span class="p">:</span> <span class="kr">number</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[]):</span> <span class="kr">number</span><span class="p">[]</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">stack</span> <span class="o">=</span> <span class="p">[</span><span class="nx">root</span><span class="p">];</span>
  <span class="k">while </span><span class="p">(</span><span class="nx">stack</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">n</span> <span class="o">=</span> <span class="nx">nodes</span><span class="p">[</span><span class="nx">stack</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span><span class="o">!</span><span class="p">];</span>
    <span class="k">if </span><span class="p">(</span><span class="o">!</span><span class="nf">aabbOverlap</span><span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">aabb</span><span class="p">,</span> <span class="nx">box</span><span class="p">))</span> <span class="k">continue</span><span class="p">;</span>
    <span class="k">if </span><span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">item</span><span class="p">)</span> <span class="nx">hits</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">item</span><span class="p">);</span> <span class="k">else</span> <span class="p">{</span> <span class="nx">stack</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">left</span><span class="o">!</span><span class="p">,</span> <span class="nx">n</span><span class="p">.</span><span class="nx">right</span><span class="o">!</span><span class="p">);</span> <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">hits</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>In practice this runs near O(n log n) for well‑shaped trees, with very small constants thanks to cache‑friendly AABBs and branch pruning.</p> <h2 id="narrowphase-and-minimal-translation-vector-mtv">Narrow‑Phase and Minimal Translation Vector (MTV)</h2> <p>Once a candidate pair is produced, we confirm overlap with an AABB‑AABB test and compute the minimal translation vector to separate them. For axis‑aligned rectangles:</p> <div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">MTV</span> <span class="o">=</span> <span class="p">{</span> <span class="na">dx</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span> <span class="nl">dy</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span> <span class="nl">depth</span><span class="p">:</span> <span class="kr">number</span> <span class="p">};</span>

<span class="kd">function</span> <span class="nf">aabbMTV</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="nx">AABB</span><span class="p">,</span> <span class="nx">b</span><span class="p">:</span> <span class="nx">AABB</span><span class="p">):</span> <span class="nx">MTV</span> <span class="o">|</span> <span class="kc">null</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">overlapX</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">min</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">maxX</span> <span class="o">-</span> <span class="nx">b</span><span class="p">.</span><span class="nx">minX</span><span class="p">,</span> <span class="nx">b</span><span class="p">.</span><span class="nx">maxX</span> <span class="o">-</span> <span class="nx">a</span><span class="p">.</span><span class="nx">minX</span><span class="p">);</span>
  <span class="kd">const</span> <span class="nx">overlapY</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">min</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">maxY</span> <span class="o">-</span> <span class="nx">b</span><span class="p">.</span><span class="nx">minY</span><span class="p">,</span> <span class="nx">b</span><span class="p">.</span><span class="nx">maxY</span> <span class="o">-</span> <span class="nx">a</span><span class="p">.</span><span class="nx">minY</span><span class="p">);</span>
  <span class="k">if </span><span class="p">(</span><span class="nx">overlapX</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">overlapY</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
  <span class="c1">// move along the smaller penetration</span>
  <span class="k">if </span><span class="p">(</span><span class="nx">overlapX</span> <span class="o">&lt;</span> <span class="nx">overlapY</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">dir</span> <span class="o">=</span> <span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">minX</span> <span class="o">+</span> <span class="nx">a</span><span class="p">.</span><span class="nx">maxX</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">&lt;</span> <span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">minX</span> <span class="o">+</span> <span class="nx">b</span><span class="p">.</span><span class="nx">maxX</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="p">?</span> <span class="o">-</span><span class="mi">1</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">return</span> <span class="p">{</span> <span class="na">dx</span><span class="p">:</span> <span class="nx">dir</span> <span class="o">*</span> <span class="nx">overlapX</span><span class="p">,</span> <span class="na">dy</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="na">depth</span><span class="p">:</span> <span class="nx">overlapX</span> <span class="p">};</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">dir</span> <span class="o">=</span> <span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">minY</span> <span class="o">+</span> <span class="nx">a</span><span class="p">.</span><span class="nx">maxY</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">&lt;</span> <span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">minY</span> <span class="o">+</span> <span class="nx">b</span><span class="p">.</span><span class="nx">maxY</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="p">?</span> <span class="o">-</span><span class="mi">1</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">return</span> <span class="p">{</span> <span class="na">dx</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="na">dy</span><span class="p">:</span> <span class="nx">dir</span> <span class="o">*</span> <span class="nx">overlapY</span><span class="p">,</span> <span class="na">depth</span><span class="p">:</span> <span class="nx">overlapY</span> <span class="p">};</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <h2 id="correction-stable-separation-without-jitter">Correction: Stable Separation Without Jitter</h2> <p>LD V2 resolves overlaps immediately after detection using a symmetric, bias‑aware push:</p> <ul> <li>Compute MTV between <code class="language-plaintext highlighter-rouge">A</code> and <code class="language-plaintext highlighter-rouge">B</code>.</li> <li>Split correction based on “priority” (e.g., locked/anchored items get 0, draggable gets 1) or mass (both 0.5 by default).</li> <li>Apply positional slop and a softness factor to avoid oscillation.</li> <li>Refit BVH along the paths of the moved leaves.</li> </ul> <div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">resolvePair</span><span class="p">(</span><span class="nx">aIdx</span><span class="p">:</span> <span class="kr">number</span><span class="p">,</span> <span class="nx">bIdx</span><span class="p">:</span> <span class="kr">number</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">a</span> <span class="o">=</span> <span class="nx">items</span><span class="p">[</span><span class="nx">aIdx</span><span class="p">],</span> <span class="nx">b</span> <span class="o">=</span> <span class="nx">items</span><span class="p">[</span><span class="nx">bIdx</span><span class="p">];</span>
  <span class="kd">const</span> <span class="nx">mtv</span> <span class="o">=</span> <span class="nf">aabbMTV</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">aabb</span><span class="p">,</span> <span class="nx">b</span><span class="p">.</span><span class="nx">aabb</span><span class="p">);</span> <span class="k">if </span><span class="p">(</span><span class="o">!</span><span class="nx">mtv</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>

  <span class="c1">// Bias: anchored items don’t move; otherwise split 50/50</span>
  <span class="kd">const</span> <span class="nx">wa</span> <span class="o">=</span> <span class="nx">a</span><span class="p">.</span><span class="nx">anchored</span> <span class="p">?</span> <span class="mi">0</span> <span class="p">:</span> <span class="mf">0.5</span><span class="p">;</span>
  <span class="kd">const</span> <span class="nx">wb</span> <span class="o">=</span> <span class="nx">b</span><span class="p">.</span><span class="nx">anchored</span> <span class="p">?</span> <span class="mi">0</span> <span class="p">:</span> <span class="mf">0.5</span><span class="p">;</span>

  <span class="c1">// Positional slop to reduce jitter on grazing contacts</span>
  <span class="kd">const</span> <span class="nx">SLOP</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">;</span> <span class="c1">// pixels</span>
  <span class="kd">const</span> <span class="nx">DEPTH</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nx">mtv</span><span class="p">.</span><span class="nx">depth</span> <span class="o">-</span> <span class="nx">SLOP</span><span class="p">);</span>
  <span class="kd">const</span> <span class="nx">SOFTNESS</span> <span class="o">=</span> <span class="mf">0.9</span><span class="p">;</span> <span class="c1">// 1.0 = full separation, &lt;1 damps</span>

  <span class="kd">const</span> <span class="nx">dx</span> <span class="o">=</span> <span class="nx">SOFTNESS</span> <span class="o">*</span> <span class="p">(</span><span class="nx">mtv</span><span class="p">.</span><span class="nx">dx</span> <span class="o">===</span> <span class="mi">0</span> <span class="p">?</span> <span class="mi">0</span> <span class="p">:</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">sign</span><span class="p">(</span><span class="nx">mtv</span><span class="p">.</span><span class="nx">dx</span><span class="p">)</span> <span class="o">*</span> <span class="nx">DEPTH</span><span class="p">);</span>
  <span class="kd">const</span> <span class="nx">dy</span> <span class="o">=</span> <span class="nx">SOFTNESS</span> <span class="o">*</span> <span class="p">(</span><span class="nx">mtv</span><span class="p">.</span><span class="nx">dy</span> <span class="o">===</span> <span class="mi">0</span> <span class="p">?</span> <span class="mi">0</span> <span class="p">:</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">sign</span><span class="p">(</span><span class="nx">mtv</span><span class="p">.</span><span class="nx">dy</span><span class="p">)</span> <span class="o">*</span> <span class="nx">DEPTH</span><span class="p">);</span>

  <span class="nx">a</span><span class="p">.</span><span class="nf">translate</span><span class="p">(</span><span class="o">-</span><span class="nx">wa</span> <span class="o">*</span> <span class="nx">dx</span><span class="p">,</span> <span class="o">-</span><span class="nx">wa</span> <span class="o">*</span> <span class="nx">dy</span><span class="p">);</span>
  <span class="nx">b</span><span class="p">.</span><span class="nf">translate</span><span class="p">(</span> <span class="nx">wb</span> <span class="o">*</span> <span class="nx">dx</span><span class="p">,</span>  <span class="nx">wb</span> <span class="o">*</span> <span class="nx">dy</span><span class="p">);</span>

  <span class="c1">// Update their leaf AABBs and refit paths to root</span>
  <span class="nf">refitLeaf</span><span class="p">(</span><span class="nx">aIdx</span><span class="p">);</span>
  <span class="nf">refitLeaf</span><span class="p">(</span><span class="nx">bIdx</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>To avoid chain reactions, the solver iterates over current overlaps a small, bounded number of times (e.g., 2–4 iterations), which is usually sufficient for layouts. Detect‑correct‑refit repeats per iteration.</p> <h2 id="update-loop">Update Loop</h2> <p>Two common modes are used depending on interaction type:</p> <ul> <li>Dragging live: on each pointer move, query BVH against the dragged item’s AABB, resolve overlaps immediately, refit, repeat until no overlaps or max iterations reached.</li> <li>Batch settle: after bulk edits (e.g., paste 50 items), collect global pairs, then iterate resolve passes.</li> </ul> <div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">settle</span><span class="p">(</span><span class="nx">maxIters</span> <span class="o">=</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">it</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">it</span> <span class="o">&lt;</span> <span class="nx">maxIters</span><span class="p">;</span> <span class="nx">it</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">pairs</span> <span class="o">=</span> <span class="nf">collectPairs</span><span class="p">(</span><span class="nx">root</span><span class="p">);</span>
    <span class="k">if </span><span class="p">(</span><span class="nx">pairs</span><span class="p">.</span><span class="nx">length</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
    <span class="k">for </span><span class="p">(</span><span class="kd">const</span> <span class="p">[</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">]</span> <span class="k">of</span> <span class="nx">pairs</span><span class="p">)</span> <span class="nf">resolvePair</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <h2 id="dynamic-considerations">Dynamic Considerations</h2> <ul> <li>Fast motion: inflate the moving item’s query box by its frame delta (swept AABB) to avoid tunneling through small gaps.</li> <li>Large size differences: BVH handles this better than a uniform grid, but keep an eye on tree height; trigger local rotations or rebuilds when needed.</li> <li>Precision: use integer math for positions where possible; keep AABB computations consistent to avoid 1‑pixel “thrash.”</li> <li>Ordering: for deterministic results, sort candidate pairs (e.g., by minX, then minY) before resolving.</li> </ul> <h2 id="complexity--performance">Complexity &amp; Performance</h2> <ul> <li>Query: typical O(log n + k) where k is number of true overlaps; worst‑case can degenerate but is rare in practice with occasional rebalancing.</li> <li>Update: leaf refit is O(log n); incremental inserts and removals are similar.</li> <li>Correction: per‑pair O(1) math; bounded passes keep total under control in interactive scenarios.</li> </ul> <h2 id="pitfalls-and-fixes">Pitfalls and Fixes</h2> <ul> <li>Jitter on grazing contacts: add positional slop and soften the correction.</li> <li>Oscillation between neighbors: bias movement by “anchored” or “priority” flags; damp corrections slightly.</li> <li>Deep or skewed trees: rotate local subtrees, or rebuild on a height/imbalance threshold.</li> <li>Over‑correction near walls: clamp movement against fixed bounds before applying MTV.</li> </ul> <h2 id="minimal-example-all-together">Minimal Example (All Together)</h2> <div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Move an item, then keep it overlap‑free</span>
<span class="kd">function</span> <span class="nf">moveItem</span><span class="p">(</span><span class="nx">idx</span><span class="p">:</span> <span class="kr">number</span><span class="p">,</span> <span class="nx">dx</span><span class="p">:</span> <span class="kr">number</span><span class="p">,</span> <span class="nx">dy</span><span class="p">:</span> <span class="kr">number</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">item</span> <span class="o">=</span> <span class="nx">items</span><span class="p">[</span><span class="nx">idx</span><span class="p">];</span>
  <span class="nx">item</span><span class="p">.</span><span class="nf">translate</span><span class="p">(</span><span class="nx">dx</span><span class="p">,</span> <span class="nx">dy</span><span class="p">);</span>
  <span class="nf">refitLeaf</span><span class="p">(</span><span class="nx">idx</span><span class="p">);</span>

  <span class="c1">// Query neighbors against inflated box (swept AABB)</span>
  <span class="kd">const</span> <span class="nx">q</span> <span class="o">=</span> <span class="nf">inflate</span><span class="p">(</span><span class="nx">item</span><span class="p">.</span><span class="nx">aabb</span><span class="p">,</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">abs</span><span class="p">(</span><span class="nx">dx</span><span class="p">),</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">abs</span><span class="p">(</span><span class="nx">dy</span><span class="p">));</span>
  <span class="kd">const</span> <span class="nx">neighbors</span> <span class="o">=</span> <span class="nf">queryOverlaps</span><span class="p">(</span><span class="nx">root</span><span class="p">,</span> <span class="nx">q</span><span class="p">);</span>

  <span class="c1">// Resolve locally a few times</span>
  <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">it</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">it</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="nx">it</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="kr">any</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
    <span class="k">for </span><span class="p">(</span><span class="kd">const</span> <span class="nx">j</span> <span class="k">of</span> <span class="nx">neighbors</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if </span><span class="p">(</span><span class="nx">j</span> <span class="o">===</span> <span class="nx">idx</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
      <span class="kd">const</span> <span class="nx">before</span> <span class="o">=</span> <span class="nx">items</span><span class="p">[</span><span class="nx">idx</span><span class="p">].</span><span class="nx">aabb</span><span class="p">;</span>
      <span class="nf">resolvePair</span><span class="p">(</span><span class="nx">idx</span><span class="p">,</span> <span class="nx">j</span><span class="p">);</span>
      <span class="kr">any</span> <span class="o">=</span> <span class="kr">any</span> <span class="o">||</span> <span class="nf">aabbOverlap</span><span class="p">(</span><span class="nx">before</span><span class="p">,</span> <span class="nx">items</span><span class="p">[</span><span class="nx">j</span><span class="p">].</span><span class="nx">aabb</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if </span><span class="p">(</span><span class="o">!</span><span class="kr">any</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <h2 id="takeaways">Takeaways</h2> <ul> <li>BVH provides robust, distribution‑aware broad‑phase for heterogeneous layouts.</li> <li>Local refits keep updates cheap; occasional rebalancing maintains query speed.</li> <li>MTV‑based correction with slop/softness yields stable, overlap‑free arrangements without visible jitter.</li> </ul> <h2 id="interactive-bvh-demo">Interactive BVH Demo</h2> <p>Below is an interactive canvas showing the BVH broad‑phase along with collision detection and correction between draggable rectangles. Toggle BVH boxes, candidate pairs, and pause; drag rectangles to see local queries and on‑the‑fly resolution.</p> <div id="bvh-container"> <div id="bvh-controls"> <div class="control-group"> <label>Objects: <span class="value" id="bvhCountLabel">60</span></label> <input id="bvhCount" type="range" min="10" max="200" step="5" value="60"/> </div> <div class="control-group"> <label>Animation Speed: <span class="value" id="bvhSpeedLabel">1.0x</span></label> <input id="bvhSpeed" type="range" min="0.1" max="3.0" step="0.1" value="1.0"/> </div> <div class="control-group"> <label>Visuals</label> <div class="control-row"> <label class="checkbox"><input id="bvhShowTree" type="checkbox" checked=""/> BVH Tree</label> <label class="checkbox"><input id="bvhShowPairs" type="checkbox"/> Collision Pairs</label> </div> <div class="control-row"> <label class="checkbox"><input id="bvhShowTrails" type="checkbox" checked=""/> Velocity Trails</label> <label class="checkbox"><input id="bvhShowQuery" type="checkbox"/> Query Boxes</label> </div> <div class="control-row"> <label class="checkbox"><input id="bvhPause" type="checkbox"/> Pause Animation</label> </div> </div> <div class="control-group"> <label>Actions</label> <div class="control-row"> <button id="bvhReset">Reset Scene</button> <button id="bvhShuffle">Shuffle + Settle</button> </div> </div> </div> <div id="bvh-viz-container"> <canvas id="bvh-viz" width="1280" height="720" aria-label="Enhanced BVH collision detection demo"></canvas> <div class="loading" id="bvhLoading">Preparing Enhanced BVH…</div> <div class="no-canvas" id="bvhNoCanvas" hidden="">Your browser does not support Canvas.</div> </div> <div id="bvh-hud"> <div class="hud-panel"> <h4>BVH Statistics</h4> <div class="hud-value"><span class="label">Nodes</span><span class="value" id="bvhHudNodes">0</span></div> <div class="hud-value"><span class="label">Tree Height</span><span class="value" id="bvhHudHeight">0</span></div> <div class="hud-value"><span class="label">Collision Pairs</span><span class="value" id="bvhHudPairs">0</span></div> <div class="hud-value"><span class="label">Queries/Frame</span><span class="value" id="bvhHudQueries">0</span></div> <div class="hud-value"><span class="label">FPS</span><span class="value" id="bvhHudFps">0</span></div> </div> <div class="hud-panel"> <h4>Interactive Features</h4> <ul class="notes"> <li><strong>Drag objects</strong> — Real-time collision resolution with MTV</li> <li><strong>3 object types</strong> — Normal (colorful), heavy (thick border), light (thin border)</li> <li><strong>Visual effects</strong> — Collision sparks, velocity trails, query highlighting</li> <li><strong>Dynamic BVH</strong> — Tree updates locally as objects move</li> <li><strong>Performance</strong> — Efficient O(log n) queries with pruning</li> </ul> </div> </div> </div> <link rel="stylesheet" href="/assets/css/bvh-layout.css?v=1"/> <script defer="" src="/assets/js/bvh-layout.js?v=1"></script>]]></content><author><name></name></author><category term="blog"/><category term="layout"/><category term="algorithms"/><category term="collision-detection"/><category term="BVH"/><category term="performance"/><summary type="html"><![CDATA[A practical deep‑dive into the Bounding Volume Hierarchy (BVH) system powering fast overlap detection and robust correction.]]></summary></entry><entry><title type="html">Interactive Orbital Rendezvous Simulator</title><link href="https://saeed1262.github.io/blog/2025/orbital-rendezvous-simulator/" rel="alternate" type="text/html" title="Interactive Orbital Rendezvous Simulator"/><published>2025-09-01T00:00:00+00:00</published><updated>2025-09-01T00:00:00+00:00</updated><id>https://saeed1262.github.io/blog/2025/orbital-rendezvous-simulator</id><content type="html" xml:base="https://saeed1262.github.io/blog/2025/orbital-rendezvous-simulator/"><![CDATA[ <script type="text/javascript">window.MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]],processEscapes:!0,processEnvironments:!0,tags:"ams"},options:{ignoreHtmlClass:"tex2jax_ignore",processHtmlClass:"tex2jax_process"}};</script> <script type="text/javascript" id="MathJax-script" async="" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <h2 id="why-speeding-up-can-make-you-fall-behind">Why “Speeding Up” Can Make You Fall Behind</h2> <p>In orbit, a short +V makes you faster now but slower later. A <strong>prograde burn</strong> boosts energy and raises the <strong>opposite side</strong> of your orbit; when you get there, you’re in a higher, slower path. To catch a target ahead, the winning move is often <strong>−V to drop lower and lap faster</strong>.</p> <p>Quick intuition check (two classic cases):</p> <div style="display:grid;grid-template-columns:1fr 1fr;gap:1rem;margin:1rem 0;align-items:center;"> <figure style="margin:0;padding:0.5rem;border:1px solid rgba(59,130,246,0.25);border-radius:10px;background:linear-gradient(135deg,rgba(59,130,246,0.08),rgba(15,23,42,0.3));"> <svg viewBox="0 0 300 200" width="100%" height="auto" role="img" aria-label="Prograde at periapsis raises apoapsis"> <circle cx="150" cy="100" r="24" fill="#0f2744" stroke="#60a5fa" stroke-opacity="0.35"/> <circle cx="150" cy="100" r="74" fill="none" stroke="#94a3b8" stroke-dasharray="6 6"/> <ellipse cx="150" cy="100" rx="118" ry="74" fill="none" stroke="#e5e7eb" stroke-width="2"/> <circle cx="268" cy="100" r="5" fill="#a855f7"/> <text x="210" y="88" fill="#e9d5ff" font-size="12">Apoapsis ↑</text> <circle cx="32" cy="100" r="5" fill="#3b82f6"/> <text x="12" y="88" fill="#bfdbfe" font-size="12">Periapsis</text> <circle cx="150" cy="174" r="6" fill="#22c55e"/> <text x="162" y="176" fill="#bbf7d0" font-size="12">+V here</text> </svg> <figcaption style="text-align:center;color:#cbd5e1;font-size:0.9rem">+V at periapsis → apoapsis rises; later you go slower.</figcaption> </figure> <figure style="margin:0;padding:0.5rem;border:1px solid rgba(59,130,246,0.25);border-radius:10px;background:linear-gradient(135deg,rgba(59,130,246,0.08),rgba(15,23,42,0.3));"> <svg viewBox="0 0 300 200" width="100%" height="auto" role="img" aria-label="Retrograde at apoapsis lowers periapsis"> <circle cx="150" cy="100" r="24" fill="#0f2744" stroke="#60a5fa" stroke-opacity="0.35"/> <circle cx="150" cy="100" r="120" fill="none" stroke="#94a3b8" stroke-dasharray="6 6"/> <ellipse cx="150" cy="100" rx="118" ry="74" fill="none" stroke="#e5e7eb" stroke-width="2"/> <circle cx="268" cy="100" r="6" fill="#ef4444"/> <text x="210" y="88" fill="#fecaca" font-size="12">−V here</text> <circle cx="32" cy="100" r="5" fill="#3b82f6"/> <text x="8" y="88" fill="#bfdbfe" font-size="12">Periapsis ↓</text> </svg> <figcaption style="text-align:center;color:#cbd5e1;font-size:0.9rem">−V at apoapsis → periapsis drops; lower orbit laps faster.</figcaption> </figure> </div> <p>So what? To close on a target ahead of you: <strong>drop, wait, then raise</strong>.</p> <h2 id="interactive-orbital-mechanics-simulator">Interactive Orbital Mechanics Simulator</h2> <link rel="stylesheet" href="/assets/css/orbit-simulator.css"/> <style>#orbit-controls{background:linear-gradient(135deg,rgba(30,41,59,0.9) 0%,rgba(15,23,42,0.95) 100%);border:1px solid rgba(59,130,246,0.3);border-radius:16px;padding:1.5rem;margin-bottom:1.5rem;display:grid;grid-template-columns:repeat(auto-fit,minmax(220px,1fr));gap:1.5rem;align-items:center;box-shadow:0 8px 25px rgba(0,0,0,0.2),inset 0 1px 0 rgba(255,255,255,0.1)}.control-group{display:flex;flex-direction:column;gap:.75rem;align-items:center}.control-group label{font-size:.9rem;font-weight:600;color:rgba(255,255,255,0.9);text-align:center;text-shadow:0 1px 2px rgba(0,0,0,0.5);letter-spacing:.5px}.control-row{display:flex;gap:.75rem;align-items:center;justify-content:center}.burn-button{background:linear-gradient(135deg,var(--global-theme-color) 0%,rgba(59,130,246,0.8) 100%);color:white;border:0;padding:.875rem 1.25rem;border-radius:10px;cursor:pointer;font-weight:600;font-size:.95rem;transition:all .3s cubic-bezier(0.4,0,0.2,1);min-width:70px;position:relative;overflow:hidden;box-shadow:0 4px 15px rgba(0,0,0,0.2),0 0 0 1px rgba(255,255,255,0.1);text-shadow:0 1px 2px rgba(0,0,0,0.5)}.burn-button::before{content:'';position:absolute;top:0;left:-100%;width:100%;height:100%;background:linear-gradient(90deg,transparent,rgba(255,255,255,0.2),transparent);transition:left .5s}.burn-button:hover::before{left:100%}.burn-button:hover{transform:translateY(-2px) scale(1.05);box-shadow:0 8px 25px rgba(0,0,0,0.3),0 0 20px rgba(59,130,246,0.4)}.burn-button:active{transform:translateY(0) scale(0.98)}.burn-button.prograde{background:linear-gradient(135deg,#22c55e 0%,#16a34a 100%);box-shadow:0 4px 15px rgba(34,197,94,0.3),0 0 0 1px rgba(255,255,255,0.1)}.burn-button.prograde:hover{box-shadow:0 8px 25px rgba(34,197,94,0.4),0 0 20px rgba(34,197,94,0.6)}.burn-button.retrograde{background:linear-gradient(135deg,#ef4444 0%,#dc2626 100%);box-shadow:0 4px 15px rgba(239,68,68,0.3),0 0 0 1px rgba(255,255,255,0.1)}.burn-button.retrograde:hover{box-shadow:0 8px 25px rgba(239,68,68,0.4),0 0 20px rgba(239,68,68,0.6)}.burn-button.radial-out{background:linear-gradient(135deg,#3b82f6 0%,#2563eb 100%);box-shadow:0 4px 15px rgba(59,130,246,0.3),0 0 0 1px rgba(255,255,255,0.1)}.burn-button.radial-out:hover{box-shadow:0 8px 25px rgba(59,130,246,0.4),0 0 20px rgba(59,130,246,0.6)}.burn-button.radial-in{background:linear-gradient(135deg,#f59e0b 0%,#d97706 100%);box-shadow:0 4px 15px rgba(245,158,11,0.3),0 0 0 1px rgba(255,255,255,0.1)}.burn-button.radial-in:hover{box-shadow:0 8px 25px rgba(245,158,11,0.4),0 0 20px rgba(245,158,11,0.6)}button{background:linear-gradient(135deg,var(--global-theme-color) 0%,rgba(59,130,246,0.8) 100%);color:white;border:0;padding:.75rem 1.25rem;border-radius:8px;cursor:pointer;font-weight:500;transition:all .3s ease;box-shadow:0 4px 15px rgba(0,0,0,0.2),0 0 0 1px rgba(255,255,255,0.1)}button:hover{transform:translateY(-1px);box-shadow:0 6px 20px rgba(0,0,0,0.3),0 0 20px rgba(59,130,246,0.4)}select{background:linear-gradient(135deg,rgba(30,41,59,0.9) 0%,rgba(15,23,42,0.9) 100%);color:var(--global-text-color);border:1px solid rgba(59,130,246,0.3);padding:.75rem;border-radius:8px;cursor:pointer;transition:all .3s ease}select:hover{border-color:rgba(59,130,246,0.6);box-shadow:0 0 15px rgba(59,130,246,0.3)}.slider-group{display:flex;flex-direction:column;align-items:center;gap:.5rem}.slider-group label{font-size:.9rem;font-weight:600;color:rgba(255,255,255,0.9);text-align:center;text-shadow:0 1px 2px rgba(0,0,0,0.5)}.slider-group input[type="range"]{width:140px;height:6px;background:linear-gradient(90deg,rgba(59,130,246,0.3) 0%,rgba(59,130,246,0.8) 100%);border-radius:3px;outline:0;-webkit-appearance:none}.slider-group input[type="range"]::-webkit-slider-thumb{-webkit-appearance:none;width:18px;height:18px;background:linear-gradient(135deg,#3b82f6 0%,#2563eb 100%);border-radius:50%;cursor:pointer;box-shadow:0 2px 8px rgba(59,130,246,0.5)}.slider-group input[type="range"]::-moz-range-thumb{width:18px;height:18px;background:linear-gradient(135deg,#3b82f6 0%,#2563eb 100%);border-radius:50%;cursor:pointer;border:0;box-shadow:0 2px 8px rgba(59,130,246,0.5)}.slider-group .value{font-family:'SF Mono','Monaco','Inconsolata','Roboto Mono',monospace;font-size:.85rem;color:#3b82f6;font-weight:600;background:rgba(59,130,246,0.1);padding:.25rem .5rem;border-radius:4px;border:1px solid rgba(59,130,246,0.3)}#orbit-viz-container{position:relative;width:100%;aspect-ratio:16/9;background:radial-gradient(ellipse at center,#0f172a 0%,#000 70%);border:1px solid rgba(59,130,246,0.3);border-radius:16px;overflow:hidden;margin-bottom:1.5rem;box-shadow:0 8px 25px rgba(0,0,0,0.4),inset 0 1px 0 rgba(255,255,255,0.1)}#orbit-viz{width:100%;height:100%}#orbit-hud{background:linear-gradient(135deg,rgba(30,41,59,0.9) 0%,rgba(15,23,42,0.95) 100%);border:1px solid rgba(59,130,246,0.3);border-radius:16px;padding:1.5rem;display:grid;grid-template-columns:repeat(auto-fit,minmax(320px,1fr));gap:1.5rem;box-shadow:0 8px 25px rgba(0,0,0,0.2),inset 0 1px 0 rgba(255,255,255,0.1)}
.hud-panel{background:linear-gradient(135deg,rgba(59,130,246,0.1) 0%,rgba(30,58,138,0.05) 100%);border:1px solid rgba(59,130,246,0.3);border-radius:12px;padding:1rem;transition:all .3s ease;box-shadow:0 4px 15px rgba(0,0,0,0.1)}.hud-panel:hover{border-color:rgba(59,130,246,0.5);box-shadow:0 6px 20px rgba(0,0,0,0.2),0 0 15px rgba(59,130,246,0.2);transform:translateY(-2px)}.hud-panel h4{color:#60a5fa;margin-bottom:.75rem;font-size:1rem;font-weight:600;text-transform:uppercase;letter-spacing:.75px;text-shadow:0 1px 2px rgba(0,0,0,0.5);border-bottom:2px solid rgba(59,130,246,0.3);padding-bottom:.5rem}.hud-value{font-family:'SF Mono','Monaco','Inconsolata','Roboto Mono',monospace;font-size:.9rem;color:var(--global-text-color);display:flex;justify-content:space-between;margin-bottom:.5rem;padding:.25rem 0;border-bottom:1px solid rgba(255,255,255,0.1)}.hud-value:last-child{border-bottom:0}.hud-value .label{color:rgba(255,255,255,0.7);font-weight:400}.hud-value .value{color:#60a5fa;font-weight:600;text-shadow:0 1px 2px rgba(0,0,0,0.5)}#orbit-status{font-family:'SF Mono','Monaco','Inconsolata','Roboto Mono',monospace;font-size:1rem;color:#60a5fa;padding:1rem;background:linear-gradient(135deg,rgba(59,130,246,0.1) 0%,rgba(30,58,138,0.05) 100%);border:1px solid rgba(59,130,246,0.3);border-radius:12px;text-align:center;grid-column:1 / -1;margin-top:1rem;box-shadow:0 4px 15px rgba(0,0,0,0.1);text-shadow:0 1px 2px rgba(0,0,0,0.5)}.scenario-button{background:linear-gradient(135deg,var(--global-theme-color) 0%,rgba(59,130,246,0.8) 100%);color:white;border:0;padding:.75rem 1rem;border-radius:8px;cursor:pointer;font-size:.85rem;font-weight:500;transition:all .3s ease;box-shadow:0 4px 15px rgba(0,0,0,0.2),0 0 0 1px rgba(255,255,255,0.1)}.scenario-button:hover{transform:translateY(-1px) scale(1.02);box-shadow:0 6px 20px rgba(0,0,0,0.3),0 0 15px rgba(59,130,246,0.4)}.burn-info{font-size:.75rem;color:rgba(255,255,255,0.7);text-align:center;margin-bottom:.5rem;padding:.5rem;background:rgba(59,130,246,0.1);border-radius:6px;border:1px solid rgba(59,130,246,0.2)}.scenario-grid{display:grid;grid-template-columns:repeat(3,1fr);gap:.5rem;width:100%}.scenario-grid .scenario-button{padding:.6rem .4rem;font-size:.75rem;line-height:1.2;min-height:60px;display:flex;align-items:center;justify-content:center;text-align:center}.burn-effect{position:absolute;pointer-events:none;border-radius:50%;animation:burnPulse .6s ease-out}@keyframes burnPulse{0%{transform:scale(0);opacity:1}100%{transform:scale(3);opacity:0}}@media(max-width:768px){#orbit-container{margin:1rem;padding:1rem}#orbit-controls{grid-template-columns:1fr;gap:1rem;padding:1rem}.control-group{align-items:stretch}.control-row{justify-content:stretch}.burn-button{flex:1;padding:1rem}#orbit-hud{grid-template-columns:1fr;padding:1rem}}.no-webgl{display:flex;align-items:center;justify-content:center;height:100%;font-size:1.2rem;color:rgba(255,255,255,0.7);text-align:center;padding:2rem;background:linear-gradient(135deg,rgba(239,68,68,0.1) 0%,rgba(220,38,38,0.1) 100%);border:1px solid rgba(239,68,68,0.3);border-radius:12px}.loading{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);color:#60a5fa;font-size:1.2rem;font-weight:600;text-shadow:0 1px 2px rgba(0,0,0,0.5)}.loading::after{content:'';animation:loadingDots 1.5s infinite}@keyframes loadingDots{0%,20%{content:'.'}40%{content:'..'}60%,100%{content:'...'}}.units-legend{margin:0 0 1rem 0;padding:.75rem 1rem;font-size:.9rem;color:rgba(255,255,255,0.85);background:linear-gradient(135deg,rgba(59,130,246,0.08) 0%,rgba(15,23,42,0.3) 100%);border:1px solid rgba(59,130,246,0.25);border-radius:10px}.toast{position:fixed;top:20px;right:20px;max-width:400px;padding:1rem 1.25rem;background:linear-gradient(135deg,rgba(59,130,246,0.95) 0%,rgba(30,58,138,0.98) 100%);border:1px solid rgba(59,130,246,0.8);border-radius:12px;color:white;font-size:.95rem;font-weight:500;box-shadow:0 8px 25px rgba(0,0,0,0.4),0 0 20px rgba(59,130,246,0.6);transform:translateX(450px);transition:transform .4s cubic-bezier(0.4,0,0.2,1);z-index:1000;backdrop-filter:blur(10px);text-shadow:0 1px 2px rgba(0,0,0,0.5)}.toast.show{transform:translateX(0)}.toast .toast-icon{display:inline-block;margin-right:.5rem;font-size:1.1em}.phase-gauge{background:linear-gradient(135deg,rgba(59,130,246,0.1) 0%,rgba(30,58,138,0.05) 100%);border:1px solid rgba(59,130,246,0.3);border-radius:12px;padding:1rem;box-shadow:0 4px 15px rgba(0,0,0,0.1)}.phase-gauge h4{color:#60a5fa;margin-bottom:.75rem;font-size:1rem;font-weight:600;text-transform:uppercase;letter-spacing:.75px;border-bottom:2px solid rgba(59,130,246,0.3);padding-bottom:.5rem}.phase-gauge .row{display:flex;justify-content:space-between;font-family:'SF Mono','Monaco','Inconsolata','Roboto Mono',monospace;font-size:.9rem;margin:.25rem 0}
.phase-bar{position:relative;height:10px;border-radius:6px;background:rgba(255,255,255,0.08);margin-top:.5rem;overflow:hidden;border:1px solid rgba(255,255,255,0.15)}.phase-fill{position:absolute;top:0;left:0;bottom:0;width:0;background:linear-gradient(90deg,rgba(34,197,94,0.8),rgba(59,130,246,0.8))}.phase-status{margin-top:.5rem;text-align:center;font-weight:700}.phase-status.ready{color:#22c55e}.phase-status.wait{color:#f59e0b}.phase-status.na{color:rgba(255,255,255,0.6)}.sprite-label{filter:drop-shadow(0 0 2px rgba(0,0,0,0.7))}body.performance-mode .burn-button{box-shadow:0 2px 8px rgba(0,0,0,0.15)!important}body.performance-mode .hud-panel{box-shadow:0 2px 8px rgba(0,0,0,0.08)!important}body.performance-mode .toast{box-shadow:0 4px 12px rgba(0,0,0,0.2)!important;backdrop-filter:none!important}body.performance-mode #orbit-container{box-shadow:0 8px 30px rgba(0,0,0,0.2)!important;backdrop-filter:none!important}.keyboard-shortcuts{position:fixed;bottom:20px;left:20px;background:rgba(15,23,42,0.95);border:1px solid rgba(59,130,246,0.3);border-radius:8px;padding:.75rem;font-size:.8rem;color:rgba(255,255,255,0.8);max-width:200px;transform:translateY(200px);transition:transform .3s ease;z-index:999}.keyboard-shortcuts.show{transform:translateY(0)}.keyboard-shortcuts h5{color:#60a5fa;margin-bottom:.5rem;font-size:.9rem}.keyboard-shortcuts div{margin:.25rem 0}.keyboard-shortcuts kbd{background:rgba(59,130,246,0.2);border:1px solid rgba(59,130,246,0.4);border-radius:3px;padding:.1rem .3rem;font-size:.75rem;margin-right:.5rem}</style> <div class="units-legend" aria-live="polite"> <strong>Try this:</strong> Press <kbd>X</kbd> to burn <em>retrograde</em> and drop to a lower, faster orbit. Watch the phase angle close, then press <kbd>Z</kbd> at periapsis/apoapsis to raise and circularize. </div> <div id="orbit-container"> <div id="orbit-controls"> <div class="control-group"> <label><strong>Simulation Control</strong></label> <div class="control-row"> <button id="orbit-play-pause" aria-label="Play or pause simulation">Pause</button> <button id="orbit-reset" aria-label="Reset simulation">Reset</button> </div> </div> <div class="control-group"> <label><strong>Burn Controls</strong></label> <div class="burn-info"> <small>+V: Prograde (speed up) | -V: Retrograde (slow down)<br/> +R: Radial out (away from Earth) | -R: Radial in (toward Earth)</small> </div> <div class="control-row"> <button class="burn-button prograde" id="burn-prograde" aria-label="Burn prograde">+V</button> <button class="burn-button retrograde" id="burn-retrograde" aria-label="Burn retrograde">-V</button> </div> <div class="control-row"> <button class="burn-button radial-out" id="burn-radial-out" aria-label="Burn radial out">+R</button> <button class="burn-button radial-in" id="burn-radial-in" aria-label="Burn radial in">-R</button> </div> </div> <div class="slider-group"> <label for="burn-magnitude">Burn Magnitude</label> <input type="range" id="burn-magnitude" min="0.005" max="0.1" step="0.005" value="0.03" aria-label="Burn magnitude"/> <span class="value" id="burn-magnitude-value">0.03</span> </div> <div class="slider-group"> <label for="time-scale">Time Scale</label> <input type="range" id="time-scale" min="0.1" max="10" step="0.1" value="1.0" aria-label="Time scale"/> <span class="value" id="time-scale-value">1.0×</span> </div> <div class="control-group"> <label><strong>Scenarios</strong></label> <div class="scenario-grid"> <button class="scenario-button" id="scenario-basic" aria-label="Load Basic Phasing scenario">Basic<br/>Phasing</button> <button class="scenario-button" id="scenario-hohmann" aria-label="Load Hohmann Transfer scenario">Hohmann<br/>Transfer</button> <button class="scenario-button" id="scenario-rendezvous" aria-label="Load R-bar Approach scenario">R-bar<br/>Approach</button> </div> <div class="control-row" style="margin-top: 0.5rem;"> <label for="real-world-units" style="display:flex;align-items:center;gap:0.4rem;"> <input type="checkbox" id="real-world-units" aria-label="Toggle real-world units (km, km/s, minutes)"/> Real-world units (km, km/s, min) </label> </div> </div> </div> <div class="units-legend"> <strong>Units:</strong> Earth radius R⊕ = 1, gravitational parameter μ = 1, time unit TU satisfies \(T=2\pi\sqrt{a^3/\mu}\), and speeds are in VU from vis-viva. </div> <div id="orbit-viz-container"> <div id="orbit-viz"></div> </div> <div id="orbit-hud"> <div class="hud-panel"> <h4>Chaser Spacecraft</h4> <div class="hud-value"> <span class="label">Semi-major axis:</span> <span class="value" id="chaser-a">1.000 R⊕</span> </div> <div class="hud-value"> <span class="label">Eccentricity:</span> <span class="value" id="chaser-e">0.000</span> </div> <div class="hud-value"> <span class="label">Period:</span> <span class="value" id="chaser-period">1.00 TU</span> </div> <div class="hud-value"> <span class="label">Speed:</span> <span class="value" id="chaser-speed">1.000 VU</span> </div> </div> <div class="hud-panel"> <h4>Target Spacecraft</h4> <div class="hud-value"> <span class="label">Semi-major axis:</span> <span class="value" id="target-a">1.000 R⊕</span> </div> <div class="hud-value"> <span class="label">Eccentricity:</span> <span class="value" id="target-e">0.000</span> </div> <div class="hud-value"> <span class="label">Period:</span> <span class="value" id="target-period">1.00 TU</span> </div> <div class="hud-value"> <span class="label">Phase angle:</span> <span class="value" id="phase-angle">0.0°</span> </div> </div> <div class="hud-panel"> <h4>Relative Motion</h4> <div class="hud-value"> <span class="label">Range:</span> <span class="value" id="relative-range">0.000 R⊕</span> </div> <div class="hud-value"> <span class="label">Closing rate:</span> <span class="value" id="closing-rate">0.000 VU</span> </div> <div class="hud-value"> <span class="label">ΔV budget used:</span> <span class="value" id="dv-budget">0.000 VU</span> </div> <div class="hud-value"> <span class="label">Time to closest approach:</span> <span class="value" id="time-to-ca">-- TU</span> </div> <div class="hud-value"> <span class="label">Min range:</span> <span class="value" id="min-range">-- R⊕</span> </div> </div> <div class="phase-gauge"> <h4>Phase Gauge</h4> <div class="row"> <span>Current:</span> <span id="phase-current">0.0°</span> </div> <div class="row"> <span>Desired:</span> <span id="phase-desired">—</span> </div> <div class="row"> <span>Error:</span> <span id="phase-error">—</span> </div> <div class="phase-bar"> <div class="phase-fill" id="phase-fill"></div> </div> <div class="phase-status na" id="phase-status">N/A</div> </div> </div> <div id="orbit-status">Simulation ready. Use burn controls to maneuver the chaser spacecraft.</div> </div> <h2 id="what-you-can-do">What You Can Do</h2> <ul> <li>Use +V/−V (prograde/retrograde) to raise/lower the opposite side of your orbit; tweak Burn Magnitude for gentle taps.</li> <li>Try +R/−R (radial out/in) to rotate the ellipse within the plane; great for small phasing trims and lining up periapsis/apoapsis.</li> <li>Adjust Time Scale to observe slow‑motion vs. accelerated orbits; watch HUD values update in real time.</li> <li>Toggle Real‑world units to see km, km/s, and minutes alongside the normalized units used in the sim.</li> <li>Load scenarios (Basic Phasing, Hohmann, R‑bar) and follow the on‑screen HUD to hit the objectives.</li> </ul> <h2 id="how-the-simulator-works">How The Simulator Works</h2> <ul> <li>Two‑body, coplanar model: Earth is fixed; we integrate motion in normalized units with Earth radius R⊕ = 1 and μ = 1.</li> <li>Propagation: advance true anomaly via Kepler’s equation and mean motion; speed from vis‑viva; positions from orbital elements.</li> <li>Impulsive burns: convert elements → state, add Δv in the LVLH frame, then convert back to elements.</li> <li>Closest approach: periodically predict min range over ~1.5 periods to estimate time‑to‑CA and min range.</li> <li>HUD: shows each vehicle’s a, e, period, speed; relative range and closing rate; total ΔV spent; current/desired phase angle.</li> </ul> <h2 id="lvlh-visual-intuition">LVLH Visual Intuition</h2> <div style="text-align:center; margin: 1rem 0;"> <svg viewBox="0 0 400 240" width="560" height="380" style="max-width: 100%; background: #0f1117; border: 1px solid #222; border-radius: 10px;"> <circle cx="200" cy="120" r="22" fill="#0f2744" stroke="#60a5fa" stroke-opacity="0.35"/> <circle cx="200" cy="120" r="100" fill="none" stroke="#334155" stroke-dasharray="6 6"/> <circle cx="300" cy="120" r="4" fill="#e879f9"/> <g stroke-width="2" font-size="12"> <line x1="300" y1="120" x2="330" y2="120" stroke="#22c55e"/> <text x="335" y="124" fill="#22c55e" text-anchor="start">+R (radial)</text> <line x1="300" y1="120" x2="300" y2="90" stroke="#60a5fa"/> <text x="258" y="84" fill="#60a5fa" text-anchor="start">+V (prograde)</text> </g> </svg> <div style="color:#94a3b8; font-size: 0.95rem; margin-top: 0.25rem;">Burns are applied in LVLH: +V tangential, +R radial.</div> </div> <h2 id="scenario-guides">Scenario Guides</h2> <ul> <li>Basic Phasing: Catch the target ahead by going lower/faster. <ul> <li>Steps: Press −V once; let the phase angle shrink; when aligned, press +V to re-circularize.</li> <li>Check: Phase angle → 0; chaser period &lt; target; min range drops; modest ΔV.</li> </ul> </li> <li>Hohmann Transfer: Change orbits efficiently with two burns. <ul> <li>Steps: At periapsis press +V to enter transfer; coast; at apoapsis press +V to circularize with target.</li> <li>Check: Semi-major axis matches target after second burn; periods match; range trending down.</li> </ul> </li> <li>R-bar Approach: Safe final approach along the radial corridor. <ul> <li>Steps: Use small −R pulses to reduce range; keep closing rate small; null out relative motion near capture.</li> <li>Check: Closing rate near 0 at short range; relative ellipse shrinks; ΔV stays small and controlled.</li> </ul> </li> </ul> <h2 id="experiments-to-try">Experiments To Try</h2> <ul> <li>Phase to a number: set the target 30° ahead; do a small −V to drop lower, coast until phase error ≈ 0°, then +V to recircularize.</li> <li>“Wrong place” burn: try +V at apoapsis vs. at periapsis; note which side of the orbit rises and how the period changes.</li> <li>Radial trims: use short +R/−R taps to rotate periapsis alignment to the target’s true anomaly before doing +V.</li> <li>ΔV budgeting: reduce Burn Magnitude and aim to complete each scenario with minimum total ΔV in the HUD.</li> </ul> <h2 id="faq--pitfalls">FAQ &amp; Pitfalls</h2> <ul> <li>I sped up but fell behind: expected—+V at periapsis makes the opposite side higher and the overall period longer; you arrive later there.</li> <li>My transfer missed the target altitude: your first +V was too large or at the wrong place; burns are most efficient at apses.</li> <li>Radial burns seem useless: they don’t change energy much; they rotate the ellipse—use them for alignment tweaks, not big transfers.</li> <li>Numbers don’t look like km/s: enable Real‑world units; otherwise values are in normalized TU/VU/R⊕.</li> <li>Time step artifacts: if fast‑forwarding, expect small differences in closest‑approach predictions; slow down to verify.</li> </ul> <h2 id="the-mathematics-of-orbital-motion">The Mathematics of Orbital Motion</h2> <p>Understanding orbital rendezvous requires a few key equations — each answers a practical question you’ll use in the sim.</p> <h3 id="vis-viva-equation">Vis-Viva Equation</h3> <p>Why it matters: Predict local speed from orbit size — explains why “lower = faster.”</p> \[V = \sqrt{\mu\left(\frac{2}{r} - \frac{1}{a}\right)}\] <p>Where:</p> <ul> <li>$V$ = orbital velocity</li> <li>$\mu$ = gravitational parameter (GM)</li> <li>$r$ = current distance from center</li> <li>$a$ = semi-major axis</li> </ul> <p>This equation tells us why <strong>lower orbits are faster</strong>—as $a$ decreases, $V$ increases.</p> <h3 id="keplers-third-law">Kepler’s Third Law</h3> <p>Why it matters: Predict orbital period — phasing works because periods differ.</p> \[T = 2\pi\sqrt{\frac{a^3}{\mu}}\] <p>This is why phasing maneuvers work: the spacecraft in the lower orbit completes more revolutions and can “catch up” to a target in a higher orbit.</p> <h3 id="mean-motion-and-keplers-equation">Mean Motion and Kepler’s Equation</h3> <p>Why it matters: Convert time → position along an ellipse.</p> <p><strong>Mean motion</strong> (average angular velocity): \(n = \sqrt{\frac{\mu}{a^3}}\)</p> <p><strong>Kepler’s equation</strong> (relating time to orbital position): \(M = E - e \sin E\)</p> <p>Where:</p> <ul> <li>$M$ = mean anomaly (average position)</li> <li>$E$ = eccentric anomaly</li> <li>$e$ = eccentricity</li> </ul> <h3 id="eccentric-anomaly-relations">Eccentric Anomaly Relations</h3> <p>Why it matters: Convert ellipse parameterizations to the true angle you see in the sim.</p> \[\tan\left(\frac{E}{2}\right) = \sqrt{\frac{1-e}{1+e}} \tan\left(\frac{\nu}{2}\right)\] <p>Where $\nu$ is the <strong>true anomaly</strong> (actual angular position in orbit).</p> <h2 id="orbital-elements-and-state-vectors">Orbital Elements and State Vectors</h2> <p>Every orbit can be described by six <strong>orbital elements</strong>:</p> <ol> <li><strong>Semi-major axis (a)</strong>: Size of the orbit</li> <li><strong>Eccentricity (e)</strong>: Shape of the orbit (0 = circular, &gt;0 = elliptical)</li> <li><strong>Inclination (i)</strong>: Angle relative to equatorial plane</li> <li><strong>Right ascension of ascending node (Ω)</strong>: Orientation in space</li> <li><strong>Argument of periapsis (ω)</strong>: Orientation of ellipse in orbital plane</li> <li><strong>True anomaly (ν)</strong>: Position along the orbit</li> </ol> <p>For our <strong>coplanar</strong> simulation, we simplify to just $(a, e, ω, ν)$ since $i = Ω = 0$.</p> <h3 id="converting-between-elements-and-state-vectors">Converting Between Elements and State Vectors</h3> <p><strong>Position in orbital plane:</strong> \(r = \frac{a(1-e^2)}{1 + e\cos\nu}\)</p> \[\vec{r} = r[\cos(\omega + \nu), \sin(\omega + \nu), 0]\] <p><strong>Velocity direction</strong> (perpendicular to radius, adjusted for eccentricity): \(\vec{v} = \sqrt{\frac{\mu}{a(1-e^2)}}[-\sin(\omega + \nu), e + \cos(\omega + \nu), 0]\)</p> <p>Note: Use vis‑viva above for speed; this section provides the direction.</p> <h2 id="lvlh-coordinate-frame">LVLH Coordinate Frame</h2> <p>In spacecraft operations, engineers use the <strong>Local Vertical Local Horizontal (LVLH)</strong> frame, also called the <strong>Hill frame</strong>:</p> <ul> <li><strong>R-bar</strong>: Radial direction (toward/away from Earth)</li> <li><strong>V-bar</strong>: Velocity direction (prograde/retrograde)</li> <li><strong>H-bar</strong>: Angular momentum direction (out-of-plane)</li> </ul> <p><strong>Why This Matters</strong>: When mission controllers say “burn prograde” or “approach along the R-bar,” they’re using this coordinate system. It’s the natural reference frame for orbital operations.</p> <h3 id="lvlh-unit-vectors">LVLH Unit Vectors</h3> <p>At any point in orbit:</p> \[\hat{R} = \frac{\vec{r}}{|\vec{r}|} \quad \text{(radial)}\] \[\hat{V} = \frac{\vec{v}}{|\vec{v}|} \quad \text{(prograde)}\] \[\hat{H} = \frac{\vec{r} \times \vec{v}}{|\vec{r} \times \vec{v}|} \quad \text{(normal)}\] <h2 id="rendezvous-strategy-the-three-phase-approach">Rendezvous Strategy: The Three-Phase Approach</h2> <p>Real spacecraft rendezvous follows a systematic approach:</p> <h3 id="phase-1-phasing">Phase 1: Phasing</h3> <ul> <li>Lower the chaser’s orbit to make it faster</li> <li>Wait for proper phase alignment</li> <li>Multiple revolutions may be required</li> </ul> <h3 id="phase-2-transfer">Phase 2: Transfer</h3> <ul> <li>Execute Hohmann transfer or similar maneuver</li> <li>Time the burn for intercept geometry</li> <li>Monitor closest approach predictions</li> </ul> <h3 id="phase-3-final-approach">Phase 3: Final Approach</h3> <ul> <li>Small, precise burns in LVLH frame</li> <li>Approach along R-bar or V-bar for safety</li> <li>Maintain relative motion control</li> </ul> <blockquote> <p>Why it matters: Split the problem. Phase to align timing, transfer to meet geometry, then finalize relative motion safely.</p> </blockquote> <h2 id="advanced-topic-clohessy-wiltshire-equations">Advanced Topic: Clohessy-Wiltshire Equations</h2> <p>For <strong>close-proximity operations</strong>, we can linearize the relative motion equations around a circular orbit. This gives us the <strong>Clohessy-Wiltshire equations</strong>:</p> <p>\(\ddot{x} - 3n^2 x - 2n\dot{y} = 0\) \(\ddot{y} + 2n\dot{x} = 0\) \(\ddot{z} + n^2 z = 0\)</p> <p>Where:</p> <ul> <li>$x$ = radial separation (R-bar)</li> <li>$y$ = along-track separation (V-bar)</li> <li>$z$ = cross-track separation (H-bar)</li> <li>$n$ = target’s mean motion</li> </ul> <p>These equations predict that <strong>small relative motions follow elliptical paths</strong> in the orbital plane—exactly what you see in the final phases of ISS approaches.</p> <p>Try this (R‑bar): Load “R‑bar Approach.” Use tiny −R pulses to start closing, then alternate small +R/−R pulses to keep the relative ellipse centered while the closing rate trends to zero.</p> <h3 id="physical-interpretation">Physical Interpretation</h3> <p>The CW equations reveal fascinating physics:</p> <ul> <li><strong>Radial motion couples to along-track motion</strong> through Coriolis effects</li> <li><strong>A radial impulse creates a closed elliptical trajectory</strong></li> <li><strong>Along-track motion has a secular drift component</strong></li> </ul> <p>This is why spacecraft approaching the ISS follow specific <strong>R-bar</strong> or <strong>V-bar</strong> approach corridors—it’s the safest way to maintain predictable relative motion.</p> <h2 id="real-world-applications">Real-World Applications</h2> <p>This isn’t just theoretical—every spacecraft rendezvous uses these principles:</p> <h3 id="international-space-station-iss">International Space Station (ISS)</h3> <ul> <li><strong>Cargo Dragon</strong>: Approaches along the <strong>R-bar</strong> (from below/radial) to a capture point near the station.</li> <li><strong>Crew Dragon</strong>: Similar R-bar profile with multiple hold points and built-in abort options.</li> <li><strong>Progress/Soyuz</strong>: Russian vehicles use largely automated rendezvous along established corridors.</li> <li><strong>Cygnus</strong>: Also follows an R-bar approach and is grappled by the robotic arm.</li> </ul> <h3 id="historical-missions">Historical Missions</h3> <ul> <li><strong>Apollo</strong>: Lunar Module rendezvous with Command Module</li> <li><strong>Space Shuttle</strong>: Dozens of ISS construction flights</li> <li><strong>Hubble Servicing</strong>: Precision rendezvous for maintenance</li> </ul> <h3 id="future-applications">Future Applications</h3> <ul> <li><strong>Artemis</strong>: Lunar Gateway rendezvous operations</li> <li><strong>Commercial stations</strong>: Multiple private stations planned</li> <li><strong>On-orbit servicing</strong>: Satellite refueling and repair</li> <li><strong>Debris removal</strong>: Active cleanup missions</li> </ul> <h2 id="why-i-love-teaching-this">Why I Love Teaching This</h2> <p>Here’s the thing that absolutely blows my mind about orbital mechanics: it’s completely backwards from everything we experience on Earth. I’ve spent countless hours watching spacecraft approach the ISS, and every single time I’m amazed by how they do it.</p> <p>When I first learned about orbital rendezvous, I thought it would work like driving a car—speed up to catch up, right? <strong>Wrong.</strong> So incredibly wrong. And that’s exactly why I built this simulation.</p> <h2 id="the-stories-behind-each-scenario">The Stories Behind Each Scenario</h2> <p>I’ve included three different scenarios that represent real missions I’ve watched unfold. Each one teaches you something different about the beautiful, frustrating, counter-intuitive world of orbital mechanics.</p> <h3 id="scenario-1-the-chase-basic-phasing">Scenario 1: “The Chase” (Basic Phasing)</h3> <p><strong>This is my favorite one to mess with people’s heads.</strong></p> <p>Picture this: You’re an astronaut in a spacecraft, and you can see your target—maybe the ISS—ahead of you in the same orbit. Your instinct? Fire the engines and speed up to catch it, obviously.</p> <p><strong>Here’s what actually happens:</strong> You speed up, which raises the back half of your orbit, which means you’re now in a bigger orbit, which means you’re actually going <em>slower</em> on average. The target pulls further ahead. Congratulations, you just made things worse.</p> <p><strong>The mind-bending solution?</strong> Slow down. Seriously. Hit that <strong>-V button</strong> and drop into a lower orbit. Now you’re closer to Earth, moving faster, and you’ll gradually catch up over the next few orbits. It’s like taking the inside lane on a racetrack.</p> <p><strong>Real talk:</strong> This is exactly how every SpaceX Dragon mission catches up to the ISS. They launch into a lower orbit and spend about a day chasing the station from below. Every time I watch a launch, I think about how this breaks everyone’s brain the first time they learn it.</p> <h3 id="scenario-2-the-elegant-dance-hohmann-transfer">Scenario 2: “The Elegant Dance” (Hohmann Transfer)</h3> <p><strong>This one is pure poetry in motion.</strong></p> <p>Walter Hohmann figured this out in 1925—before we’d even put anything in orbit—and it’s still the most elegant way to change altitudes in space. It’s like orbital ballroom dancing: two perfectly timed moves, separated by a graceful coast through space.</p> <p><strong>Here’s how the dance works:</strong></p> <ol> <li><strong>First move (+V):</strong> Burn prograde at your lowest point. This raises the top of your orbit to match your target’s altitude.</li> <li><strong>The coast:</strong> Follow your new elliptical path for exactly half an orbit. This is where patience pays off.</li> <li><strong>Second move (+V):</strong> Another prograde burn at the high point to circularize. Now you’re dancing at the same altitude.</li> </ol> <p><strong>The magic is in the timing.</strong> You have to time that first burn so that when you arrive at the high point, your target is waiting there for you. Miss the timing, and you’re playing cosmic tag in the worst possible way.</p> <p><strong>This blew my mind:</strong> Apollo’s trans-lunar injection used a <strong>Hohmann-like</strong> transfer timed with the Moon’s motion; the same elegant, energy-efficient idea shows up everywhere in mission design.</p> <h3 id="scenario-3-the-final-approach-r-bar-approach">Scenario 3: “The Final Approach” (R-bar Approach)</h3> <p><strong>This is where it gets really precise—and really nerve-wracking.</strong></p> <p>Imagine you’re the pilot of a cargo ship approaching the ISS. You’re close now—maybe a few kilometers away. Every move you make could be your last if you mess it up. There are people inside that station, and you’re carrying tons of supplies hurtling through space at 17,500 mph.</p> <p><strong>Why the R-bar approach is brilliant:</strong> Instead of approaching directly (which would be terrifying), you approach along the “R-bar”—the imaginary line pointing straight down toward Earth. If something goes wrong, you don’t crash into the station—you just drop away toward Earth.</p> <p><strong>The technique:</strong> Tiny <strong>-R burns</strong> that nudge you inward along this safe corridor. The relative motion follows these beautiful, predictable patterns that mathematicians call Clohessy-Wiltshire equations (don’t worry about the math—just know it works).</p> <p><strong>I’ve watched this happen live:</strong> During ISS approaches, NASA’s mission control guides the spacecraft along this exact path. You can see it on their live streams—the slow, careful approach from directly below the station. It looks almost gentle, but it’s the result of decades of learning how to do this safely.</p> <h2 id="ready-to-break-your-brain">Ready to Break Your Brain?</h2> <p>Here’s what I want you to try. Start with these scenarios and prepare to have your Earth-based intuition completely shattered:</p> <p><strong>Start with “The Chase”:</strong> Click Basic Phasing, then resist every instinct you have. When you see that target ahead of you, hit <strong>-V</strong> instead of +V. Watch the magic happen over several orbits. It feels wrong, but it works.</p> <p><strong>Try “The Dance”:</strong> Load up Hohmann Transfer and practice the two-burn sequence. Hit <strong>+V</strong> at the bottom of your orbit, coast patiently, then <strong>+V</strong> again at the top. Time it right and you’ll intercept your target perfectly.</p> <p><strong>Master “The Approach”:</strong> R-bar Approach lets you practice the final phase that every ISS visitor uses. Small <strong>-R burns</strong> only. Watch how controlled and predictable everything stays.</p> <p>The first time I got these right, I felt like I’d unlocked some secret of the universe. Because in a way, I had.</p> <h2 id="wait-why-does-v-sometimes-shrink-my-orbit">“Wait, Why Does +V Sometimes Shrink My Orbit?”</h2> <p><strong>This question breaks everyone’s brain the first time.</strong> You’re not going crazy, and it’s definitely not a bug. This is orbital mechanics being its beautifully weird self.</p> <p>Here’s what’s actually happening when you hit +V (prograde burn):</p> <h3 id="the-energy-distribution-dance">The Energy Distribution Dance</h3> <p>When you fire prograde, you’re adding energy to your orbit. But here’s the kicker—<strong>that energy doesn’t just make you go faster where you are</strong>. Instead, it gets distributed around your entire orbital path in a very specific way.</p> <p><strong>The fundamental rule:</strong> A prograde burn raises the <em>opposite side</em> of your orbit from where you’re currently located.</p> <h3 id="why-this-happens">Why This Happens</h3> <p>Think of your orbit like a rubber band around Earth. When you “stretch” one part by adding energy, the opposite part moves further out. So:</p> <ul> <li><strong>Burn at the bottom of your orbit?</strong> You raise the top</li> <li><strong>Burn at the top of your orbit?</strong> You raise the bottom</li> <li><strong>Burn anywhere in between?</strong> You raise the opposite side</li> </ul> <h3 id="what-youre-actually-seeing">What You’re Actually Seeing</h3> <p>The “Semi-major axis” in the HUD shows your orbit’s average radius—and yes, +V <em>always</em> increases this. But here’s where it gets weird:</p> <ol> <li><strong>Right after the burn:</strong> Your current position might show a smaller radius if you were at a high point and the burn raised the opposite (low) point more than your current position</li> <li><strong>As you continue orbiting:</strong> You’ll see your altitude vary more dramatically because your orbit is now more elliptical</li> </ol> <h3 id="the-real-world-example">The Real-World Example</h3> <p>This is exactly why the Apollo Command Module had to do <strong>two</strong> separate burns to reach the Moon:</p> <ol> <li>First burn raised their apoapsis to lunar distance</li> <li>But they were still at low altitude—they had to coast all the way around to that high point</li> <li>Second burn at the high point raised their periapsis to complete the transfer</li> </ol> <h3 id="pro-tip-for-the-simulation">Pro Tip for the Simulation</h3> <p>Watch both the <strong>semi-major axis</strong> (average orbit size) and your <strong>current altitude</strong> as you orbit. The semi-major axis tells you the real story—it always increases with +V burns. The current radius changes as you move around your now-elliptical orbit.</p> <p><strong>This behavior is pure physics, not a bug—and it’s exactly why orbital mechanics is so beautifully counter-intuitive!</strong></p> <h2 id="help-my-hohmann-transfer-went-crazy">“Help! My Hohmann Transfer Went Crazy!”</h2> <p><strong>You’re discovering why rocket scientists do so much math before pressing buttons!</strong></p> <p>If your second +V burn in the Hohmann Transfer scenario is sending your orbit into the stratosphere, you’re experiencing one of the most important lessons in spaceflight: <strong>burn magnitude matters. A lot.</strong></p> <h3 id="whats-actually-happening">What’s Actually Happening</h3> <p>The Hohmann transfer is incredibly sensitive to burn timing and magnitude. Here’s what’s going wrong:</p> <ol> <li><strong>Your first burn was probably too big</strong>: This created a transfer orbit that’s larger than intended</li> <li><strong>When you reached apoapsis</strong>: You’re now much higher than the target orbit</li> <li><strong>The second burn</strong>: Instead of circularizing at the target altitude, it’s adding energy to an already high orbit</li> </ol> <h3 id="the-real-world-parallel">The Real-World Parallel</h3> <p>This is exactly why SpaceX and NASA spend months calculating precise burn values. Get it wrong by even a few meters per second, and you miss your target by thousands of kilometers.</p> <h3 id="how-to-get-it-right">How to Get It Right</h3> <p>For the Hohmann Transfer scenario, try this:</p> <ol> <li><strong>Reduce your burn magnitude to ~0.02</strong> using the slider</li> <li><strong>First burn</strong>: One quick +V tap at your lowest point (periapsis)</li> <li><strong>Coast</strong>: Wait exactly half an orbit until you’re at the highest point</li> <li><strong>Second burn</strong>: Another small +V tap to circularize</li> </ol> <h3 id="the-math-behind-it">The Math Behind It</h3> <p>In the real world, the exact burn values for a Hohmann transfer are calculated using:</p> <ul> <li>First burn: ΔV₁ = √(μ/r₁) × (√(2r₂/(r₁+r₂)) - 1)</li> <li>Second burn: ΔV₂ = √(μ/r₂) × (1 - √(2r₁/(r₁+r₂)))</li> </ul> <p>For our scenario (1.2 to 1.4 Earth radii), these work out to much smaller values than the default 0.05 burn magnitude.</p> <h3 id="pro-tip">Pro Tip</h3> <p><strong>Watch the ghost trail!</strong> After your first burn, you’ll see a dashed line showing your predicted orbit. It should just barely touch the target’s orbital altitude. If it goes way beyond, your burn was too big.</p> <p><strong>This is why orbital mechanics is both beautiful and terrifying—tiny changes have huge consequences!</strong></p> <h2 id="the-counter-intuitive-truth">The Counter-Intuitive Truth</h2> <p>Now you understand why “speeding up makes you drop”:</p> <ul> <li>A <strong>prograde burn raises your apoapsis</strong> but may put you in a less favorable position</li> <li><strong>Lower orbits are faster</strong>, so dropping down can help you catch up</li> <li><strong>Orbital mechanics is about energy and angular momentum</strong>, not just instantaneous velocity</li> </ul> <p>This is the beautiful complexity of orbital mechanics—it requires thinking in terms of entire orbital paths, not just local motion. Every real spacecraft mission depends on these principles, from the smallest CubeSat to the largest space station.</p> <p>The next time you see a cargo ship approaching the ISS, you’ll know exactly why it takes that specific curved approach path and why the maneuvers seem so deliberate and careful. It’s not just caution—it’s the fundamental physics of orbital motion at work.</p> <script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
  }
}
</script> <script type="module/disabled">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

// Check WebGL support with actual context creation
const canvas = document.createElement('canvas');
const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
if (!gl) {
  document.getElementById('orbit-viz').innerHTML = '<div class="no-webgl">WebGL is not supported in your browser</div>';
  throw new Error('WebGL not supported');
}

// Show loading indicator
document.getElementById('orbit-viz').innerHTML = '<div class="loading">Loading Orbital Simulator</div>';

// Normalized units: Earth radius = 1, μ = 1
const EARTH_RADIUS = 1.0;
const MU = 1.0; // Gravitational parameter

// Simulation parameters
let params = {
  playing: true,
  timeScale: 1.0,
  burnMagnitude: 0.05,
  dt: 0.01,
  realWorldUnits: false
};

// Real-world unit conversions
const EARTH_RADIUS_KM = 6371.0; // km
const TU_TO_SECONDS = Math.sqrt(EARTH_RADIUS_KM * EARTH_RADIUS_KM * EARTH_RADIUS_KM / 398600.4418); // √(R³/μ_Earth)
const VU_TO_KM_S = EARTH_RADIUS_KM / TU_TO_SECONDS; // km/s

// Simulation state
let time = 0;
let dvBudget = 0;
let currentScenario = null;

// Orbital elements for chaser and target [a, e, omega, nu]
let chaserElements = [1.0, 0.0, 0.0, 0.0];
let targetElements = [1.0, 0.0, 0.0, Math.PI/6]; // Start target ahead

// Three.js objects
let scene, camera, renderer, controls;
let earthMesh, chaserMesh, targetMesh;
let chaserTrail, targetTrail, ghostTrail;
let chaserTrailGeometry, targetTrailGeometry, ghostTrailGeometry;
let starField, ambientLight, directionalLight, pointLight;
let particleSystem, burnParticles = [];
let chaserGlow, targetGlow, earthGlow;

// Markers for chaser periapsis/apoapsis
let periMarker, apoMarker, periLabel, apoLabel;

// Ghost burn arrows for Hohmann guidance
let periBurnArrow, apoBurnArrow;

// Orbital mechanics functions
function keplerSolve(M, e, tolerance = 1e-8) {
  let E = M; // Initial guess
  for (let i = 0; i < 10; i++) {
    const dE = (E - e * Math.sin(E) - M) / (1 - e * Math.cos(E));
    E -= dE;
    if (Math.abs(dE) < tolerance) break;
  }
  return E;
}

function elementsToState(elements) {
  const [a, e, omega, nu] = elements;
  
  // Position magnitude
  const r = a * (1 - e * e) / (1 + e * Math.cos(nu));
  
  // Position vector
  const cosOmegaNu = Math.cos(omega + nu);
  const sinOmegaNu = Math.sin(omega + nu);
  const position = new THREE.Vector3(r * cosOmegaNu, r * sinOmegaNu, 0);
  
  // Velocity vector
  const h = Math.sqrt(MU * a * (1 - e * e)); // Angular momentum
  const cosNu = Math.cos(nu);
  const sinNu = Math.sin(nu);
  const cosOmega = Math.cos(omega);
  const sinOmega = Math.sin(omega);
  
  const vx = -(MU / h) * Math.sin(omega + nu);
  const vy = (MU / h) * (e + Math.cos(omega + nu));
  const velocity = new THREE.Vector3(vx, vy, 0);
  
  return { position, velocity, r, speed: velocity.length() };
}

function stateToElements(position, velocity) {
  const r = position.length();
  const v = velocity.length();
  
  // Angular momentum vector
  const h_vec = new THREE.Vector3().crossVectors(position, velocity);
  const h = h_vec.length();
  
  // Eccentricity vector
  const mu_r = MU / r;
  const e_vec = new THREE.Vector3()
    .crossVectors(velocity, h_vec)
    .divideScalar(MU)
    .sub(position.clone().normalize());
  const e = e_vec.length();
  
  // Semi-major axis
  const energy = 0.5 * v * v - mu_r;
  const a = -MU / (2 * energy);
  
  // Argument of periapsis and true anomaly
  let omega, nu;
  if (e < 1e-6) {
    // Circular orbit case - omega is undefined, set to 0 for consistency
    omega = 0;
    // True anomaly is just the position angle
    nu = Math.atan2(position.y, position.x);
    // Normalize to [0, 2π]
    while (nu < 0) nu += 2 * Math.PI;
    while (nu > 2 * Math.PI) nu -= 2 * Math.PI;
  } else {
    // Elliptical orbit case
    omega = Math.atan2(e_vec.y, e_vec.x);
    const cos_nu = e_vec.dot(position) / (e * r);
    const sin_nu = h_vec.dot(new THREE.Vector3().crossVectors(e_vec, position)) / (h * e * r);
    nu = Math.atan2(sin_nu, cos_nu);
  }
  
  return [a, e, omega, nu];
}

function propagateOrbit(elements, dt) {
  const [a, e, omega, nu_old] = elements;
  
  // Convert to eccentric anomaly
  const cos_E_old = (e + Math.cos(nu_old)) / (1 + e * Math.cos(nu_old));
  const sin_E_old = Math.sqrt(1 - e * e) * Math.sin(nu_old) / (1 + e * Math.cos(nu_old));
  const E_old = Math.atan2(sin_E_old, cos_E_old);
  
  // Mean anomaly
  const M_old = E_old - e * Math.sin(E_old);
  
  // Advance mean anomaly
  const n = Math.sqrt(MU / (a * a * a)); // Mean motion
  const M_new = M_old + n * dt;
  
  // Solve Kepler's equation
  const E_new = keplerSolve(M_new, e);
  
  // Convert back to true anomaly
  const cos_nu_new = (Math.cos(E_new) - e) / (1 - e * Math.cos(E_new));
  const sin_nu_new = Math.sqrt(1 - e * e) * Math.sin(E_new) / (1 - e * Math.cos(E_new));
  const nu_new = Math.atan2(sin_nu_new, cos_nu_new);
  
  return [a, e, omega, nu_new];
}

function applyBurn(elements, deltaV) {
  // Get current state
  const state = elementsToState(elements);
  
  // Apply delta-V
  const newVelocity = state.velocity.clone().add(deltaV);
  
  // Convert back to elements
  return stateToElements(state.position, newVelocity);
}

function computePhaseAngle(chaserElements, targetElements) {
  const chaserNu = chaserElements[3];
  const targetNu = targetElements[3];
  let phase = targetNu - chaserNu;
  
  // Normalize to [0, 2π]
  while (phase < 0) phase += 2 * Math.PI;
  while (phase > 2 * Math.PI) phase -= 2 * Math.PI;
  
  return phase;
}

function predictClosestApproach(chaserElements, targetElements, maxTime = null) {
  // Use scale-invariant prediction horizon based on chaser's period
  if (maxTime === null) {
    const [a] = chaserElements;
    const P = 2 * Math.PI * Math.sqrt(a * a * a / MU);
    maxTime = 1.5 * P;
  }
  
  let minRange = Infinity;
  let timeToCA = 0;
  let chaserStateAtCA = null;
  let targetStateAtCA = null;
  
  const dt = 0.01;
  const steps = Math.floor(maxTime / dt);
  
  let currentChaserElements = [...chaserElements];
  let currentTargetElements = [...targetElements];
  
  for (let i = 0; i < steps; i++) {
    const chaserState = elementsToState(currentChaserElements);
    const targetState = elementsToState(currentTargetElements);
    
    const range = chaserState.position.distanceTo(targetState.position);
    
    if (range < minRange) {
      minRange = range;
      timeToCA = i * dt;
      chaserStateAtCA = { ...chaserState };
      targetStateAtCA = { ...targetState };
    }
    
    // Propagate orbits
    currentChaserElements = propagateOrbit(currentChaserElements, dt);
    currentTargetElements = propagateOrbit(currentTargetElements, dt);
  }
  
  return {
    minRange,
    timeToCA,
    chaserStateAtCA,
    targetStateAtCA
  };
}

function createTrailGeometry(maxPoints = 500) {
  const positions = new Float32Array(maxPoints * 3);
  const geometry = new THREE.BufferGeometry();
  geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
  geometry.setDrawRange(0, 0); // Initially draw no points
  return geometry;
}

function updateTrail(trailGeometry, newPosition, maxPoints = 500) {
  const positions = trailGeometry.attributes.position.array;
  const currentCount = trailGeometry.drawRange.count;
  
  if (currentCount < maxPoints) {
    // Add new point
    const index = currentCount * 3;
    positions[index] = newPosition.x;
    positions[index + 1] = newPosition.y;
    positions[index + 2] = newPosition.z;
    trailGeometry.setDrawRange(0, currentCount + 1);
  } else {
    // Shift array and add new point
    for (let i = 0; i < (maxPoints - 1) * 3; i++) {
      positions[i] = positions[i + 3];
    }
    const lastIndex = (maxPoints - 1) * 3;
    positions[lastIndex] = newPosition.x;
    positions[lastIndex + 1] = newPosition.y;
    positions[lastIndex + 2] = newPosition.z;
  }
  
  trailGeometry.attributes.position.needsUpdate = true;
}

function getLVLHBasis(position, velocity) {
  const rBar = position.clone().normalize(); // Radial (away from Earth)
  const hBar = new THREE.Vector3().crossVectors(position, velocity).normalize(); // Normal (out of plane)
  const vBar = new THREE.Vector3().crossVectors(hBar, rBar); // Prograde (velocity direction)
  
  return { rBar, vBar, hBar };
}

// Add orbital collision detection and prevention
function isOrbitValid(elements) {
  const [a, e] = elements;
  
  // Check for hyperbolic orbits (energy >= 0, a < 0)
  if (a <= 0) {
    return false; // Hyperbolic or parabolic orbit
  }
  
  // Check periapsis against Earth intersection
  const periapsis = a * (1 - e);
  const EARTH_RADIUS = 1.0;
  const MIN_ALTITUDE = 0.01; // Minimum safe altitude above Earth
  
  if (periapsis <= (EARTH_RADIUS + MIN_ALTITUDE)) {
    return false; // Would crash into Earth
  }
  
  // Check apoapsis to avoid near-parabolic numerical weirdness
  const apoapsis = a * (1 + e);
  const MAX_APOAPSIS = 10.0; // Reasonable limit for simulation
  
  if (apoapsis > MAX_APOAPSIS) {
    return false; // Orbit too large, numerical issues likely
  }
  
  return true;
}

// Enhanced simulation step with visual effects
function step() {
  if (!params.playing) return;
  
  const dt = params.dt * params.timeScale;
  
  // Propagate orbits
  chaserElements = propagateOrbit(chaserElements, dt);
  targetElements = propagateOrbit(targetElements, dt);
  
  time += dt;
  
  // Update spacecraft positions
  const chaserState = elementsToState(chaserElements);
  const targetState = elementsToState(targetElements);
  
  chaserMesh.position.copy(chaserState.position);
  targetMesh.position.copy(targetState.position);
  
  // Update trails with enhanced effects
  updateTrail(chaserTrailGeometry, chaserState.position);
  updateTrail(targetTrailGeometry, targetState.position);
  
  // Update particle systems
  updateParticles();
  
  // Animate glow effects
  if (chaserGlow) {
    chaserGlow.material.opacity = 0.3 + 0.1 * Math.sin(time * 5);
  }
  if (targetGlow) {
    targetGlow.material.opacity = 0.3 + 0.1 * Math.sin(time * 3);
  }
  if (earthGlow) {
    earthGlow.material.opacity = 0.2 + 0.05 * Math.sin(time * 2);
  }
  
  // Rotate Earth slowly
  if (earthMesh) {
    earthMesh.rotation.y += 0.001 * params.timeScale;
  }
  
  // Animate starfield
  if (starField) {
    starField.rotation.y += 0.0001 * params.timeScale;
  }
  
  // Update directional light position (simulating sun)
  if (directionalLight) {
    const angle = time * 0.1;
    directionalLight.position.set(
      Math.cos(angle) * 10,
      3,
      Math.sin(angle) * 10
    );
  }
  
  // Update HUD
  updateHUD();
  
  updatePAOMarkers();
  updatePhaseGauge();
  updateGhostBurnArrows();
  
  updatePAOMarkers();
  updatePhaseGauge();
  
  updatePAOMarkers();
  updatePhaseGauge();
  
  updatePAOMarkers();
  updatePhaseGauge();
  
  updatePAOMarkers();
  updatePhaseGauge();
}

function updateHUD() {
  const chaserState = elementsToState(chaserElements);
  const targetState = elementsToState(targetElements);
  
  // Chaser parameters
  const [chaserA, chaserE] = chaserElements;
  const chaserPeriod = 2 * Math.PI * Math.sqrt(chaserA * chaserA * chaserA / MU);
  
  if (params.realWorldUnits) {
    document.getElementById('chaser-a').textContent = `${(chaserA * EARTH_RADIUS_KM).toFixed(0)} km`;
    document.getElementById('chaser-period').textContent = `${(chaserPeriod * TU_TO_SECONDS / 60).toFixed(1)} min`;
    document.getElementById('chaser-speed').textContent = `${(chaserState.speed * VU_TO_KM_S).toFixed(2)} km/s`;
  } else {
    document.getElementById('chaser-a').textContent = `${chaserA.toFixed(3)} R⊕`;
    document.getElementById('chaser-period').textContent = `${chaserPeriod.toFixed(2)} TU`;
    document.getElementById('chaser-speed').textContent = `${chaserState.speed.toFixed(3)} VU`;
  }
  document.getElementById('chaser-e').textContent = chaserE.toFixed(3);
  
  // Target parameters
  const [targetA, targetE] = targetElements;
  const targetPeriod = 2 * Math.PI * Math.sqrt(targetA * targetA * targetA / MU);
  
  if (params.realWorldUnits) {
    document.getElementById('target-a').textContent = `${(targetA * EARTH_RADIUS_KM).toFixed(0)} km`;
    document.getElementById('target-period').textContent = `${(targetPeriod * TU_TO_SECONDS / 60).toFixed(1)} min`;
  } else {
    document.getElementById('target-a').textContent = `${targetA.toFixed(3)} R⊕`;
    document.getElementById('target-period').textContent = `${targetPeriod.toFixed(2)} TU`;
  }
  document.getElementById('target-e').textContent = targetE.toFixed(3);
  
  // Phase angle (same in both unit systems)
  const phaseAngle = computePhaseAngle(chaserElements, targetElements);
  document.getElementById('phase-angle').textContent = `${(phaseAngle * 180 / Math.PI).toFixed(1)}°`;
  
  // Relative motion
  const range = chaserState.position.distanceTo(targetState.position);
  const relativeVel = new THREE.Vector3().subVectors(chaserState.velocity, targetState.velocity);
  const closingRate = -relativeVel.dot(new THREE.Vector3().subVectors(targetState.position, chaserState.position).normalize());
  
  if (params.realWorldUnits) {
    document.getElementById('relative-range').textContent = `${(range * EARTH_RADIUS_KM).toFixed(1)} km`;
    document.getElementById('closing-rate').textContent = `${(closingRate * VU_TO_KM_S).toFixed(3)} km/s`;
    document.getElementById('dv-budget').textContent = `${(dvBudget * VU_TO_KM_S).toFixed(2)} km/s`;
  } else {
    document.getElementById('relative-range').textContent = `${range.toFixed(3)} R⊕`;
    document.getElementById('closing-rate').textContent = `${closingRate.toFixed(3)} VU`;
    document.getElementById('dv-budget').textContent = `${dvBudget.toFixed(3)} VU`;
  }
  
  // Closest approach prediction
  const ca = predictClosestApproach(chaserElements, targetElements);
  if (params.realWorldUnits) {
    document.getElementById('time-to-ca').textContent =
      ca.timeToCA > 0 ? `${(ca.timeToCA * TU_TO_SECONDS / 60).toFixed(1)} min` : '-- min';
    document.getElementById('min-range').textContent = `${(ca.minRange * EARTH_RADIUS_KM).toFixed(1)} km`;
  } else {
    document.getElementById('time-to-ca').textContent =
      ca.timeToCA > 0 ? `${ca.timeToCA.toFixed(1)} TU` : '-- TU';
    document.getElementById('min-range').textContent = `${ca.minRange.toFixed(3)} R⊕`;
  }

  // Status
  const mode = params.playing ? 'Running' : 'Paused';
  if (params.realWorldUnits) {
    document.getElementById('orbit-status').textContent =
      `${mode} | Time: ${(time * TU_TO_SECONDS / 60).toFixed(1)} min | Range: ${(range * EARTH_RADIUS_KM).toFixed(1)} km`;
  } else {
    document.getElementById('orbit-status').textContent =
      `${mode} | Time: ${time.toFixed(1)} TU | Range: ${range.toFixed(3)} R⊕`;
  }
}

// Create starfield background
function createStarField() {
  const starsGeometry = new THREE.BufferGeometry();
  const starsMaterial = new THREE.PointsMaterial({
    color: 0xffffff,
    size: 0.003,
    transparent: true,
    opacity: 1.0,
    sizeAttenuation: false
  });

  const starsVertices = [];
  for (let i = 0; i < 2000; i++) {
    const x = (Math.random() - 0.5) * 200;
    const y = (Math.random() - 0.5) * 200;
    const z = (Math.random() - 0.5) * 200;
    starsVertices.push(x, y, z);
  }

  starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starsVertices, 3));
  return new THREE.Points(starsGeometry, starsMaterial);
}

// Create particle system for burn effects
function createParticleSystem() {
  const particleCount = 100;
  const geometry = new THREE.BufferGeometry();
  const positions = new Float32Array(particleCount * 3);
  const velocities = new Float32Array(particleCount * 3);
  const lifetimes = new Float32Array(particleCount);
  
  geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
  geometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3));
  geometry.setAttribute('lifetime', new THREE.BufferAttribute(lifetimes, 1));
  
  const material = new THREE.PointsMaterial({
    color: 0xffffff,
    size: 0.01,
    transparent: true,
    opacity: 0.8,
    blending: THREE.AdditiveBlending
  });
  
  return new THREE.Points(geometry, material);
}

// Create glow effect
function createGlow(color, size) {
  const glowGeometry = new THREE.SphereGeometry(size, 16, 16);
  const glowMaterial = new THREE.MeshBasicMaterial({
    color: color,
    transparent: true,
    opacity: 0.3,
    side: THREE.BackSide
  });
  return new THREE.Mesh(glowGeometry, glowMaterial);
}

// Create a small colored marker sphere
function createMarker(color = 0x00e5ff, size = 0.035) {
  const geo = new THREE.SphereGeometry(size, 16, 16);
  const mat = new THREE.MeshPhongMaterial({ color, emissive: 0x000000, shininess: 80, specular: 0x444444 });
  const mesh = new THREE.Mesh(geo, mat);
  mesh.castShadow = true;
  return mesh;
}

// Make a simple text sprite (canvas-based) so it always faces camera
function makeTextSprite(text, color = '#e5e7eb', fontSize = 48) {
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');
  const pad = 16;
  ctx.font = `bold ${fontSize}px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto`;
  const w = Math.ceil(ctx.measureText(text).width) + pad * 2;
  const h = fontSize + pad * 2;
  canvas.width = w; canvas.height = h;
  // background glow
  const grd = ctx.createLinearGradient(0,0,w,h);
  grd.addColorStop(0, 'rgba(30,41,59,0.8)'); grd.addColorStop(1, 'rgba(15,23,42,0.8)');
  ctx.fillStyle = grd; ctx.fillRect(0,0,w,h);
  ctx.strokeStyle = 'rgba(59,130,246,0.6)'; ctx.lineWidth = 2; ctx.strokeRect(1,1,w-2,h-2);
  // text
  ctx.font = `bold ${fontSize}px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto`;
  ctx.fillStyle = color; ctx.textBaseline = 'middle'; ctx.textAlign = 'center';
  ctx.fillText(text, w/2, h/2);

  const texture = new THREE.CanvasTexture(canvas);
  texture.anisotropy = 4; texture.needsUpdate = true;
  const material = new THREE.SpriteMaterial({ map: texture, transparent: true });
  const sprite = new THREE.Sprite(material);
  const scale = 0.45; // world units scale
  sprite.scale.set(canvas.width / 200 * scale, canvas.height / 200 * scale, 1);
  sprite.userData.canvasTexture = texture;
  sprite.renderOrder = 999;
  return sprite;
}

// Position vector for a given (a, e, omega) at specified true anomaly nu (z=0 plane)
function positionAtTrueAnomaly(a, e, omega, nu) {
  const r = a * (1 - e * e) / (1 + e * Math.cos(nu));
  const ang = omega + nu;
  return new THREE.Vector3(r * Math.cos(ang), r * Math.sin(ang), 0);
}

// Create burn arrow indicator
function createBurnArrow(color = 0x22c55e, size = 0.08) {
  const group = new THREE.Group();
  
  // Arrow shaft
  const shaftGeometry = new THREE.CylinderGeometry(0.008, 0.008, size, 8);
  const shaftMaterial = new THREE.MeshPhongMaterial({ color, emissive: color, emissiveIntensity: 0.3 });
  const shaft = new THREE.Mesh(shaftGeometry, shaftMaterial);
  shaft.rotation.z = Math.PI / 2; // Point right initially
  group.add(shaft);
  
  // Arrow head
  const headGeometry = new THREE.ConeGeometry(0.02, 0.04, 8);
  const head = new THREE.Mesh(headGeometry, shaftMaterial);
  head.position.x = size / 2 + 0.02;
  head.rotation.z = -Math.PI / 2; // Point right
  group.add(head);
  
  return group;
}

// Update ghost burn arrows visibility and positioning
function updateGhostBurnArrows() {
  // Return early if arrows haven't been created yet
  if (!periBurnArrow || !apoBurnArrow) return;
  
  const showArrows = (currentScenario === 'hohmann');
  
  periBurnArrow.visible = showArrows;
  apoBurnArrow.visible = showArrows;
  
  if (showArrows) {
    const [a, e, omega] = chaserElements;
    
    // Position arrows at periapsis and apoapsis
    const periPos = positionAtTrueAnomaly(a, e, omega, 0);
    const apoPos = positionAtTrueAnomaly(a, e, omega, Math.PI);
    
    periBurnArrow.position.copy(periPos);
    apoBurnArrow.position.copy(apoPos);
    
    // Orient arrows tangentially (prograde direction)
    const periTangent = Math.atan2(periPos.y, periPos.x) + Math.PI/2;
    const apoTangent = Math.atan2(apoPos.y, apoPos.x) + Math.PI/2;
    
    periBurnArrow.rotation.z = periTangent;
    apoBurnArrow.rotation.z = apoTangent;
    
    // Animate the arrows
    const pulse = 0.8 + 0.2 * Math.sin(time * 4);
    periBurnArrow.scale.setScalar(pulse);
    apoBurnArrow.scale.setScalar(pulse);
  }
}

// Update periapsis/apoapsis markers (for chaser)
function updatePAOMarkers() {
  if (!periMarker || !apoMarker || !periLabel || !apoLabel) return;
  
  const [a, e, omega] = chaserElements;
  const periPos = positionAtTrueAnomaly(a, e, omega, 0);
  const apoPos  = positionAtTrueAnomaly(a, e, omega, Math.PI);
  periMarker.position.copy(periPos);
  apoMarker.position.copy(apoPos);
  // Offset labels slightly outward
  periLabel.position.copy(periPos.clone().multiplyScalar(1.06));
  apoLabel.position.copy(apoPos.clone().multiplyScalar(1.06));
}

// Wrap angle to [-π, π]
function wrapPi(theta) {
  while (theta > Math.PI) theta -= 2*Math.PI;
  while (theta < -Math.PI) theta += 2*Math.PI;
  return theta;
}

// Desired target lead angle (radians) for Hohmann-style transfer between *nearly circular* orbits
// Positive = target ahead of chaser at departure
function desiredPhaseHohmann(a1, a2) {
  if (a1 <= 0 || a2 <= 0) return null;
  // transfer time = π * sqrt( ((a1+a2)/2)^3 / μ ), μ = 1
  const tTrans = Math.PI * Math.sqrt(Math.pow((a1 + a2)/2, 3));
  const n2 = Math.sqrt(1 / Math.pow(a2, 3)); // mean motion of target
  // Lower -> Higher: φ = π - n2*tTrans (target should lead by φ)
  // Higher -> Lower: same formula still yields correct sign; interpret positive as "target ahead"
  const phi = Math.PI - n2 * tTrans;
  return wrapPi(phi);
}

// Update gauge UI; returns readiness boolean
function updatePhaseGauge() {
  const [a1, e1] = chaserElements;
  const [a2, e2] = targetElements;

  // Current phase (target relative to chaser)
  const phase = computePhaseAngle(chaserElements, targetElements); // 0..2π
  const phaseSigned = wrapPi(phase); // -π..π

  // Show current
  document.getElementById('phase-current').textContent = `${(phase * 180/Math.PI).toFixed(1)}°`;

  // Only meaningful for near-circular orbits
  if (e1 > 0.05 || e2 > 0.05) {
    document.getElementById('phase-desired').textContent = '— (non-circular)';
    document.getElementById('phase-error').textContent = '—';
    document.getElementById('phase-status').textContent = 'N/A for eccentric orbits';
    document.getElementById('phase-status').className = 'phase-status na';
    document.getElementById('phase-fill').style.width = '0%';
    return false;
  }

  const phi = desiredPhaseHohmann(a1, a2);
  if (phi === null) {
    document.getElementById('phase-desired').textContent = '—';
    document.getElementById('phase-error').textContent = '—';
    document.getElementById('phase-status').textContent = 'N/A';
    document.getElementById('phase-status').className = 'phase-status na';
    document.getElementById('phase-fill').style.width = '0%';
    return false;
  }

  // desired lead (signed): positive = target ahead; negative = target behind
  const desiredDeg = phi * 180/Math.PI;
  document.getElementById('phase-desired').textContent =
    `${desiredDeg >= 0 ? '' : '−'}${Math.abs(desiredDeg).toFixed(1)}° ${desiredDeg >= 0 ? '(ahead)' : '(behind)'}`;

  // Error: difference between current phase and desired lead
  const err = wrapPi(phaseSigned - phi);
  const errDeg = err * 180/Math.PI;
  document.getElementById('phase-error').textContent = `${errDeg >= 0 ? '' : '−'}${Math.abs(errDeg).toFixed(1)}°`;

  // Bar shows "how close" (0° = full bar)
  const tol = 5; // degrees
  const closeness = Math.max(0, 1 - Math.min(Math.abs(errDeg)/90, 1)); // crude visualization
  document.getElementById('phase-fill').style.width = `${(closeness*100).toFixed(0)}%`;

  const ready = Math.abs(errDeg) <= tol;
  const statusEl = document.getElementById('phase-status');
  if (ready) {
    statusEl.textContent = `READY (|error| ≤ ${tol}°)`;
    statusEl.className = 'phase-status ready';
  } else {
    statusEl.textContent = `WAIT (need |error| ≤ ${tol}°)`;
    statusEl.className = 'phase-status wait';
  }
  return ready;
}

// Initialize Three.js scene
function initThree() {
  const container = document.getElementById('orbit-viz');
  
  // Clear loading indicator
  container.innerHTML = '';
  
  // Scene
  scene = new THREE.Scene();
  scene.fog = new THREE.Fog(0x000510, 10, 100);
  
  // Starfield background
  starField = createStarField();
  scene.add(starField);
  
  // Camera
  camera = new THREE.PerspectiveCamera(60, container.clientWidth / container.clientHeight, 0.1, 500);
  camera.position.set(0, 0, 8);
  camera.lookAt(0, 0, 0);
  
  // Renderer with enhanced settings
  renderer = new THREE.WebGLRenderer({
    antialias: true,
    alpha: true,
    powerPreference: 'high-performance'
  });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.setSize(container.clientWidth, container.clientHeight);
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.toneMappingExposure = 1.2;
  container.appendChild(renderer.domElement);
  
  // Enhanced lighting system - brighter for better visibility
  ambientLight = new THREE.AmbientLight(0x6080a0, 0.7);
  scene.add(ambientLight);
  
  directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
  directionalLight.position.set(5, 3, 5);
  directionalLight.castShadow = true;
  directionalLight.shadow.mapSize.width = 2048;
  directionalLight.shadow.mapSize.height = 2048;
  directionalLight.shadow.camera.near = 0.5;
  directionalLight.shadow.camera.far = 50;
  scene.add(directionalLight);
  
  pointLight = new THREE.PointLight(0x80b5ff, 1.2, 50);
  pointLight.position.set(0, 0, 0);
  scene.add(pointLight);
  
  // Enhanced Earth with realistic materials
  const earthGeometry = new THREE.SphereGeometry(EARTH_RADIUS, 64, 64);
  
  // Create enhanced Earth texture
  const canvas = document.createElement('canvas');
  canvas.width = 1024;
  canvas.height = 512;
  const ctx = canvas.getContext('2d');
  
  // Earth base with realistic colors
  const earthGradient = ctx.createRadialGradient(512, 256, 0, 512, 256, 400);
  earthGradient.addColorStop(0, '#2563eb');
  earthGradient.addColorStop(0.3, '#1d4ed8');
  earthGradient.addColorStop(0.7, '#1e40af');
  earthGradient.addColorStop(1, '#1e3a8a');
  ctx.fillStyle = earthGradient;
  ctx.fillRect(0, 0, 1024, 512);
  
  // Add continents
  ctx.fillStyle = '#065f46';
  ctx.beginPath();
  ctx.ellipse(200, 200, 80, 50, Math.PI/4, 0, 2*Math.PI);
  ctx.fill();
  ctx.beginPath();
  ctx.ellipse(600, 300, 120, 70, -Math.PI/6, 0, 2*Math.PI);
  ctx.fill();
  
  // Add coordinate grid
  ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
  ctx.lineWidth = 1;
  for (let i = 0; i <= 16; i++) {
    const x = (i * 1024) / 16;
    ctx.beginPath();
    ctx.moveTo(x, 0);
    ctx.lineTo(x, 512);
    ctx.stroke();
  }
  for (let i = 0; i <= 8; i++) {
    const y = (i * 512) / 8;
    ctx.beginPath();
    ctx.moveTo(0, y);
    ctx.lineTo(1024, y);
    ctx.stroke();
  }
  
  const earthTexture = new THREE.CanvasTexture(canvas);
  earthTexture.wrapS = THREE.RepeatWrapping;
  earthTexture.wrapT = THREE.RepeatWrapping;
  
  const earthMaterial = new THREE.MeshPhongMaterial({
    map: earthTexture,
    transparent: true,
    opacity: 1.0,
    shininess: 30,
    specular: 0x222222
  });
  
  earthMesh = new THREE.Mesh(earthGeometry, earthMaterial);
  earthMesh.castShadow = true;
  earthMesh.receiveShadow = true;
  scene.add(earthMesh);
  
  // Earth glow effect
  earthGlow = createGlow(0x60a5fa, 1.1);
  earthMesh.add(earthGlow);
  
  // Enhanced Chaser spacecraft - larger and more visible
  const chaserGeometry = new THREE.SphereGeometry(0.06, 16, 16);
  const chaserMaterial = new THREE.MeshPhongMaterial({
    color: 0xff4444,
    emissive: 0x330000,
    shininess: 100,
    specular: 0x555555
  });
  chaserMesh = new THREE.Mesh(chaserGeometry, chaserMaterial);
  chaserMesh.castShadow = true;
  scene.add(chaserMesh);
  
  // Chaser glow - larger
  chaserGlow = createGlow(0xff4444, 0.12);
  chaserMesh.add(chaserGlow);
  
  // Enhanced Target spacecraft - larger and more visible
  const targetGeometry = new THREE.SphereGeometry(0.06, 16, 16);
  const targetMaterial = new THREE.MeshPhongMaterial({
    color: 0x44ff44,
    emissive: 0x003300,
    shininess: 100,
    specular: 0x555555
  });
  targetMesh = new THREE.Mesh(targetGeometry, targetMaterial);
  targetMesh.castShadow = true;
  scene.add(targetMesh);
  
  // Target glow - larger
  targetGlow = createGlow(0x44ff44, 0.12);
  targetMesh.add(targetGlow);
  
  // --- Periapsis / Apoapsis markers & labels for the chaser ---
  periMarker = createMarker(0x3b82f6, 0.04);   // blue-ish
  apoMarker  = createMarker(0xa855f7, 0.04);   // purple-ish
  scene.add(periMarker, apoMarker);

  periLabel = makeTextSprite('Periapsis', '#bfdbfe', 48);
  apoLabel  = makeTextSprite('Apoapsis',  '#e9d5ff', 48);
  periLabel.className = 'sprite-label';
  apoLabel.className  = 'sprite-label';
  scene.add(periLabel, apoLabel);

  // Position them once at startup
  updatePAOMarkers();
  
  // Enhanced orbital trails with gradient
  chaserTrailGeometry = createTrailGeometry();
  const chaserTrailMaterial = new THREE.LineBasicMaterial({
    color: 0xff4444,
    transparent: true,
    opacity: 0.8,
    linewidth: 2
  });
  chaserTrail = new THREE.Line(chaserTrailGeometry, chaserTrailMaterial);
  scene.add(chaserTrail);
  
  targetTrailGeometry = createTrailGeometry();
  const targetTrailMaterial = new THREE.LineBasicMaterial({
    color: 0x44ff44,
    transparent: true,
    opacity: 0.8,
    linewidth: 2
  });
  targetTrail = new THREE.Line(targetTrailGeometry, targetTrailMaterial);
  scene.add(targetTrail);
  
  // Enhanced ghost trail with dashed line effect
  ghostTrailGeometry = createTrailGeometry();
  const ghostTrailMaterial = new THREE.LineDashedMaterial({
    color: 0xffffff,
    transparent: true,
    opacity: 0.5,
    dashSize: 0.05,
    gapSize: 0.03,
    linewidth: 1
  });
  ghostTrail = new THREE.Line(ghostTrailGeometry, ghostTrailMaterial);
  ghostTrail.computeLineDistances();
  scene.add(ghostTrail);
  
  // Particle system for burn effects
  particleSystem = createParticleSystem();
  scene.add(particleSystem);
  
  // Enhanced controls
  controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.dampingFactor = 0.05;
  controls.enablePan = true;
  controls.enableZoom = true;
  controls.minDistance = 1.5;
  controls.maxDistance = 15;
  controls.autoRotate = false;
  controls.autoRotateSpeed = 0.5;
  
  // Handle resize
  const resizeObserver = new ResizeObserver(() => {
    camera.aspect = container.clientWidth / container.clientHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(container.clientWidth, container.clientHeight);
  });
  resizeObserver.observe(container);
  
  // --- Ghost burn arrows for Hohmann guidance ---
  periBurnArrow = createBurnArrow(0x22c55e, 0.12); // Green prograde arrow
  apoBurnArrow = createBurnArrow(0x22c55e, 0.12);  // Green prograde arrow
  periBurnArrow.visible = false; // Initially hidden
  apoBurnArrow.visible = false;
  scene.add(periBurnArrow, apoBurnArrow);
  
  // Initial positions
  resetSimulation();
}

function resetSimulation() {
  // Reset to initial conditions - start at LEO altitude
  chaserElements = [1.3, 0.0, 0.0, 0.0];
  targetElements = [1.3, 0.0, 0.0, Math.PI/6];
  time = 0;
  dvBudget = 0;
  
  // Clear trails (only if they exist)
  if (chaserTrailGeometry) chaserTrailGeometry.setDrawRange(0, 0);
  if (targetTrailGeometry) targetTrailGeometry.setDrawRange(0, 0);
  if (ghostTrailGeometry) ghostTrailGeometry.setDrawRange(0, 0);
  
  // Update positions (only if meshes exist)
  if (chaserMesh && targetMesh) {
    const chaserState = elementsToState(chaserElements);
    const targetState = elementsToState(targetElements);
    
    chaserMesh.position.copy(chaserState.position);
    targetMesh.position.copy(targetState.position);
  }
  
  updateHUD();
  if (periMarker && apoMarker) updatePAOMarkers();
  updatePhaseGauge();
  currentScenario = null; // Reset scenario
  updateGhostBurnArrows();
}

// Scenario presets with detailed setups
function loadScenario(scenario) {
  switch (scenario) {
    case 'basic':
      // Basic Phasing: Chaser starts behind target in same circular orbit
      // Goal: Use retrograde burn to lower orbit and catch up
      chaserElements = [1.3, 0.0, 0.0, -Math.PI/3]; // 60° behind
      targetElements = [1.3, 0.0, 0.0, 0.0];
      currentScenario = 'basic';
      document.getElementById('orbit-status').textContent =
        'Basic Phasing: Try a -V burn to lower orbit and catch up to target';
      break;
      
    case 'hohmann':
      // Hohmann Transfer: Chaser in lower orbit, target in higher orbit
      // Goal: Execute two-burn transfer maneuver
      chaserElements = [1.2, 0.0, 0.0, 0.0]; // Lower orbit
      targetElements = [1.4, 0.0, 0.0, Math.PI]; // Higher orbit, opposite side
      currentScenario = 'hohmann';
      document.getElementById('orbit-status').textContent =
        'Hohmann Transfer: Use +V at periapsis, then +V again at apoapsis to circularize';
      break;
      
    case 'rendezvous':
      // R-bar Approach: Close proximity with slight eccentricity
      // Goal: Use small radial burns for final approach
      chaserElements = [1.295, 0.02, 0.0, Math.PI + Math.PI/12]; // Slightly elliptical, near target
      targetElements = [1.3, 0.0, 0.0, 0.0];
      currentScenario = 'rendezvous';
      document.getElementById('orbit-status').textContent =
        'R-bar Approach: Use small -R burns to approach target along radial corridor';
      break;
  }
  
  // Clear trails for new scenario (only if they exist)
  if (chaserTrailGeometry) chaserTrailGeometry.setDrawRange(0, 0);
  if (targetTrailGeometry) targetTrailGeometry.setDrawRange(0, 0);
  if (ghostTrailGeometry) ghostTrailGeometry.setDrawRange(0, 0);
  
  time = 0;
  dvBudget = 0;
  
  // Update positions (only if meshes exist)
  if (chaserMesh && targetMesh) {
    const chaserState = elementsToState(chaserElements);
    const targetState = elementsToState(targetElements);
    
    chaserMesh.position.copy(chaserState.position);
    targetMesh.position.copy(targetState.position);
  }
  
  updateHUD();
  if (periMarker && apoMarker) updatePAOMarkers();
  updatePhaseGauge();
  updateGhostBurnArrows();
}

// Create burn particle effect
function createBurnEffect(position, direction, burnType) {
  const particleCount = 50;
  const particles = new THREE.Group();
  
  for (let i = 0; i < particleCount; i++) {
    const particleGeometry = new THREE.SphereGeometry(0.002, 4, 4);
    let particleColor;
    switch (burnType) {
      case 'prograde': particleColor = 0x22c55e; break;
      case 'retrograde': particleColor = 0xef4444; break;
      case 'radial-out': particleColor = 0x3b82f6; break;
      case 'radial-in': particleColor = 0xf59e0b; break;
      default: particleColor = 0xffffff;
    }
    
    const particleMaterial = new THREE.MeshBasicMaterial({
      color: particleColor,
      transparent: true,
      opacity: 0.8
    });
    
    const particle = new THREE.Mesh(particleGeometry, particleMaterial);
    
    // Random position around burn point
    const spread = 0.1;
    particle.position.copy(position);
    particle.position.add(new THREE.Vector3(
      (Math.random() - 0.5) * spread,
      (Math.random() - 0.5) * spread,
      (Math.random() - 0.5) * spread
    ));
    
    // Velocity opposite to burn direction
    const velocity = direction.clone().multiplyScalar(-0.02 * (0.5 + Math.random()));
    velocity.add(new THREE.Vector3(
      (Math.random() - 0.5) * 0.01,
      (Math.random() - 0.5) * 0.01,
      (Math.random() - 0.5) * 0.01
    ));
    
    particle.userData = {
      velocity: velocity,
      life: 1.0,
      decay: 0.02 + Math.random() * 0.02
    };
    
    particles.add(particle);
  }
  
  scene.add(particles);
  burnParticles.push({
    group: particles,
    life: 1.0
  });
}

// Update particle systems
function updateParticles() {
  for (let i = burnParticles.length - 1; i >= 0; i--) {
    const burnEffect = burnParticles[i];
    burnEffect.life -= 0.02;
    
    if (burnEffect.life <= 0) {
      scene.remove(burnEffect.group);
      burnParticles.splice(i, 1);
      continue;
    }
    
    burnEffect.group.children.forEach(particle => {
      particle.userData.life -= particle.userData.decay;
      particle.position.add(particle.userData.velocity);
      particle.material.opacity = particle.userData.life;
      particle.scale.setScalar(particle.userData.life);
      
      if (particle.userData.life <= 0) {
        particle.visible = false;
      }
    });
  }
}

// Enhanced execute burn with visual effects and collision detection
function executeBurn(direction) {
  const chaserState = elementsToState(chaserElements);
  const basis = getLVLHBasis(chaserState.position, chaserState.velocity);
  
  let deltaV;
  switch (direction) {
    case 'prograde':
      deltaV = basis.vBar.clone().multiplyScalar(params.burnMagnitude);
      break;
    case 'retrograde':
      deltaV = basis.vBar.clone().multiplyScalar(-params.burnMagnitude);
      break;
    case 'radial-out':
      deltaV = basis.rBar.clone().multiplyScalar(params.burnMagnitude);
      break;
    case 'radial-in':
      deltaV = basis.rBar.clone().multiplyScalar(-params.burnMagnitude);
      break;
  }
  
  // Test the burn before applying it
  const testElements = applyBurn(chaserElements, deltaV);
  
  // Check if the resulting orbit would be valid (not crash into Earth)
  if (!isOrbitValid(testElements)) {
    // Warn user and prevent dangerous burn
    document.getElementById('orbit-status').textContent =
      `⚠️ Burn rejected: Would cause orbit to intersect with Earth! Try smaller magnitude.`;
    document.getElementById('orbit-status').style.color = '#ef4444';
    
    // Reset color after 3 seconds
    setTimeout(() => {
      document.getElementById('orbit-status').style.color = '#60a5fa';
    }, 3000);
    
    return; // Don't execute the burn
  }
  
  // Create visual burn effect
  createBurnEffect(chaserState.position, deltaV.clone().normalize(), direction);
  
  // Flash effect on chaser
  chaserMesh.material.emissive.setHex(0x444444);
  setTimeout(() => {
    chaserMesh.material.emissive.setHex(0x330000);
  }, 200);
  
  // Apply the burn (we know it's safe now)
  chaserElements = testElements;
  dvBudget += deltaV.length();
  
  // Update ghost trail with prediction
  updateGhostTrail();
  
  // Update status with burn confirmation
  const burnNames = {
    'prograde': '+V (Prograde)',
    'retrograde': '-V (Retrograde)',
    'radial-out': '+R (Radial Out)',
    'radial-in': '-R (Radial In)'
  };
  document.getElementById('orbit-status').textContent =
    `✓ ${burnNames[direction]} burn executed. ΔV: ${params.burnMagnitude.toFixed(3)} VU`;
  
  // Add UI feedback
  const button = document.getElementById(`burn-${direction}`);
  if (button) {
    button.style.transform = 'scale(0.95)';
    setTimeout(() => {
      button.style.transform = '';
    }, 150);
  }
}

function updateGhostTrail() {
  // Clear previous ghost trail
  ghostTrailGeometry.setDrawRange(0, 0);
  
  // Predict future trajectory
  let tempElements = [...chaserElements];
  const positions = ghostTrailGeometry.attributes.position.array;
  
  for (let i = 0; i < 200; i++) {
    const state = elementsToState(tempElements);
    positions[i * 3] = state.position.x;
    positions[i * 3 + 1] = state.position.y;
    positions[i * 3 + 2] = state.position.z;
    
    tempElements = propagateOrbit(tempElements, 0.05);
  }
  
  ghostTrailGeometry.setDrawRange(0, 200);
  ghostTrailGeometry.attributes.position.needsUpdate = true;
  
  // Recompute line distances so dashes render correctly after updates
  if (ghostTrail && ghostTrail.computeLineDistances) {
    ghostTrail.computeLineDistances();
  }
}

// Educational callouts for counter-intuitive moments
function showEducationalCallout(direction, chaserState, elements) {
  const [a, e, omega, nu] = elements;
  const r = chaserState.r;
  
  // Determine orbital position relative to periapsis/apoapsis
  const periapsisR = a * (1 - e);
  const apoapsisR = a * (1 + e);
  const nearPeriapsis = Math.abs(r - periapsisR) < 0.1 * a;
  const nearApoapsis = Math.abs(r - apoapsisR) < 0.1 * a;
  
  let message = '';
  
  if (direction === 'prograde') {
    if (nearPeriapsis) {
      message = '🚀 Apoapsis ↑, current speed ↑ (instant), average speed ↓ after you reach apoapsis';
    } else if (nearApoapsis) {
      message = '🌍 Periapsis ↑, current speed ↑ (instant), you\'re now in a higher, slower orbit';
    } else {
      message = '⬆️ Prograde burn raises opposite side of orbit - energy increases but effects are delayed';
    }
  } else if (direction === 'retrograde') {
    if (nearPeriapsis) {
      message = '⬇️ Apoapsis ↓, current speed ↓ (instant), but you\'ll be faster on average in this lower orbit';
    } else if (nearApoapsis) {
      message = '🎯 Periapsis ↓, dropping to a lower, faster orbit - perfect for catching up';
    } else {
      message = '🔻 Retrograde burn lowers opposite side - less energy means faster average speed';
    }
  } else if (direction === 'radial-out') {
    message = '📡 Radial-out burn: raising periapsis while lowering apoapsis - circularizing from below';
  } else if (direction === 'radial-in') {
    message = '🎯 Radial-in burn: lowering periapsis while raising apoapsis - circularizing from above';
  }
  
  if (message) {
    showToast(message);
  }
}

// Show toast message
let currentToast = null;
function showToast(message) {
  // Remove existing toast
  if (currentToast) {
    currentToast.remove();
  }
  
  // Create new toast
  currentToast = document.createElement('div');
  currentToast.className = 'toast';
  currentToast.innerHTML = `<span class="toast-icon">💡</span>${message}`;
  document.body.appendChild(currentToast);
  
  // Show animation
  setTimeout(() => {
    currentToast.classList.add('show');
  }, 50);
  
  // Auto-hide after 4 seconds
  setTimeout(() => {
    if (currentToast) {
      currentToast.classList.remove('show');
      setTimeout(() => {
        if (currentToast) {
          currentToast.remove();
          currentToast = null;
        }
      }, 400);
    }
  }, 4000);
}

// Animation loop
function animate() {
  requestAnimationFrame(animate);
  
  step();
  controls.update();
  renderer.render(scene, camera);
}

// Event listeners
document.getElementById('orbit-play-pause').addEventListener('click', () => {
  params.playing = !params.playing;
  document.getElementById('orbit-play-pause').textContent = params.playing ? 'Pause' : 'Play';
});

document.getElementById('orbit-reset').addEventListener('click', resetSimulation);

document.getElementById('burn-prograde').addEventListener('click', () => executeBurn('prograde'));
document.getElementById('burn-retrograde').addEventListener('click', () => executeBurn('retrograde'));
document.getElementById('burn-radial-out').addEventListener('click', () => executeBurn('radial-out'));
document.getElementById('burn-radial-in').addEventListener('click', () => executeBurn('radial-in'));

document.getElementById('burn-magnitude').addEventListener('input', (e) => {
  params.burnMagnitude = parseFloat(e.target.value);
  document.getElementById('burn-magnitude-value').textContent = params.burnMagnitude.toFixed(2);
});

document.getElementById('time-scale').addEventListener('input', (e) => {
  params.timeScale = parseFloat(e.target.value);
  document.getElementById('time-scale-value').textContent = `${params.timeScale.toFixed(1)}×`;
});

document.getElementById('scenario-basic').addEventListener('click', () => loadScenario('basic'));
document.getElementById('scenario-hohmann').addEventListener('click', () => loadScenario('hohmann'));
document.getElementById('scenario-rendezvous').addEventListener('click', () => loadScenario('rendezvous'));

// Real-world units toggle removed - no UI element exists for this feature
// If needed in future, add a checkbox element with id="real-world-units"

// Keyboard shortcuts
document.addEventListener('keydown', (e) => {
  // Don't interfere if user is typing in an input
  if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
  
  switch (e.key.toLowerCase()) {
    case ' ':
      e.preventDefault();
      document.getElementById('orbit-play-pause').click();
      break;
    case '[':
      e.preventDefault();
      const timeScale = Math.max(0.1, params.timeScale - 0.1);
      document.getElementById('time-scale').value = timeScale;
      document.getElementById('time-scale').dispatchEvent(new Event('input'));
      break;
    case ']':
      e.preventDefault();
      const timeScaleUp = Math.min(10, params.timeScale + 0.1);
      document.getElementById('time-scale').value = timeScaleUp;
      document.getElementById('time-scale').dispatchEvent(new Event('input'));
      break;
    case 'z':
      e.preventDefault();
      executeBurn('prograde');
      break;
    case 'x':
      e.preventDefault();
      executeBurn('retrograde');
      break;
    case 'c':
      e.preventDefault();
      executeBurn('radial-out');
      break;
    case 'v':
      e.preventDefault();
      executeBurn('radial-in');
      break;
    case 'r':
      e.preventDefault();
      document.getElementById('orbit-reset').click();
      break;
    case '?':
    case 'h':
      e.preventDefault();
      toggleKeyboardHelp();
      break;
  }
});

// Show/hide keyboard shortcuts help
let keyboardHelpVisible = false;
function toggleKeyboardHelp() {
  const helpDiv = document.getElementById('keyboard-help');
  if (helpDiv) {
    keyboardHelpVisible = !keyboardHelpVisible;
    helpDiv.classList.toggle('show', keyboardHelpVisible);
  }
}

// Add keyboard shortcuts helper to page
document.body.insertAdjacentHTML('beforeend', `
<div id="keyboard-help" class="keyboard-shortcuts">
  <h5>Keyboard Shortcuts</h5>
  <div><kbd>Space</kbd>Play/Pause</div>
  <div><kbd>[</kbd><kbd>]</kbd>Time Scale</div>
  <div><kbd>Z</kbd>+V (Prograde)</div>
  <div><kbd>X</kbd>-V (Retrograde)</div>
  <div><kbd>C</kbd>+R (Radial Out)</div>
  <div><kbd>V</kbd>-R (Radial In)</div>
  <div><kbd>R</kbd>Reset</div>
  <div><kbd>?</kbd>Toggle Help</div>
</div>
`);

// Initialize
initThree();
animate();
</script> <script type="module" src="/assets/js/orbit-simulator.js"></script>]]></content><author><name></name></author><category term="blog"/><category term="orbital-mechanics"/><category term="physics"/><category term="simulation"/><category term="aerospace"/><category term="interactive"/><category term="three-js"/><summary type="html"><![CDATA[Explore the counter-intuitive nature of orbital mechanics through interactive 3D simulations. Learn why speeding up can make you drop and master spacecraft rendezvous techniques.]]></summary></entry><entry><title type="html">Fast Collision in Games: Spatial Hashing vs. Naïve</title><link href="https://saeed1262.github.io/blog/2025/spatial-hashing-collision/" rel="alternate" type="text/html" title="Fast Collision in Games: Spatial Hashing vs. Naïve"/><published>2025-08-24T00:00:00+00:00</published><updated>2025-08-24T00:00:00+00:00</updated><id>https://saeed1262.github.io/blog/2025/spatial-hashing-collision</id><content type="html" xml:base="https://saeed1262.github.io/blog/2025/spatial-hashing-collision/"><![CDATA[<p>When hundreds of objects move every frame, naïvely checking all pairs is O(n²) and quickly tanks performance. Games use a broad‑phase to prune most pairs before precise (narrow‑phase) checks. A simple and effective broad‑phase is a uniform grid, also called spatial hashing.</p> <p>Below you can toggle between Naïve and Spatial Hashing, adjust object counts, and visualize grid cells and candidate pairs. Watch the collision‑checks counter as n scales.</p> <div id="hash-container"> <div id="hash-controls"> <div class="control-group"> <label>Algorithm</label> <div class="control-row"> <select id="algo"> <option value="hash">Spatial Hash</option> <option value="naive">Naïve O(n²)</option> </select> </div> </div> <div class="control-group"> <label>Objects: <span class="value" id="countLabel">300</span></label> <input id="count" type="range" min="50" max="1200" step="10" value="300"/> </div> <div class="control-group"> <label>Cell Size: <span class="value" id="cellLabel">32</span> px</label> <input id="cell" type="range" min="12" max="80" step="4" value="32"/> </div> <div class="control-group"> <label>Speed: <span class="value" id="speedLabel">1.0x</span></label> <input id="speed" type="range" min="0.25" max="2.0" step="0.25" value="1.0"/> </div> <div class="control-group"> <label>Visuals</label> <div class="control-row"> <label class="checkbox"><input id="showGrid" type="checkbox" checked=""/> Grid</label> <label class="checkbox"><input id="showCandidates" type="checkbox"/> Candidates</label> <label class="checkbox"><input id="pause" type="checkbox"/> Pause</label> </div> </div> </div> <div id="hash-viz-container"> <canvas id="hash-viz" width="1280" height="720" aria-label="Spatial hashing collision demo"></canvas> <div class="loading" id="loading">Preparing simulation…</div> <div class="no-canvas" id="noCanvas" hidden="">Your browser does not support Canvas.</div> </div> <div id="hash-hud"> <div class="hud-panel"> <h4>Performance</h4> <div class="hud-value"><span class="label">Algorithm</span><span class="value" id="hudAlgo">Spatial Hash</span></div> <div class="hud-value"><span class="label">Objects</span><span class="value" id="hudCount">300</span></div> <div class="hud-value"><span class="label">Cell Size</span><span class="value" id="hudCell">32 px</span></div> <div class="hud-value"><span class="label">Broad‑phase Pairs</span><span class="value" id="hudPairs">0</span></div> <div class="hud-value"><span class="label">Collision Checks</span><span class="value" id="hudChecks">0</span></div> <div class="hud-value"><span class="label">FPS</span><span class="value" id="hudFps">0</span></div> </div> <div class="hud-panel"> <h4>Notes</h4> <ul class="notes"> <li>Uniform grid partitions space; objects visit only nearby cells.</li> <li>Broad‑phase prunes pairs; narrow‑phase confirms actual overlaps.</li> <li>Best grid size ≈ 1–2× object diameter for circles/AABBs.</li> </ul> </div> </div> </div> <link rel="stylesheet" href="/assets/css/spatial-hash.css"/> <script defer="" src="/assets/js/spatial-hash.js"></script> <h2 id="why-i-built-this">Why I Built This</h2> <p>In real‑time games, hundreds or thousands of moving objects need collision checks every frame. The straightforward way—compare everything with everything—blows up quadratically and crushes frame time. I wanted an interactive, visual way to show how a simple broad‑phase like a uniform grid (aka spatial hashing) turns this into near‑linear work for typical scenes. The demo mirrors how production engines prune pairs before doing precise tests.</p> <h2 id="what-you-can-do">What You Can Do</h2> <ul> <li>Toggle <code class="language-plaintext highlighter-rouge">Algorithm</code> between <code class="language-plaintext highlighter-rouge">Naïve O(n²)</code> and <code class="language-plaintext highlighter-rouge">Spatial Hash</code> and watch <code class="language-plaintext highlighter-rouge">Broad‑phase Pairs</code> and <code class="language-plaintext highlighter-rouge">Collision Checks</code> in the HUD.</li> <li>Drag <code class="language-plaintext highlighter-rouge">Objects</code> higher. Naïve explodes in work; hashing stays smooth until you really crowd the scene.</li> <li>Vary <code class="language-plaintext highlighter-rouge">Cell Size</code>. Try around the object diameter for best pruning; too small or too large hurts.</li> <li>Enable <code class="language-plaintext highlighter-rouge">Grid</code> to see the uniform cells; enable <code class="language-plaintext highlighter-rouge">Candidates</code> to visualize broad‑phase pair hypotheses.</li> <li>Nudge <code class="language-plaintext highlighter-rouge">Speed</code> up to stress the system; combine with small cells to see dedup rules still hold.</li> </ul> <h2 id="broadphase-vs-narrowphase">Broad‑Phase vs Narrow‑Phase</h2> <ul> <li>Broad‑phase: fast, conservative culling to propose potential overlaps (same or adjacent cells). Output is a set of candidate pairs.</li> <li>Narrow‑phase: precise, more expensive test (e.g., circle vs circle, AABB vs AABB, or SAT for polygons) to confirm real collisions.</li> <li>The broad‑phase should be cheap enough to run every frame and accurate enough that most true overlaps are proposed without flooding the narrow‑phase with false positives.</li> </ul> <h2 id="complexity-and-scaling">Complexity and Scaling</h2> <ul> <li>Naïve: O(n²) candidate pairs. Doubling n → ~4× more comparisons.</li> <li>Spatial hash: O(n + k), where k is the number of candidate pairs from local neighbors. With a good cell size and reasonably uniform distribution, k ≈ c·n with small c.</li> <li>Example intuition: At 1,000 objects, naïve emits ~500k pairs. With a grid tuned to object size, each object often sees only tens of neighbors, yielding tens of thousands of pairs instead of hundreds of thousands.</li> <li>Pathological worst case exists (everyone in one cell) but is rare with sane parameters and motion.</li> </ul> <h2 id="visual-intuition">Visual Intuition</h2> <p>Only neighbors in your 3×3 cell neighborhood can collide in 2D (27 cells in 3D). The grid shrinks the search from “the whole world” to “just around me.”</p> <div style="text-align:center; margin: 1rem 0;"> <svg viewBox="0 0 220 220" width="360" height="360" style="max-width: 100%; background: #0f1117; border: 1px solid #222; border-radius: 10px;"> <defs> <pattern id="grid" width="20" height="20" patternUnits="userSpaceOnUse"> <path d="M 20 0 L 0 0 0 20" fill="none" stroke="#273447" stroke-width="1"/> </pattern> </defs> <rect x="10" y="10" width="200" height="200" fill="url(#grid)" stroke="#334155"/> <rect x="90" y="90" width="20" height="20" fill="rgba(100,255,218,0.12)" stroke="#64ffda"/> <g fill="rgba(100,255,218,0.05)" stroke="#3b82f6"> <rect x="70" y="70" width="20" height="20"/> <rect x="90" y="70" width="20" height="20"/> <rect x="110" y="70" width="20" height="20"/> <rect x="70" y="90" width="20" height="20"/> <rect x="110" y="90" width="20" height="20"/> <rect x="70" y="110" width="20" height="20"/> <rect x="90" y="110" width="20" height="20"/> <rect x="110" y="110" width="20" height="20"/> </g> <circle cx="100" cy="100" r="5" fill="#e879f9"/> <circle cx="132" cy="98" r="5" fill="#60a5fa"/> <circle cx="88" cy="120" r="5" fill="#34d399"/> <circle cx="58" cy="76" r="5" fill="#f472b6"/> <text x="110" y="30" fill="#94a3b8" font-size="12" text-anchor="middle">Only test within these cells</text> </svg> <div style="color:#94a3b8; font-size: 0.95rem; margin-top: 0.25rem;">Broad‑phase limits candidates to the 3×3 neighborhood.</div> </div> <h3 id="why-spatial-hashing-works">Why Spatial Hashing Works</h3> <ul> <li>Broad‑phase reduces pair candidates from O(n²) toward O(n) on average by restricting checks to neighbors in the same or adjacent cells.</li> <li>The grid key can be computed with integer division; a small hash map keeps cell→object lists per frame.</li> <li>For robustness, only emit pairs with i &lt; j to avoid duplicates; optionally use a small seen‑set if objects span multiple cells.</li> </ul> <p>This pattern scales well and is a staple in physics, AI sensing, particle systems, and effects. In production, you may switch to a quadtree, BVH, or clustered grids for heterogeneous sizes, but a uniform hash is hard to beat for simplicity and speed.</p> <h2 id="how-the-demo-works">How the Demo Works</h2> <ul> <li>Integrate motion: update positions with simple Euler and wall bounces.</li> <li>Build grid: for each circle, insert its covered cells into a <code class="language-plaintext highlighter-rouge">Map</code> keyed by integer cell coords.</li> <li>Emit candidates: iterate each occupied cell and its neighbors; enforce <code class="language-plaintext highlighter-rouge">i &lt; j</code> to avoid duplicates.</li> <li>Narrow‑phase: circle‑circle distance test for each candidate pair; mark colliding objects.</li> <li>Visualize: draw the grid (optional), candidate lines (optional), and circles with collision tint.</li> <li>HUD: report algorithm, object count, cell size, candidate pair count, precise check count, and FPS.</li> </ul> <p>The implementation is in <code class="language-plaintext highlighter-rouge">assets/js/spatial-hash.js</code>. The grid uses string keys like <code class="language-plaintext highlighter-rouge">"gx,gy"</code> and a small set to deduplicate pairs across neighboring cells. Everything is rebuilt per frame to reflect motion—simple and cache‑friendly in JS.</p> <h2 id="experiments-to-try">Experiments To Try</h2> <ul> <li>Double <code class="language-plaintext highlighter-rouge">Objects</code> while in <code class="language-plaintext highlighter-rouge">Naïve</code> and watch checks explode; switch to <code class="language-plaintext highlighter-rouge">Spatial Hash</code> to see the difference.</li> <li>Sweep <code class="language-plaintext highlighter-rouge">Cell Size</code> from too small → optimal → too large and note how <code class="language-plaintext highlighter-rouge">Broad‑phase Pairs</code> changes.</li> <li>Turn on <code class="language-plaintext highlighter-rouge">Candidates</code>, then toggle algorithms to see how local the lines become with hashing.</li> <li>Max out <code class="language-plaintext highlighter-rouge">Speed</code> and observe missed cases when using too few substeps—then lower speed or slightly inflate AABBs in the broad‑phase.</li> </ul> <h3 id="naïve-vs-hashing-mental-model">Naïve vs. Hashing: Mental Model</h3> <ul> <li>Naïve O(n²): Every frame, compare each object with every other. Work ~ n(n-1)/2; doubling n ~4× comparisons.</li> <li>Spatial Hash O(n + k): Insert all objects into a grid (O(n)), then only test neighbors inside the same/adjacent cells. If objects are fairly evenly distributed and cell size matches object size, each object sees a constant number of neighbors on average, so k ~ c·n.</li> <li>Worst case still exists: If everything piles into one cell, you’re back to O(n²). Good parameters and mild randomness avoid this.</li> </ul> <h3 id="choosing-cell-size">Choosing Cell Size</h3> <ul> <li>Rule of thumb: cell size ≈ object diameter (for circles/spheres) or the larger dimension of the AABB.</li> <li>Too small: each object touches many cells; higher bookkeeping and deduplication work.</li> <li>Too large: too many unrelated objects share a cell; more false candidate pairs.</li> <li>2D vs 3D: neighbors are 9 cells in 2D (3×3 around you) and 27 in 3D (3×3×3).</li> </ul> <h3 id="core-pseudocode-2d-circlesaabbs">Core Pseudocode (2D circles/AABBs)</h3> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Integer cell coordinate from world position
cell(p, size) = (floor(p.x / size), floor(p.y / size))

// Build the grid (hash map from (cx,cy) -&gt; list of indices)
grid.clear()
for i in 0..n-1:
  aabb = bounds(i)               // center + radius or min/max
  (cx0, cy0) = cell(aabb.min, S)
  (cx1, cy1) = cell(aabb.max, S)
  for cy in cy0..cy1:
    for cx in cx0..cx1:
      grid[(cx,cy)].push(i)

// Emit pairs from each occupied cell
pairs.clear()
for each (cx,cy) in grid.keys():
  for ny in cy-1..cy+1:
    for nx in cx-1..cx+1:
      let A = grid[(cx,cy)]
      let B = grid[(nx,ny)]
      // order rule avoids duplicates: only if (nx,ny) &gt;= (cx,cy)
      if (ny &lt; cy) or (ny == cy and nx &lt; cx): continue
      for each i in A:
        for each j in B:
          if (A == B and j &lt;= i): continue  // keep i&lt;j
          if narrowPhaseOverlap(i, j):
            pairs.add((i,j))
</code></pre></div></div> <p>Notes:</p> <ul> <li>The “order rule” prevents the same pair from being emitted from multiple neighboring cells.</li> <li>If objects are small relative to S, each object spans 1–4 cells in 2D (1–8 in 3D).</li> <li>Use contiguous arrays and reuse buffers to avoid per‑frame allocation.</li> </ul> <h3 id="hashing-implementation-details">Hashing Implementation Details</h3> <ul> <li>Key packing: convert <code class="language-plaintext highlighter-rouge">(cx, cy)</code> to a single integer key, e.g., <code class="language-plaintext highlighter-rouge">(int64(cx) &lt;&lt; 32) ^ (cy &amp; 0xffffffff)</code> or use a proper hash of the pair.</li> <li>Data layout: prefer <code class="language-plaintext highlighter-rouge">struct of arrays</code> (SoA) for positions/radii to be cache‑friendly in the tight loops.</li> <li>Frame clearing: instead of freeing maps, keep capacity and reset lengths; pool cell lists for reuse.</li> <li>Stable ordering: keep object indices stable to improve cache locality across frames.</li> </ul> <h3 id="handling-high-speeds-ccd">Handling High Speeds (CCD)</h3> <ul> <li>Broad‑phase with static AABBs can miss fast objects that tunnel through each other between frames.</li> <li>Common fixes: <ul> <li>Inflate AABBs by velocity over the timestep (swept AABB) before broad‑phase.</li> <li>Integrate in substeps when speeds are high relative to object size.</li> <li>Use time‑of‑impact narrow‑phase for critical objects only.</li> </ul> </li> </ul> <h3 id="variable-sizes-and-density">Variable Sizes and Density</h3> <ul> <li>Mixed scales: large and tiny objects together degrade uniform grids. Options: <ul> <li>Multi‑level grids (different S per tier; insert by size class).</li> <li>Insert big objects into all cells overlapped; cap per‑cell occupancy.</li> <li>Hybrid broad‑phase: grid for smalls, sweep‑and‑prune or BVH for larges.</li> </ul> </li> <li>Crowding: if a cell exceeds a threshold, adapt (split cell, switch to secondary structure) or increase S slightly.</li> </ul> <h3 id="performance-tips">Performance Tips</h3> <ul> <li>Avoid hash map churn: precompute world‑to‑cell bounds and allocate a fixed window when the world is limited. For infinite worlds, use a custom open‑addressing hash.</li> <li>SIMD: distance checks for circles/AABBs vectorize well; batch candidate pairs.</li> <li>Parallelism: split space into strips or blocks; merge pairs afterward. Be careful with duplicates across boundaries.</li> <li>Metrics: track “broad‑phase pairs per object” and “narrow‑phase hits” to tune S.</li> </ul> <h3 id="how-it-compares">How It Compares</h3> <ul> <li>Sweep and Prune (SAP): great along one axis when motion is coherent; widely used in physics engines.</li> <li>Quad/Octrees: adapt to non‑uniform densities but cost more to update with many movers.</li> <li>BVH: excellent for static or semi‑static geometry; dynamic rebuilds are pricier.</li> <li>Uniform Grid/Hash: minimal code, fast updates, shines with many similar‑sized dynamic objects.</li> </ul> <h3 id="tiny-javascript-example">Tiny JavaScript Example</h3> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 64-bit style key using two 32-bit signed ints</span>
<span class="kd">const</span> <span class="nx">key</span> <span class="o">=</span> <span class="p">(</span><span class="nx">cx</span><span class="p">,</span> <span class="nx">cy</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="nc">BigInt</span><span class="p">(</span><span class="nx">cx</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="nx">n</span><span class="p">)</span> <span class="o">^</span> <span class="p">(</span><span class="nc">BigInt</span><span class="p">(</span><span class="nx">cy</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xffffffff</span><span class="nx">n</span><span class="p">);</span>

<span class="kd">function</span> <span class="nf">buildGrid</span><span class="p">(</span><span class="nx">objs</span><span class="p">,</span> <span class="nx">S</span><span class="p">,</span> <span class="nx">grid</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">grid</span><span class="p">.</span><span class="nf">clear</span><span class="p">();</span>
  <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">objs</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">o</span> <span class="o">=</span> <span class="nx">objs</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
    <span class="kd">const</span> <span class="nx">minx</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">((</span><span class="nx">o</span><span class="p">.</span><span class="nx">x</span> <span class="o">-</span> <span class="nx">o</span><span class="p">.</span><span class="nx">r</span><span class="p">)</span> <span class="o">/</span> <span class="nx">S</span><span class="p">);</span>
    <span class="kd">const</span> <span class="nx">maxx</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">((</span><span class="nx">o</span><span class="p">.</span><span class="nx">x</span> <span class="o">+</span> <span class="nx">o</span><span class="p">.</span><span class="nx">r</span><span class="p">)</span> <span class="o">/</span> <span class="nx">S</span><span class="p">);</span>
    <span class="kd">const</span> <span class="nx">miny</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">((</span><span class="nx">o</span><span class="p">.</span><span class="nx">y</span> <span class="o">-</span> <span class="nx">o</span><span class="p">.</span><span class="nx">r</span><span class="p">)</span> <span class="o">/</span> <span class="nx">S</span><span class="p">);</span>
    <span class="kd">const</span> <span class="nx">maxy</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">((</span><span class="nx">o</span><span class="p">.</span><span class="nx">y</span> <span class="o">+</span> <span class="nx">o</span><span class="p">.</span><span class="nx">r</span><span class="p">)</span> <span class="o">/</span> <span class="nx">S</span><span class="p">);</span>
    <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">cy</span> <span class="o">=</span> <span class="nx">miny</span><span class="p">;</span> <span class="nx">cy</span> <span class="o">&lt;=</span> <span class="nx">maxy</span><span class="p">;</span> <span class="nx">cy</span><span class="o">++</span><span class="p">)</span>
      <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">cx</span> <span class="o">=</span> <span class="nx">minx</span><span class="p">;</span> <span class="nx">cx</span> <span class="o">&lt;=</span> <span class="nx">maxx</span><span class="p">;</span> <span class="nx">cx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">k</span> <span class="o">=</span> <span class="nf">key</span><span class="p">(</span><span class="nx">cx</span><span class="p">,</span> <span class="nx">cy</span><span class="p">);</span>
        <span class="kd">let</span> <span class="nx">arr</span> <span class="o">=</span> <span class="nx">grid</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="nx">k</span><span class="p">);</span>
        <span class="k">if </span><span class="p">(</span><span class="o">!</span><span class="nx">arr</span><span class="p">)</span> <span class="nx">grid</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">k</span><span class="p">,</span> <span class="p">(</span><span class="nx">arr</span> <span class="o">=</span> <span class="p">[]));</span>
        <span class="nx">arr</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span>
      <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nf">emitPairs</span><span class="p">(</span><span class="nx">grid</span><span class="p">,</span> <span class="nx">objs</span><span class="p">,</span> <span class="nx">S</span><span class="p">,</span> <span class="nx">outPairs</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">outPairs</span><span class="p">.</span><span class="nx">length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">for </span><span class="p">(</span><span class="kd">const</span> <span class="p">[</span><span class="nx">k</span><span class="p">,</span> <span class="nx">A</span><span class="p">]</span> <span class="k">of</span> <span class="nx">grid</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">cy</span> <span class="o">=</span> <span class="nc">Number</span><span class="p">((</span><span class="nx">k</span> <span class="o">&amp;</span> <span class="mh">0xffffffff</span><span class="nx">n</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="nx">n</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="nx">n</span><span class="p">);</span> <span class="c1">// sign-extend</span>
    <span class="kd">const</span> <span class="nx">cx</span> <span class="o">=</span> <span class="nc">Number</span><span class="p">(</span><span class="nx">k</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="nx">n</span><span class="p">);</span>
    <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">ny</span> <span class="o">=</span> <span class="nx">cy</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">ny</span> <span class="o">&lt;=</span> <span class="nx">cy</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">ny</span><span class="o">++</span><span class="p">)</span>
      <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">nx</span> <span class="o">=</span> <span class="nx">cx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">nx</span> <span class="o">&lt;=</span> <span class="nx">cx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">nx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// order rule to avoid duplicates</span>
        <span class="k">if </span><span class="p">(</span><span class="nx">ny</span> <span class="o">&lt;</span> <span class="nx">cy</span> <span class="o">||</span> <span class="p">(</span><span class="nx">ny</span> <span class="o">===</span> <span class="nx">cy</span> <span class="o">&amp;&amp;</span> <span class="nx">nx</span> <span class="o">&lt;</span> <span class="nx">cx</span><span class="p">))</span> <span class="k">continue</span><span class="p">;</span>
        <span class="kd">const</span> <span class="nx">B</span> <span class="o">=</span> <span class="nx">grid</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="nf">key</span><span class="p">(</span><span class="nx">nx</span><span class="p">,</span> <span class="nx">ny</span><span class="p">));</span>
        <span class="k">if </span><span class="p">(</span><span class="o">!</span><span class="nx">B</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
        <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">ai</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">ai</span> <span class="o">&lt;</span> <span class="nx">A</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">ai</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">const</span> <span class="nx">i</span> <span class="o">=</span> <span class="nx">A</span><span class="p">[</span><span class="nx">ai</span><span class="p">];</span>
          <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">bj</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">bj</span> <span class="o">&lt;</span> <span class="nx">B</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">bj</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="kd">const</span> <span class="nx">j</span> <span class="o">=</span> <span class="nx">B</span><span class="p">[</span><span class="nx">bj</span><span class="p">];</span>
            <span class="k">if </span><span class="p">(</span><span class="nx">A</span> <span class="o">===</span> <span class="nx">B</span> <span class="o">&amp;&amp;</span> <span class="nx">j</span> <span class="o">&lt;=</span> <span class="nx">i</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
            <span class="c1">// circle narrow-phase</span>
            <span class="kd">const</span> <span class="nx">dx</span> <span class="o">=</span> <span class="nx">objs</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">x</span> <span class="o">-</span> <span class="nx">objs</span><span class="p">[</span><span class="nx">j</span><span class="p">].</span><span class="nx">x</span><span class="p">;</span>
            <span class="kd">const</span> <span class="nx">dy</span> <span class="o">=</span> <span class="nx">objs</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">y</span> <span class="o">-</span> <span class="nx">objs</span><span class="p">[</span><span class="nx">j</span><span class="p">].</span><span class="nx">y</span><span class="p">;</span>
            <span class="kd">const</span> <span class="nx">rr</span> <span class="o">=</span> <span class="nx">objs</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">r</span> <span class="o">+</span> <span class="nx">objs</span><span class="p">[</span><span class="nx">j</span><span class="p">].</span><span class="nx">r</span><span class="p">;</span>
            <span class="k">if </span><span class="p">(</span><span class="nx">dx</span><span class="o">*</span><span class="nx">dx</span> <span class="o">+</span> <span class="nx">dy</span><span class="o">*</span><span class="nx">dy</span> <span class="o">&lt;=</span> <span class="nx">rr</span><span class="o">*</span><span class="nx">rr</span><span class="p">)</span> <span class="nx">outPairs</span><span class="p">.</span><span class="nf">push</span><span class="p">([</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span><span class="p">]);</span>
          <span class="p">}</span>
        <span class="p">}</span>
      <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="when-not-to-use-it">When Not To Use It</h3> <ul> <li>Extremely non‑uniform sizes or densities dominate runtime: prefer BVH or hybrid.</li> <li>Highly coherent 1D motion (e.g., stacks, axis‑aligned sweeps): SAP can be faster.</li> <li>Very small n (&lt;50): the constant factors of hashing may outweigh benefits; naïve is fine.</li> </ul> <h3 id="takeaways">Takeaways</h3> <ul> <li>Pick a cell size that matches your object scale, watch per‑cell occupancy, and use a clear dedup rule.</li> <li>Measure candidate pairs and FPS as you tune; grids can deliver near‑linear scaling for typical game scenes.</li> </ul>]]></content><author><name></name></author><category term="blog"/><category term="game-dev"/><category term="algorithms"/><category term="collision-detection"/><category term="performance"/><category term="interactive"/><summary type="html"><![CDATA[An interactive broad‑phase collision demo showing why uniform grids (spatial hashing) beat O(n²) for many moving objects in real‑time games.]]></summary></entry><entry><title type="html">Interactive Inverse Kinematics: CCD, FABRIK, and Jacobian Transpose</title><link href="https://saeed1262.github.io/blog/2025/inverse-kinematics-models/" rel="alternate" type="text/html" title="Interactive Inverse Kinematics: CCD, FABRIK, and Jacobian Transpose"/><published>2025-08-17T00:00:00+00:00</published><updated>2025-08-17T00:00:00+00:00</updated><id>https://saeed1262.github.io/blog/2025/inverse-kinematics-models</id><content type="html" xml:base="https://saeed1262.github.io/blog/2025/inverse-kinematics-models/"><![CDATA[<p>Inverse kinematics (IK) asks: given a desired end‑effector position, what joint angles produce it? Below you can compare three widely used IK solvers side‑by‑side on a planar arm. Drag the target, switch algorithms, and tune parameters to feel their behavior.</p> <div id="ik-container"> <div id="ik-controls"> <div class="control-panel"> <h5>Algorithm Selection</h5> <div class="control-group"> <div class="control-row"> <select id="ikAlgo"> <option value="ccd">CCD (Cyclic Coordinate Descent)</option> <option value="fabrik">FABRIK (Forward/Backward)</option> <option value="jt">Jacobian Transpose</option> <option value="dls">DLS (Damped Least Squares)</option> </select> </div> </div> </div> <div class="control-panel"> <h5>Basic Parameters</h5> <div class="control-group"> <label>Links: <span class="value" id="linksLabel">4</span></label> <input id="links" type="range" min="2" max="12" step="1" value="4"/> </div> <div class="control-group"> <label>Link Length: <span class="value" id="lenLabel">90</span> px</label> <input id="len" type="range" min="30" max="140" step="5" value="90"/> </div> <div class="control-group"> <label>Iterations/Frame: <span class="value" id="itersLabel">8</span></label> <input id="iters" type="range" min="1" max="64" step="1" value="8"/> </div> </div> <div class="control-panel"> <h5>Algorithm Settings</h5> <div class="control-group" id="jt-only"> <label>JT Step (γ): <span class="value" id="gammaLabel">0.3</span></label> <input id="gamma" type="range" min="0.02" max="1.0" step="0.02" value="0.3"/> </div> <div class="control-group" id="dls-only"> <label>DLS λ: <span class="value" id="lambdaLabel">2.0</span></label> <input id="lambda" type="range" min="0.0" max="10.0" step="0.1" value="2.0"/> </div> <div class="control-group"> <label>Damping: <span class="value" id="dampLabel">0.6</span></label> <input id="damp" type="range" min="0.05" max="1.0" step="0.05" value="0.6"/> </div> </div> <div class="control-panel"> <h5>Joint Limits</h5> <div class="control-group"> <div class="control-row"> <label class="checkbox"><input id="limitsEnabled" type="checkbox"/> Enable</label> <label>±<span class="value" id="limitDegLabel">160</span>°</label> </div> <input id="limitDeg" type="range" min="10" max="180" step="5" value="160"/> <div class="control-row"> <label class="checkbox"><input id="showLimits" type="checkbox"/> Show Limit Arcs</label> </div> </div> </div> <div class="control-panel"> <h5>Rest Pose</h5> <div class="control-group"> <label>Rest Pose Bias: <span class="value" id="restLabel">0.00</span></label> <input id="restBias" type="range" min="0.00" max="0.50" step="0.01" value="0.00"/> <div class="control-row"> <button class="button" id="setRest">Set Rest = Current</button> <button class="button" id="resetRest">Reset Rest</button> </div> </div> </div> <div class="control-panel"> <h5>Moving Target</h5> <div class="control-group"> <div class="control-row"> <button class="button" id="moveNone">Stop</button> <button class="button" id="moveCircle">Circle</button> <button class="button" id="moveEight">Figure‑8</button> </div> <label>Speed: <span class="value" id="speed2Label">1.0</span>x</label> <input id="targetSpeed" type="range" min="0.2" max="3.0" step="0.1" value="1.0"/> </div> </div> <div class="control-panel"> <h5>Visualization &amp; Utilities</h5> <div class="control-group"> <div class="control-row"> <label class="checkbox"><input id="pauseIK" type="checkbox"/> Pause</label> <label class="checkbox"><input id="showGhost" type="checkbox" checked=""/> Show Reach Circle</label> </div> <div class="control-row"> <label class="checkbox"><input id="showTrace" type="checkbox"/> Trace End‑Effector</label> <label class="checkbox"><input id="showMetrics" type="checkbox" checked=""/> Show Metrics</label> </div> <div class="control-row"> <button class="button" id="toggleHelp">Help</button> </div> </div> </div> </div> <div id="ik-viz-container" aria-label="Inverse kinematics playground"> <canvas id="ik-canvas" width="1400" height="900"></canvas> <div class="loading" id="ik-loading">Loading IK demo…</div> </div> <div id="ik-hud"> <div class="hud-panel"> <h4>Status</h4> <div class="hud-value"><span class="label">Algorithm</span><span class="value" id="hudAlgo">CCD</span></div> <div class="hud-value"><span class="label">End‑Effector Error</span><span class="value" id="hudErr">0.0 px</span></div> <div class="hud-value"><span class="label">Iterations</span><span class="value" id="hudIters">0</span></div> <div class="hud-value"><span class="label">FPS</span><span class="value" id="hudFps">0</span></div> </div> <div class="hud-panel"> <h4>Tips</h4> <ul class="notes"> <li>Drag anywhere to move the target; hold Shift to move the base.</li> <li>CCD: simple and robust; converges gradually joint‑by‑joint.</li> <li>FABRIK: geometric, fast convergence in many cases.</li> <li>Jacobian‑Transpose: gradient‑like; tune γ for stability.</li> </ul> </div> </div> </div> <style>.container{max-width:1200px;margin:0 auto}.post{max-width:1200px;margin:0 auto}.post-content{max-width:1200px;margin:0 auto}</style> <link rel="stylesheet" href="/assets/css/ik-playground.css?v=4"/> <script defer="" src="/assets/js/ik-playground.js?v=4"></script> <div id="ik-help" hidden=""> <div class="ik-help-content"> <h3>IK Playground Help</h3> <p>Drag to move the target; hold Shift to drag the base. Use the controls to change solver, link count/length, iterations, damping, joint limits, and add a rest‑pose bias.</p> <p>Moving targets let you compare tracking behavior.</p> <ul> <li>Shortcuts: 1=CCD, 2=FABRIK, 3=JT, 4=DLS, p=pause, t=trace, g=reach, k=metrics, ?=help, c=circle, l=figure‑8, s=stop</li> </ul> <button class="button" id="closeHelp">Close</button> </div> <div class="ik-help-backdrop"></div> </div> <h2 id="why-i-built-this">Why I Built This</h2> <p>IK sits at a beautiful intersection of robotics, character animation, and human–computer interaction. I wanted a hands‑on way to feel how classic solvers behave under constraints, limits, and moving targets—so you can build intuition, not just read formulas. This playground lets you drag a target and immediately see solver trade‑offs in stability, speed, and path smoothness.</p> <h2 id="where-ik-shows-up">Where IK Shows Up</h2> <p>If you’ve ever dragged a character’s hand onto a doorknob in an animation tool, or watched a robot smoothly align a gripper with a bolt, you’ve seen IK at work. Games lean on it to plant feet on uneven ground; VR headsets use it to guess a whole body from a few tracked points; mocap artists use it to tame jitter and fill gaps. The point isn’t just “reaching a position” — it’s doing so while staying within joint limits, preferring comfortable poses, and moving in a way that looks intentional.</p> <h2 id="how-the-demo-works">How The Demo Works</h2> <p>Drag the orange crosshair and the arm tries to follow. Under the hood, forward kinematics turns the current joint angles into points in space; then, several times per frame, the chosen solver nudges those angles to shrink the gap to the target. After each nudge, we respect joint limits if you’ve enabled them, and we can gently bias the motion back toward a rest pose so things don’t collapse into awkward shapes. You can switch algorithms on the fly to feel how each one “thinks,” and turn on metrics to watch the error curve settle as the arm converges.</p> <h2 id="complexity--scaling">Complexity &amp; Scaling</h2> <p>Not all IK steps cost the same. CCD in this simple form touches one joint at a time and re‑does forward kinematics after each tweak, which makes a full sweep scale roughly like n² for n links. FABRIK runs two clean passes along the chain and lands at O(n) per iteration. Jacobian‑based methods also build O(n) updates in this 2D setup; the transpose variant takes a smart step in the gradient’s direction, while Damped Least Squares solves a tiny 2×2 system to stay stable near straightened‑out poses. In practice, you can raise Iterations/Frame until the error curve gets calm, then balance snappiness vs. smoothness with JT’s γ or DLS’s λ plus the global damping.</p> <h2 id="visual-intuition">Visual Intuition</h2> <p>The end‑effector wants to reach the target. CCD swings one joint at a time so the segment points more toward the target. FABRIK slides points along lines to keep segment lengths while pulling the end to the goal. Jacobian methods compute how small angle changes move the end point, then nudge all joints together.</p> <h2 id="three-ways-to-solve-it">Three Ways To Solve It</h2> <p>There isn’t one “right” way to do IK — there are families of approaches with different personalities. CCD feels like a careful hand guiding each joint in turn. FABRIK acts like a strand of beads that slides into shape. Jacobian methods think locally: “if I turn joints this much, the end will move that way.” Real rigs mix these ideas with limits, damping, and sometimes orientation goals; the core intuition carries through.</p> <h2 id="play-with-it">Play With It</h2> <p>Start simple: drag the target a short distance and watch how each solver approaches it. CCD will send a ripple down the chain, joint by joint, like a snake finding its way. FABRIK tends to straighten segments into clean lines and snaps into place in just a few passes. Jacobian‑Transpose moves everything together in smooth, coordinated nudges — turn the step down if it starts to overshoot.</p> <p>Make it harder. Hold Shift and move the green base to change what’s reachable, then try pulling the target beyond the reach circle to see how each solver hugs the boundary. Turn on joint limits and show limit arcs; you’ll notice how CCD inches along the constraints, FABRIK rebalances lengths gracefully, and Jacobian methods slow down near singular poses unless you give them a bit more damping or λ.</p> <p>Finally, give the system a rhythm. Put the target on a circle or figure‑8, enable trace, and compare how closely each solver tracks the path. You’ll feel the trade‑off: faster steps react quickly but can ring; heavier damping and DLS stay composed but lag a touch.</p> <h2 id="appendix-shareable-presets">Appendix: Shareable Presets</h2> <p>The demo reads settings from the URL, so you can share a preset. Example:</p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>?algo=dls&amp;n=6&amp;L=80&amp;it=16&amp;la=3&amp;d=0.7&amp;rg=1&amp;tr=1&amp;mv=eight&amp;sp=1.2
</code></pre></div></div> <p>Parameters:</p> <ul> <li> <table> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">algo</code>: ccd</td> <td>fabrik</td> <td>jt</td> <td>dls</td> </tr> </tbody> </table> </li> <li><code class="language-plaintext highlighter-rouge">n</code>: number of links</li> <li><code class="language-plaintext highlighter-rouge">L</code>: link length (px)</li> <li><code class="language-plaintext highlighter-rouge">it</code>: iterations per frame</li> <li><code class="language-plaintext highlighter-rouge">g</code>: JT step gamma (γ)</li> <li><code class="language-plaintext highlighter-rouge">la</code>: DLS lambda (λ)</li> <li><code class="language-plaintext highlighter-rouge">d</code>: damping [0..1]</li> <li><code class="language-plaintext highlighter-rouge">px</code>: pause (0 or 1)</li> <li><code class="language-plaintext highlighter-rouge">rg</code>: show reach circle (0 or 1)</li> <li><code class="language-plaintext highlighter-rouge">tr</code>: show trace (0 or 1)</li> <li><code class="language-plaintext highlighter-rouge">lm</code>: enable joint limits (0 or 1)</li> <li><code class="language-plaintext highlighter-rouge">ld</code>: joint limit degrees (±)</li> <li><code class="language-plaintext highlighter-rouge">sl</code>: show limit arcs (0 or 1)</li> <li><code class="language-plaintext highlighter-rouge">rb</code>: rest pose bias [0..0.5]</li> <li> <table> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">mv</code>: target motion mode: none</td> <td>circle</td> <td>eight</td> </tr> </tbody> </table> </li> <li><code class="language-plaintext highlighter-rouge">sp</code>: target speed multiplier</li> <li><code class="language-plaintext highlighter-rouge">mx,my</code>: base position (px)</li> <li><code class="language-plaintext highlighter-rouge">tx,ty</code>: target position (px)</li> </ul> <h2 id="what-it-feels-like">What It Feels Like</h2> <p>CCD progresses joint‑by‑joint from the end — you can literally watch the “wave” of corrections travel back to the base. FABRIK often finds a clean, nearly straight path in just a few sweeps. Jacobian‑Transpose updates everything at once; it’s wonderfully smooth when the step is tamed, and a little exuberant if you let γ run wild. Outside the reach circle, all methods settle on the boundary in the closest direction they can manage.</p> <h3 id="problem-setup-2d-planar-chain">Problem Setup (2D Planar Chain)</h3> <p>We’re solving for joint angles <code class="language-plaintext highlighter-rouge">θ = [θ1..θn]</code> so the end‑effector position <code class="language-plaintext highlighter-rouge">p(θ)</code> matches a target <code class="language-plaintext highlighter-rouge">t</code>. Each link has length <code class="language-plaintext highlighter-rouge">L</code> and we keep the base fixed, so forward kinematics is just a sum of rotations and offsets along the chain. All the solvers below chase the same objective — reduce the position error <code class="language-plaintext highlighter-rouge">e = t − p(θ)</code> — but they update <code class="language-plaintext highlighter-rouge">θ</code> in different ways.</p> <h3 id="ccd-cyclic-coordinate-descent">CCD (Cyclic Coordinate Descent)</h3> <p>CCD is the “one joint at a time” approach. Starting from the tip and walking back to the base, each joint turns just enough to make the end‑effector point more directly at the target. It’s dead simple and very forgiving — great when you just need something that works — but on long chains you’ll see a characteristic wiggle and a bit more time to settle.</p> <p>Geometrically, for joint i with position p_i, end‑effector e, and target t, define</p> \[\mathbf{u} = e - p_i,\quad \mathbf{v} = t - p_i.\] <p>The signed rotation that best aligns u to v in 2D is</p> \[\Delta\theta_i = \operatorname{atan2}(\,u_x v_y - u_y v_x,\; u_x v_x + u_y v_y\,)\] <p>and we apply a damped update</p> \[\theta_i \leftarrow \theta_i + \eta\,\Delta\theta_i, \quad 0&lt;\eta\le 1.\] <p>After changing θ_i we recompute forward kinematics so the next joint acts on the new end‑effector position. CCD naturally handles unreachable targets: the chain aligns toward t and settles at the boundary of the reach circle.</p> <p>Pseudo‑steps per sweep:</p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for i = n-1 down to 0:
  a1 = angle(j_i → end_effector)
  a2 = angle(j_i → target)
  θ_i += wrap_to_pi(a2 - a1) * damping
  forward_kinematics()
</code></pre></div></div> <h3 id="fabrik-forward-and-backward-reaching-ik">FABRIK (Forward And Backward Reaching IK)</h3> <p>FABRIK works directly in position space with two elegant passes. First it fixes the end at the target and drags joints backward along straight lines while keeping segment lengths. Then it pins the base and pushes forward the same way. The result is fast, stable convergence without building Jacobians — you get clean motion with very little fuss.</p> <table> <tbody> <tr> <td>Let joints be positions p_0, …, p_n with segment lengths L_i =</td> <td> </td> <td>p_{i+1}-p_i</td> <td> </td> <td>(kept constant).</td> </tr> </tbody> </table> <ul> <li>If the target t is unreachable, set every segment to point toward t:</li> </ul> \[p_{i+1} \leftarrow p_i + L_i\,\frac{t-p_i}{\lVert t-p_i\rVert}.\] <ul> <li>Otherwise, do two passes per iteration: <ul> <li> <p>Backward (anchor end at t): set p_n ← t, then for i = n−1…0</p> \[p_i \leftarrow p_{i+1} + L_{i}\,\frac{p_i - p_{i+1}}{\lVert p_i - p_{i+1}\rVert}.\] </li> <li> <p>Forward (anchor base at p_0^0): set p_0 ← p_0^0, then for i = 0…n−1</p> \[p_{i+1} \leftarrow p_{i} + L_{i}\,\frac{p_{i+1} - p_{i}}{\lVert p_{i+1} - p_{i}\rVert}.\] </li> </ul> </li> </ul> <p>Angles θ are then recovered from adjacent positions. Constraints like joint limits fit by clamping angles after each iteration.</p> <p>Pseudo‑steps per iteration:</p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// If unreachable: point segments toward target and stop.
end = target
for i = n-1..0:  j_i = j_{i+1} + L * normalize(j_i - j_{i+1})
base stays fixed
for i = 0..n-1:  j_{i+1} = j_i + L * normalize(j_{i+1} - j_i)
</code></pre></div></div> <h3 id="jacobian-transpose-jt">Jacobian Transpose (JT)</h3> <p>Jacobian‑Transpose thinks like a gradient step: if small changes in angles move the end by <code class="language-plaintext highlighter-rouge">Δp ≈ J Δθ</code>, then turning in the direction of <code class="language-plaintext highlighter-rouge">J^T (t − p)</code> should make the error shrink. Here it takes an adaptive step and clamps it by <code class="language-plaintext highlighter-rouge">γ</code> for stability. The payoff is coordinated, smooth updates and an easy path to richer goals (like mixing position and orientation) — as long as you keep the step size in check near singular poses.</p> <p>We minimize position error r = t − p(θ). Linearizing</p> \[\Delta\mathbf{p} \approx J(\theta)\,\Delta\boldsymbol{\theta}.\] <table> <tbody> <tr> <td>Gradient descent on E = 1/2</td> <td> </td> <td>r</td> <td> </td> <td>^2 gives</td> </tr> </tbody> </table> \[\Delta\boldsymbol{\theta} = -\alpha\,\nabla_{\theta}E = \alpha\,J^T r.\] <p>Choosing the step by projecting the desired motion r onto the predicted motion v = J J^T r yields</p> \[\alpha = \frac{r^\top v}{v^\top v + \varepsilon} = \frac{r^\top J J^T r}{\lVert J J^T r\rVert^2 + \varepsilon},\] <p>then clamp 0 ≤ α ≤ γ for stability (as done in the demo). In 2D, the Jacobian column for joint i is a perpendicular to the joint→end vector; see the dedicated section below.</p> <p>Update rule used here:</p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>u = J^T r          // per-joint update direction
v = J u            // predicted end-effector motion
α = clamp( (r·v) / (v·v + ε), 0, γ )
θ ← θ + α u * damping
</code></pre></div></div> <h3 id="jacobian-for-a-planar-chain-2d">Jacobian for a Planar Chain (2D)</h3> <ul> <li>For joint i at position <code class="language-plaintext highlighter-rouge">p_i = (x_i, y_i)</code> and the end‑effector at <code class="language-plaintext highlighter-rouge">e = (x_e, y_e)</code>, the Jacobian column with respect to <code class="language-plaintext highlighter-rouge">θ_i</code> is <code class="language-plaintext highlighter-rouge">[−(y_e − y_i), (x_e − x_i)]</code>.</li> <li>This geometric form (a perpendicular to the joint→end vector) is what the demo uses for both JT and DLS updates.</li> </ul> <h3 id="damped-least-squares-dls">Damped Least Squares (DLS)</h3> <p>DLS is the calm one. It takes a regularized least‑squares step <code class="language-plaintext highlighter-rouge">Δθ = J^T (J J^T + λ^2 I)^{-1} r</code>, which naturally tempers directions that would otherwise explode near singularities. Turn λ up for composure, down for responsiveness, and you’ll get graceful behavior even when the target or base won’t sit still.</p> <p>Formally, solve the Tikhonov‑regularized problem</p> \[\min_{\Delta\theta}\;\lVert J\,\Delta\theta - r\rVert^2 + \lambda^2\,\lVert \Delta\theta\rVert^2,\] <p>whose normal equations give</p> \[\Delta\theta = (J^T J + \lambda^2 I)^{-1} J^T r.\] <p>Using the matrix identity (Woodbury), this equals the dual form we implement efficiently in 2D task‑space:</p> \[\Delta\theta = J^T\,(J J^T + \lambda^2 I)^{-1} r.\] <p>As λ → 0 you recover least‑squares (fast but sensitive); as λ grows you get smaller, more conservative steps. Combine with a global damping factor to smooth motion frame‑to‑frame.</p> <p>Pseudo‑step (2D task):</p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>A = J J^T + λ^2 I    // 2×2 in this demo
y = A^{-1} r
Δθ = J^T y
θ ← θ + Δθ * damping
</code></pre></div></div> <p>Tuning: raise <code class="language-plaintext highlighter-rouge">λ</code> for stability (less aggressive updates), lower it for responsiveness. Combine with global <code class="language-plaintext highlighter-rouge">Damping</code> for smooth paths.</p> <h2 id="when-things-get-tricky">When Things Get Tricky</h2> <p>Outside the reach circle, all methods will align toward the target and rest on the boundary — that’s expected. Near straight‑line (singular) poses, gradient‑based updates can wobble unless you rein them in; that’s why the JT step is clamped by <code class="language-plaintext highlighter-rouge">γ</code>, and why DLS’s λ exists at all. If you see ringing, ease γ up or add damping; if things feel sluggish, give the solver a few more iterations per frame. Joint limits add realism but also resistance — clamp after each update and let the solvers negotiate their way along the arcs rather than fighting them.</p> <h2 id="which-solver-when">Which Solver When</h2> <p>Use CCD when you want a tiny, dependable hammer and don’t mind a little wiggle on long chains. Reach for FABRIK when you care about fast, stable convergence and clean paths — it’s a favorite for character rigs. Choose Jacobian methods when you want to combine objectives (position now, orientation later) and tune behavior; DLS, in particular, shines when you need robustness over raw snap.</p> <h2 id="beyond-this-demo">Beyond This Demo</h2> <p>There’s plenty more to explore: per‑joint limits and soft preferences, stronger regularization, end‑effector orientation, even obstacle avoidance by projecting joints away between passes. The math scales naturally to 3D, and the same ideas power everything from robotic arms to full‑body avatars.</p> <h3 id="references-and-further-reading">References and Further Reading</h3> <ul> <li>Aristidou &amp; Lasenby, “FABRIK: A fast, iterative solver for the Inverse Kinematics problem” (2011)</li> <li>Buss, “Introduction to Inverse Kinematics with Jacobian Methods” (2004)</li> <li>Tolani, Goswami, &amp; Badler, “Real-Time Inverse Kinematics Techniques for Anthropomorphic Limbs” (2000)</li> <li>Wampler, “Manipulator Inverse Kinematic Solutions Based on Vector Formulations and Damped Least‑Squares Methods” (1986)</li> <li>Nakamura &amp; Hanafusa, “Inverse kinematics solutions with singularity avoidance for robot manipulator control” (1986)</li> <li>Maciejewski &amp; Klein, “Obstacle avoidance for kinematically redundant manipulators in dynamically varying environments” (1985)</li> </ul>]]></content><author><name></name></author><category term="blog"/><category term="robotics"/><category term="animation"/><category term="kinematics"/><category term="algorithms"/><category term="interactive"/><summary type="html"><![CDATA[Play with three classic IK solvers on a 2D arm: CCD, FABRIK, and Jacobian‑transpose. Drag the target, tweak links, and watch convergence.]]></summary></entry><entry><title type="html">Interactive 3D N-Body Gravity Simulation with Barnes-Hut Optimization</title><link href="https://saeed1262.github.io/blog/2025/nbody-barnes-hut-3d/" rel="alternate" type="text/html" title="Interactive 3D N-Body Gravity Simulation with Barnes-Hut Optimization"/><published>2025-08-10T00:00:00+00:00</published><updated>2025-08-10T00:00:00+00:00</updated><id>https://saeed1262.github.io/blog/2025/nbody-barnes-hut-3d</id><content type="html" xml:base="https://saeed1262.github.io/blog/2025/nbody-barnes-hut-3d/"><![CDATA[<h2 id="why-i-built-this">Why I Built This</h2> <p>I’ve always been fascinated by gravity. Not just the everyday kind that keeps us grounded, but the cosmic choreography that shapes entire galaxies. How do billions of stars dance together to form those beautiful spiral arms we see in Hubble images? What happens when two galaxies collide? These questions led me down a rabbit hole that eventually resulted in this interactive 3D simulation.</p> <p>The <strong>N-body problem</strong> is basically this: if you have N objects all pulling on each other with gravity, how do they move? For two objects (like Earth and Moon), we can solve this exactly. But add just one more object and suddenly the math becomes… well, let’s just say there’s no clean solution. You need to simulate it step by step.</p> <p>I wanted to show you two different approaches:</p> <ul> <li><strong>Barnes-Hut Algorithm</strong>: A clever trick that makes the simulation blazing fast</li> <li><strong>Direct Summation</strong>: The brute-force approach where every particle feels every other particle</li> </ul> <p>But here’s what really excites me about this project…</p> <h2 id="the-real-story-of-galaxy-formation">The Real Story of Galaxy Formation</h2> <p>Before we dive into the simulation, let me clear up a common misconception. Galaxies didn’t form from explosions—that’s actually way cooler than that.</p> <p>Picture this: About 13.8 billion years ago, the Big Bang created a universe that was almost perfectly smooth, but not quite. There were tiny density fluctuations—some regions had just a little bit more matter than others. These tiny differences were like seeds.</p> <p>Over millions of years, gravity did its thing. The denser regions attracted more matter, growing slowly but steadily. Dark matter (which we can’t see but makes up most of the universe) clumped together first, forming invisible scaffolding called “dark matter halos.”</p> <p>Then regular matter—hydrogen and helium gas—fell into these dark matter halos like water flowing into a bowl. As the gas collapsed, it started spinning (conservation of angular momentum), forming rotating discs. When the gas became dense and hot enough, stars began to form.</p> <p><strong>This is exactly what you’ll see in the simulation!</strong> Those rotating discs that emerge aren’t just pretty patterns—they’re recreating billions of years of cosmic evolution in fast-forward. The spiral arms that develop naturally from gravitational instabilities? That’s how we think our own Milky Way got its iconic shape.</p> <p>The galaxy merger scenarios I included show another crucial part of the story. Galaxies aren’t isolated islands—they’re constantly interacting, merging, and growing. Most large galaxies, including ours, are thought to be the result of many smaller galaxies merging over cosmic time.</p> <p>So no explosions—just gravity, time, and the universe’s incredible ability to build structure from simplicity.</p> <h2 id="this-is-how-we-study-the-universe">This Is How We Study the Universe</h2> <p>When I started building this simulation, I didn’t realize I was essentially recreating the same methods that astronomers use to understand cosmic evolution. It turns out the algorithms running in your browser right now are the same ones powering some of the most ambitious scientific endeavors in human history.</p> <h3 id="galaxy-formation-in-your-browser"><strong>Galaxy Formation in Your Browser</strong></h3> <p>That rotating disc you’ll see in the simulation? That’s not just a pretty pattern—it’s how we think the Milky Way formed billions of years ago. Astrophysicists run massive versions of this simulation with millions of particles to understand how spiral arms emerge and evolve.</p> <p>The “Galaxy Merger” preset I included recreates one of the most dramatic events in cosmic history. In about 4.5 billion years, our Milky Way will collide with Andromeda—and this is exactly how scientists study what will happen.</p> <h3 id="cosmic-web-formation"><strong>Cosmic Web Formation</strong></h3> <p>The same Barnes-Hut algorithm I implemented here scales up to track dark matter particles forming the largest structures in the universe—the cosmic web of filaments that spans hundreds of millions of light-years. When you watch particles clumping together in the simulation, you’re seeing the same physics that created every galaxy cluster we observe.</p> <h3 id="a-1986-revolution"><strong>A 1986 Revolution</strong></h3> <p>Josh Barnes and Piet Hut published their breakthrough algorithm in 1986, and it completely transformed computational astrophysics. Before their work, simulations were limited to a few thousand particles—nowhere near enough to model realistic galaxies. Their clever insight about treating distant groups of particles as single masses suddenly made simulations with millions of particles possible.</p> <h3 id="modern-supercomputing"><strong>Modern Supercomputing</strong></h3> <p>Today’s astrophysics codes like GADGET, AREPO, and RAMSES use GPU acceleration to simulate systems with <em>billions</em> of particles. The Millennium Simulation—one of the most famous—followed 21.6 billion particles over the entire history of the universe, from shortly after the Big Bang to today.</p> <h3 id="what-youre-really-experiencing"><strong>What You’re Really Experiencing</strong></h3> <p>When you play with this simulation, you’re not just watching pretty dots move around. You’re experiencing the same fundamental physics that governs:</p> <ul> <li>How the cosmic web formed after the Big Bang</li> <li>Why our galaxy has spiral arms</li> <li>What will happen when Milky Way and Andromeda collide</li> <li>How globular clusters evolve over billions of years</li> </ul> <p>Every time you adjust the parameters and watch the system evolve, you’re doing the same kind of experiments that help us understand our place in the cosmos.</p> <h2 id="the-physics-behind-the-simulation">The Physics Behind the Simulation</h2> <h3 id="gravitational-n-body-dynamics">Gravitational N-Body Dynamics</h3> <p>Each particle in our simulation follows Newton’s laws under gravitational forces from all other particles. The gravitational force between two particles with masses $m_i$ and $m_j$ separated by distance $r_{ij}$ is:</p> \[\vec{F}_{ij} = -G \frac{m_i m_j}{|\vec{r}_{ij}|^3} \vec{r}_{ij}\] <p>Where:</p> <ul> <li>$G$ is the gravitational constant</li> <li>$\vec{r}_{ij} = \vec{r}_j - \vec{r}_i$ is the separation vector</li> <li>The negative sign indicates attraction</li> </ul> <p>The total force on particle $i$ is the sum over all other particles:</p> \[\vec{F}_i = \sum_{j \neq i} \vec{F}_{ij}\] <p>This leads to the equation of motion:</p> \[m_i \frac{d^2\vec{r}_i}{dt^2} = \vec{F}_i\] <h3 id="the-computational-challenge">The Computational Challenge</h3> <p>For N particles, computing all pairwise forces requires $\frac{N(N-1)}{2} \approx \frac{N^2}{2}$ calculations per time step. This <strong>O(N²) scaling</strong> becomes prohibitively expensive for large systems:</p> <ul> <li><strong>1,000 particles</strong>: ~500,000 force calculations</li> <li><strong>10,000 particles</strong>: ~50,000,000 force calculations</li> <li><strong>100,000 particles</strong>: ~5,000,000,000 force calculations</li> </ul> <p>Real astrophysical simulations often involve millions or billions of particles, making direct methods impractical.</p> <h2 id="the-barnes-hut-algorithm">The Barnes-Hut Algorithm</h2> <h3 id="core-principle">Core Principle</h3> <p>The Barnes-Hut algorithm, developed by Josh Barnes and Piet Hut in 1986, reduces computational complexity from O(N²) to <strong>O(N log N)</strong> using a clever approximation: distant groups of particles can be treated as single massive particles located at their center of mass.</p> <h3 id="spatial-decomposition-with-octrees">Spatial Decomposition with Octrees</h3> <p>The algorithm works by:</p> <ol> <li><strong>Spatial Subdivision</strong>: Recursively divide 3D space into octants (8 cubic regions)</li> <li><strong>Hierarchical Tree</strong>: Build an octree where each node represents a spatial region</li> <li><strong>Mass Distribution</strong>: Store total mass and center of mass for each node</li> <li><strong>Multipole Approximation</strong>: Use the multipole acceptance criterion to decide when to approximate</li> </ol> <div style="text-align: center; margin: 2rem 0;"> <svg width="700" height="450" viewBox="0 0 700 450" style="background: linear-gradient(135deg, #0a0a0a 0%, #1a1a1a 100%); border: 1px solid #333; border-radius: 12px; box-shadow: 0 4px 20px rgba(0,0,0,0.3);"> <text x="350" y="30" fill="#64ffda" font-size="18" font-weight="bold" text-anchor="middle" style="text-shadow: 0 0 10px rgba(100,255,218,0.5);">Barnes-Hut Octree Structure</text> <g transform="translate(60, 60)"> <rect x="-5" y="-5" width="210" height="210" fill="rgba(0,0,0,0.2)" stroke="none" rx="8"/> <rect x="0" y="0" width="200" height="200" fill="none" stroke="#64ffda" stroke-width="3" rx="4"/> <line x1="100" y1="0" x2="100" y2="200" stroke="#4caf50" stroke-width="2" opacity="0.8"/> <line x1="0" y1="100" x2="200" y2="100" stroke="#4caf50" stroke-width="2" opacity="0.8"/> <line x1="50" y1="50" x2="150" y2="50" stroke="#ff9800" stroke-width="1.5" opacity="0.6"/> <line x1="50" y1="150" x2="150" y2="150" stroke="#ff9800" stroke-width="1.5" opacity="0.6"/> <line x1="50" y1="50" x2="50" y2="150" stroke="#ff9800" stroke-width="1.5" opacity="0.6"/> <line x1="150" y1="50" x2="150" y2="150" stroke="#ff9800" stroke-width="1.5" opacity="0.6"/> <text x="50" y="50" fill="#64ffda" font-size="10" text-anchor="middle" opacity="0.7">I</text> <text x="150" y="50" fill="#64ffda" font-size="10" text-anchor="middle" opacity="0.7">II</text> <text x="50" y="150" fill="#64ffda" font-size="10" text-anchor="middle" opacity="0.7">III</text> <text x="150" y="150" fill="#64ffda" font-size="10" text-anchor="middle" opacity="0.7">IV</text> <defs> <filter id="glow"> <feGaussianBlur stdDeviation="2" result="coloredBlur"/> <feMerge> <feMergeNode in="coloredBlur"/> <feMergeNode in="SourceGraphic"/> </feMerge> </filter> </defs> <circle cx="30" cy="30" r="3.5" fill="#ff6b6b" filter="url(#glow)"/> <circle cx="80" cy="40" r="3.5" fill="#ff6b6b" filter="url(#glow)"/> <circle cx="120" cy="70" r="3.5" fill="#ff6b6b" filter="url(#glow)"/> <circle cx="160" cy="120" r="3.5" fill="#ff6b6b" filter="url(#glow)"/> <circle cx="40" cy="160" r="3.5" fill="#ff6b6b" filter="url(#glow)"/> <circle cx="180" cy="180" r="3.5" fill="#ff6b6b" filter="url(#glow)"/> <circle cx="70" cy="180" r="3.5" fill="#ff6b6b" filter="url(#glow)"/> <circle cx="170" cy="40" r="3.5" fill="#ff6b6b" filter="url(#glow)"/> <circle cx="55" cy="35" r="5" fill="#4caf50" stroke="#fff" stroke-width="2" filter="url(#glow)"/> <circle cx="145" cy="80" r="5" fill="#4caf50" stroke="#fff" stroke-width="2" filter="url(#glow)"/> <circle cx="125" cy="150" r="5" fill="#4caf50" stroke="#fff" stroke-width="2" filter="url(#glow)"/> <circle cx="55" cy="170" r="5" fill="#4caf50" stroke="#fff" stroke-width="2" filter="url(#glow)"/> <text x="100" y="220" fill="#ccc" font-size="12" text-anchor="middle" font-weight="bold">3D Space Subdivision</text> </g> <g transform="translate(340, 70)"> <rect x="-10" y="-10" width="180" height="140" fill="rgba(0,0,0,0.15)" stroke="none" rx="8"/> <rect x="65" y="0" width="50" height="30" fill="#64ffda" stroke="#fff" stroke-width="2" rx="4"/> <text x="90" y="20" fill="#000" font-size="12" font-weight="bold" text-anchor="middle">Root</text> <line x1="90" y1="30" x2="90" y2="50" stroke="#ccc" stroke-width="2"/> <line x1="30" y1="55" x2="150" y2="55" stroke="#ccc" stroke-width="2"/> <line x1="30" y1="50" x2="30" y2="55" stroke="#ccc" stroke-width="2"/> <line x1="70" y1="50" x2="70" y2="55" stroke="#ccc" stroke-width="2"/> <line x1="110" y1="50" x2="110" y2="55" stroke="#ccc" stroke-width="2"/> <line x1="150" y1="50" x2="150" y2="55" stroke="#ccc" stroke-width="2"/> <rect x="10" y="60" width="35" height="25" fill="#4caf50" stroke="#fff" stroke-width="1.5" rx="3"/> <text x="27.5" y="76" fill="#fff" font-size="10" font-weight="bold" text-anchor="middle">Q1</text> <rect x="55" y="60" width="35" height="25" fill="#4caf50" stroke="#fff" stroke-width="1.5" rx="3"/> <text x="72.5" y="76" fill="#fff" font-size="10" font-weight="bold" text-anchor="middle">Q2</text> <rect x="100" y="60" width="35" height="25" fill="#4caf50" stroke="#fff" stroke-width="1.5" rx="3"/> <text x="117.5" y="76" fill="#fff" font-size="10" font-weight="bold" text-anchor="middle">Q3</text> <rect x="145" y="60" width="35" height="25" fill="#4caf50" stroke="#fff" stroke-width="1.5" rx="3"/> <text x="162.5" y="76" fill="#fff" font-size="10" font-weight="bold" text-anchor="middle">Q4</text> <line x1="72.5" y1="85" x2="72.5" y2="100" stroke="#ccc" stroke-width="2"/> <line x1="55" y1="105" x2="90" y2="105" stroke="#ccc" stroke-width="2"/> <line x1="55" y1="100" x2="55" y2="105" stroke="#ccc" stroke-width="2"/> <line x1="90" y1="100" x2="90" y2="105" stroke="#ccc" stroke-width="2"/> <rect x="40" y="110" width="25" height="20" fill="#ff9800" stroke="#fff" stroke-width="1.5" rx="3"/> <text x="52.5" y="123" fill="#fff" font-size="9" font-weight="bold" text-anchor="middle">2.1</text> <rect x="75" y="110" width="25" height="20" fill="#ff9800" stroke="#fff" stroke-width="1.5" rx="3"/> <text x="87.5" y="123" fill="#fff" font-size="9" font-weight="bold" text-anchor="middle">2.2</text> <text x="90" y="150" fill="#ccc" font-size="12" text-anchor="middle" font-weight="bold">Hierarchical Tree</text> </g> <g transform="translate(60, 320)"> <rect x="-10" y="0" width="220" height="60" fill="rgba(0,0,0,0.2)" stroke="#333" stroke-width="1" rx="8"/> <text x="0" y="20" fill="#64ffda" font-size="14" font-weight="bold">Legend</text> <circle cx="15" cy="40" r="4" fill="#ff6b6b" filter="url(#glow)"/> <text x="25" y="45" fill="#fff" font-size="12" font-weight="500">Particles</text> <circle cx="90" cy="40" r="5" fill="#4caf50" stroke="#fff" stroke-width="2" filter="url(#glow)"/> <text x="103" y="45" fill="#fff" font-size="12" font-weight="500">Center of Mass</text> </g> <g transform="translate(300, 320)"> <rect x="-10" y="0" width="380" height="100" fill="rgba(0,0,0,0.2)" stroke="#333" stroke-width="1" rx="8"/> <text x="0" y="20" fill="#64ffda" font-size="14" font-weight="bold">How It Works</text> <text x="0" y="40" fill="#fff" font-size="12">• 3D space recursively subdivided into octants (shown in 2D)</text> <text x="0" y="55" fill="#fff" font-size="12">• Each tree node stores total mass and center of mass</text> <text x="0" y="70" fill="#fff" font-size="12">• Subdivisions continue until each leaf contains ≤1 particle</text> <text x="0" y="85" fill="#fff" font-size="12">• Enables O(N log N) force calculations vs O(N²) direct method</text> </g> </svg> </div> <h3 id="the-multipole-acceptance-criterion">The Multipole Acceptance Criterion</h3> <p>For each particle, we traverse the octree and at each node ask: <em>“Can I treat this entire subtree as a single particle?”</em></p> <p>The criterion is: $\frac{s}{d} &lt; \theta$</p> <p>Where:</p> <ul> <li>$s$ = size of the tree node (spatial extent)</li> <li>$d$ = distance from particle to node’s center of mass</li> <li>$\theta$ = <strong>theta parameter</strong> (accuracy threshold)</li> </ul> <p><strong>If the criterion is satisfied</strong>: Treat the entire node as a single particle <strong>If not</strong>: Descend into child nodes and repeat</p> <div style="text-align: center; margin: 2rem 0;"> <svg width="800" height="420" viewBox="0 0 800 420" style="background: linear-gradient(135deg, #0a0a0a 0%, #1a1a1a 100%); border: 1px solid #333; border-radius: 12px; box-shadow: 0 4px 20px rgba(0,0,0,0.3);"> <text x="400" y="30" fill="#64ffda" font-size="18" font-weight="bold" text-anchor="middle" style="text-shadow: 0 0 10px rgba(100,255,218,0.5);">Multipole Acceptance Criterion: s/d &lt; θ</text> <defs> <filter id="glow-criterion"> <feGaussianBlur stdDeviation="3" result="coloredBlur"/> <feMerge> <feMergeNode in="coloredBlur"/> <feMergeNode in="SourceGraphic"/> </feMerge> </filter> </defs> <g transform="translate(70, 70)"> <rect x="-20" y="-20" width="300" height="180" fill="rgba(76,175,80,0.1)" stroke="#4caf50" stroke-width="1" rx="12"/> <text x="130" y="0" fill="#4caf50" font-size="16" font-weight="bold" text-anchor="middle">✓ ACCEPT</text> <text x="130" y="18" fill="#ccc" font-size="12" text-anchor="middle">s/d &lt; θ</text> <circle cx="30" cy="70" r="6" fill="#ff6b6b" filter="url(#glow-criterion)"/> <text x="30" y="95" fill="#fff" font-size="11" font-weight="500" text-anchor="middle">Particle</text> <rect x="180" y="50" width="60" height="60" fill="rgba(100,255,218,0.1)" stroke="#64ffda" stroke-width="2" rx="6"/> <circle cx="210" cy="80" r="5" fill="#4caf50" filter="url(#glow-criterion)"/> <text x="210" y="125" fill="#ccc" font-size="11" text-anchor="middle">Tree Node</text> <line x1="36" y1="70" x2="174" y2="80" stroke="#fff" stroke-width="2" stroke-dasharray="5,5" opacity="0.8"/> <text x="105" y="65" fill="#fff" font-size="12" font-weight="bold" text-anchor="middle">d (large)</text> <line x1="180" y1="40" x2="240" y2="40" stroke="#64ffda" stroke-width="3"/> <text x="210" y="35" fill="#64ffda" font-size="12" font-weight="bold" text-anchor="middle">s</text> <text x="130" y="140" fill="#4caf50" font-size="12" font-weight="bold" text-anchor="middle">Single Mass Approximation ⚡</text> </g> <g transform="translate(430, 70)"> <rect x="-20" y="-20" width="300" height="180" fill="rgba(244,67,54,0.1)" stroke="#f44336" stroke-width="1" rx="12"/> <text x="130" y="0" fill="#f44336" font-size="16" font-weight="bold" text-anchor="middle">✗ REJECT</text> <text x="130" y="18" fill="#ccc" font-size="12" text-anchor="middle">s/d ≥ θ</text> <circle cx="70" cy="70" r="6" fill="#ff6b6b" filter="url(#glow-criterion)"/> <text x="70" y="95" fill="#fff" font-size="11" font-weight="500" text-anchor="middle">Particle</text> <rect x="140" y="50" width="60" height="60" fill="rgba(244,67,54,0.1)" stroke="#f44336" stroke-width="2" rx="6"/> <circle cx="170" cy="80" r="5" fill="#4caf50" filter="url(#glow-criterion)"/> <text x="170" y="125" fill="#ccc" font-size="11" text-anchor="middle">Tree Node</text> <line x1="170" y1="50" x2="170" y2="110" stroke="#ff9800" stroke-width="2" opacity="0.8"/> <line x1="140" y1="80" x2="200" y2="80" stroke="#ff9800" stroke-width="2" opacity="0.8"/> <line x1="76" y1="70" x2="134" y2="80" stroke="#fff" stroke-width="2" stroke-dasharray="5,5" opacity="0.8"/> <text x="105" y="65" fill="#fff" font-size="12" font-weight="bold" text-anchor="middle">d (small)</text> <line x1="140" y1="40" x2="200" y2="40" stroke="#f44336" stroke-width="3"/> <text x="170" y="35" fill="#f44336" font-size="12" font-weight="bold" text-anchor="middle">s</text> <text x="130" y="140" fill="#f44336" font-size="12" font-weight="bold" text-anchor="middle">Must Subdivide 🎯</text> </g> <g transform="translate(100, 280)"> <rect x="-20" y="-10" width="640" height="100" fill="rgba(0,0,0,0.2)" stroke="#333" stroke-width="1" rx="12"/> <text x="300" y="15" fill="#ff9800" font-size="16" font-weight="bold" text-anchor="middle">Theta Parameter Balance</text> <g transform="translate(0, 30)"> <rect x="0" y="0" width="180" height="50" fill="rgba(76,175,80,0.1)" stroke="#4caf50" stroke-width="1" rx="8"/> <text x="90" y="20" fill="#4caf50" font-size="12" font-weight="bold" text-anchor="middle">Small θ (0.3-0.5)</text> <text x="90" y="35" fill="#ccc" font-size="10" text-anchor="middle">High accuracy, slower</text> <rect x="210" y="0" width="180" height="50" fill="rgba(100,255,218,0.1)" stroke="#64ffda" stroke-width="2" rx="8"/> <text x="300" y="20" fill="#64ffda" font-size="12" font-weight="bold" text-anchor="middle">Optimal θ (0.5-0.8)</text> <text x="300" y="35" fill="#ccc" font-size="10" text-anchor="middle">Best balance, ~1% error</text> <rect x="420" y="0" width="180" height="50" fill="rgba(244,67,54,0.1)" stroke="#f44336" stroke-width="1" rx="8"/> <text x="510" y="20" fill="#f44336" font-size="12" font-weight="bold" text-anchor="middle">Large θ (1.0-1.5)</text> <text x="510" y="35" fill="#ccc" font-size="10" text-anchor="middle">Fast, lower accuracy</text> </g> </g> </svg> </div> <h3 id="theta-parameter-trade-off">Theta Parameter Trade-off</h3> <ul> <li><strong>Small θ (0.3-0.5)</strong>: High accuracy, more computations, approaches direct method</li> <li><strong>Large θ (1.0-1.5)</strong>: Fast computation, lower accuracy, more approximation error</li> </ul> <p>Typically θ ≈ 0.5-0.8 provides good balance between speed and accuracy.</p> <h2 id="numerical-integration-leapfrog-method">Numerical Integration: Leapfrog Method</h2> <p>We use the <strong>leapfrog integration</strong> scheme, which is symplectic (energy-conserving) and second-order accurate:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. Kick (half step):    v(t+dt/2) = v(t) + a(t) × dt/2
2. Drift (full step):   x(t+dt) = x(t) + v(t+dt/2) × dt
3. Compute forces:      a(t+dt) = F(x(t+dt))/m
4. Kick (half step):    v(t+dt) = v(t+dt/2) + a(t+dt) × dt/2
</code></pre></div></div> <p>This method preserves energy much better than simple Euler integration, crucial for long-term stability.</p> <h2 id="simulation-setup-rotating-galactic-disc">Simulation Setup: Rotating Galactic Disc</h2> <p>Our initial conditions create a <strong>rotating disc</strong> that mimics galaxy formation:</p> <h3 id="position-distribution">Position Distribution</h3> <p>Particles are distributed with radius $r \propto \sqrt{\text{random}}$ to create realistic density profiles, with small vertical dispersion to form a thin disc.</p> <h3 id="velocity-profile">Velocity Profile</h3> <p>Each particle receives approximately circular velocity plus perturbations:</p> <ul> <li><strong>Circular velocity</strong>: $v_{\text{circ}} = \sqrt{\frac{GM_{\text{enc}}(r)}{r}}$</li> <li><strong>Bar-like shear</strong>: Creates spiral arm instabilities</li> <li><strong>Random velocities</strong>: Adds realistic velocity dispersion</li> </ul> <p>This setup naturally evolves into spiral galaxy structures through gravitational interactions.</p> <h2 id="parameter-guide">Parameter Guide</h2> <h3 id="theta-θ-barnes-hut-accuracy"><strong>Theta (θ): Barnes-Hut Accuracy</strong></h3> <ul> <li><strong>Range</strong>: 0.3 - 1.5</li> <li><strong>Effect</strong>: Controls speed vs. accuracy trade-off</li> <li><strong>Low values</strong> (0.3-0.5): More accurate, slower computation</li> <li><strong>High values</strong> (1.0-1.5): Faster computation, more approximation</li> <li><strong>Recommended</strong>: 0.5-0.8 for good balance</li> </ul> <h3 id="time-step-dt-integration-precision"><strong>Time Step (dt): Integration Precision</strong></h3> <ul> <li><strong>Range</strong>: 0.001 - 0.03</li> <li><strong>Effect</strong>: Smaller steps = better accuracy but slower simulation</li> <li><strong>Too large</strong>: Energy drift, numerical instabilities</li> <li><strong>Too small</strong>: Unnecessarily slow computation</li> <li><strong>Recommended</strong>: 0.01 for stable evolution</li> </ul> <h3 id="softening-ε-gravitational-smoothing"><strong>Softening (ε): Gravitational Smoothing</strong></h3> <ul> <li><strong>Range</strong>: 0.002 - 0.05</li> <li><strong>Purpose</strong>: Prevents singular forces when particles get very close</li> <li><strong>Physics</strong>: Represents finite particle size or quantum effects</li> <li><strong>Effect</strong>: Larger values make forces smoother but less realistic</li> <li><strong>Recommended</strong>: 0.01 for stable dynamics</li> </ul> <h3 id="particles-n-system-size"><strong>Particles (N): System Size</strong></h3> <ul> <li><strong>Range</strong>: 1,000 - 8,000</li> <li><strong>Performance</strong>: <ul> <li>Barnes-Hut scales as O(N log N)</li> <li>Direct method scales as O(N²)</li> </ul> </li> <li><strong>Memory</strong>: Higher N requires more RAM</li> <li><strong>Visual</strong>: More particles show finer structure</li> </ul> <h2 id="what-to-observe">What to Observe</h2> <h3 id="spiral-arm-formation"><strong>Spiral Arm Formation</strong></h3> <p>Watch how the initially smooth disc develops spiral density waves through gravitational instabilities. This mirrors real galaxy evolution.</p> <h3 id="performance-comparison"><strong>Performance Comparison</strong></h3> <p>Switch between Barnes-Hut and Direct methods to see the dramatic performance difference. With 3000+ particles, Barnes-Hut runs ~10-100× faster while maintaining good accuracy.</p> <h3 id="energy-conservation"><strong>Energy Conservation</strong></h3> <p>Monitor the energy drift graph. Good simulations maintain energy to within ~1-5%. Larger drift indicates numerical problems or inadequate time resolution.</p> <p>Total energy: $E = K + U$</p> <p><strong>Kinetic energy</strong>: \(K = \frac{1}{2}\sum_{i=1}^{N} m_i |\vec{v}_i|^2\)</p> <p><strong>Potential energy</strong>: \(U = -\frac{1}{2}\sum_{i=1}^{N}\sum_{j \neq i} \frac{G m_i m_j}{|\vec{r}_{ij}|}\)</p> <p><strong>Energy drift</strong>: \(\Delta E = \frac{E(t) - E(0)}{|E(0)|} \times 100\%\)</p> <p>Good simulations maintain \(\|\Delta E\| &lt; 1\) over hundreds of dynamical times.</p> <h3 id="dynamic-range"><strong>Dynamic Range</strong></h3> <p>Observe both:</p> <ul> <li><strong>Large-scale structure</strong>: Overall spiral pattern evolution</li> <li><strong>Small-scale dynamics</strong>: Individual particle orbits and interactions</li> </ul> <hr/> <h2 id="ready-to-play-god-with-gravity">Ready to Play God with Gravity?</h2> <p>I’ve spent way too many hours tweaking this simulation (my browser history can confirm), and now it’s your turn! The controls below let you experiment with the same physics that shapes galaxies.</p> <p><strong>Here’s what I love doing:</strong></p> <ul> <li>Start with the “Single Disc” and watch spiral arms emerge naturally—it’s mesmerizing</li> <li>Switch to “Galaxy Merger” and witness cosmic destruction in real-time</li> <li>Crank up the particle count and watch Barnes-Hut work its magic (try comparing it with Direct mode… if you dare)</li> <li>Play with the theta parameter—you’ll see the accuracy vs. speed trade-off in action</li> </ul> <p>The energy drift graph at the bottom is my favorite debugging tool. If it stays flat, you’re doing physics right. If it goes crazy, well… that’s when things get interesting.</p> <p>Go ahead, break the universe. I’ve already done it countless times while building this!</p> <style>*{box-sizing:border-box;margin:0;padding:0}body{font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,sans-serif;background:#0a0a0a;color:#e0e0e0}#container{max-width:1200px;margin:0 auto;padding:1rem}#controls{background:#1a1a1a;border:1px solid #333;border-radius:8px;padding:1rem;margin-bottom:1rem;display:flex;flex-wrap:wrap;gap:1rem;align-items:center}.control-group{display:flex;gap:.5rem;align-items:center}button{background:#2a2a2a;color:#e0e0e0;border:1px solid #444;padding:.5rem 1rem;border-radius:4px;cursor:pointer;transition:background .2s}button:hover{background:#3a3a3a}button:active{background:#1a1a1a}select{background:#2a2a2a;color:#e0e0e0;border:1px solid #444;padding:.5rem;border-radius:4px;cursor:pointer}.slider-group{display:flex;align-items:center;gap:.5rem}.slider-group label{font-size:.9rem;min-width:80px;font-weight:bold;color:#fff}.slider-group input[type="range"]{width:120px}.slider-group .value{font-family:monospace;min-width:60px;text-align:right;color:#8cf;font-weight:bold}#status{font-family:monospace;font-size:.9rem;color:#8cf;padding:.5rem;background:#1a1a1a;border-radius:4px;flex:1 1 100%;text-align:center}#viz-container{position:relative;width:100%;aspect-ratio:16/9;background:#000;border:1px solid #333;border-radius:8px;overflow:hidden;margin-bottom:1rem}#viz{width:100%;height:100%}#energy-container{background:#1a1a1a;border:1px solid #333;border-radius:8px;padding:1rem;text-align:center}#energy-container h3{color:#fff;margin-bottom:.5rem;font-size:1.1rem}#energy{border:1px solid #333;background:#0a0a0a;display:block;margin:0 auto;max-width:100%;width:100%;height:120px;max-height:120px}@media(max-width:768px){.control-group{flex:1 1 100%}.slider-group input[type="range"]{width:100px}}.no-webgl{display:flex;align-items:center;justify-content:center;height:100%;font-size:1.2rem;color:#f88;text-align:center;padding:2rem}</style> <div id="container"> <div id="controls"> <div class="control-group"> <button id="play-pause">Pause</button> <button id="reset">Reset</button> <button id="reseed">Re-seed</button> </div> <div class="control-group"> <label for="mode">Mode:</label> <select id="mode"> <option value="barnes-hut">Barnes–Hut (O(N log N))</option> <option value="direct">Direct (O(N²))</option> </select> </div> <div class="control-group"> <label for="seed-type">Setup:</label> <select id="seed-type"> <option value="single">Single Disc</option> <option value="merger">Galaxy Merger</option> </select> </div> <div class="control-group"> <label for="render-mode">Render:</label> <select id="render-mode"> <option value="shader">Custom Shader</option> <option value="halo">Soft Halo</option> </select> </div> <div class="slider-group"> <label for="theta">Theta (θ):</label> <input type="range" id="theta" min="0.3" max="1.5" step="0.05" value="0.8"/> <span class="value" id="theta-value">0.8</span> </div> <div class="slider-group"> <label for="dt">Time Step (dt):</label> <input type="range" id="dt" min="0.001" max="0.03" step="0.001" value="0.01"/> <span class="value" id="dt-value">0.010</span> </div> <div class="slider-group"> <label for="eps">Softening (ε):</label> <input type="range" id="eps" min="0.002" max="0.05" step="0.001" value="0.01"/> <span class="value" id="eps-value">0.010</span> </div> <div class="slider-group"> <label for="npart">Particles (N):</label> <input type="range" id="npart" min="1000" max="8000" step="500" value="3000"/> <span class="value" id="npart-value">3000</span> </div> <div class="slider-group"> <label for="mass">Mass Scale:</label> <input type="range" id="mass" min="0.5" max="5.0" step="0.1" value="1.0"/> <span class="value" id="mass-value">1.0×</span> </div> <div id="status">t=0.00 drift=0.00% mode=BH | step=0ms fps≈0</div> </div> <div id="viz-container"> <div id="viz"></div> </div> <div id="energy-container"> <h3>Energy Drift</h3> <canvas id="energy" width="800" height="120"></canvas> </div> </div> <script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
  }
}
</script> <script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

// Check WebGL support
if (!WebGLRenderingContext) {
  document.getElementById('viz').innerHTML = '<div class="no-webgl">WebGL is not supported in your browser</div>';
  throw new Error('WebGL not supported');
}

// Simulation parameters
let params = {
  theta: 0.8,
  dt: 0.01,
  eps: 0.01,
  N: 3000,
  mass: 1.0,
  mode: 'barnes-hut',
  playing: true,
  seedType: 'single',
  renderMode: 'shader'
};

// Simulation state
let time = 0;
let frameCount = 0;
let lastFrameTime = performance.now();
let stepTime = 0;
let fps = 0;
let E0 = null;
let energyDrift = 0;

// Arrays for physics
let x, y, z, vx, vy, vz, ax, ay, az, m;
let positions, speeds;

// Energy tracking
const energyHistory = new Float32Array(800);
let energyIndex = 0;
let energyCount = 0;

// Three.js objects
let scene, camera, renderer, controls, points, geometry;

// Octree for Barnes-Hut
class OctreeNode {
  constructor(cx, cy, cz, hs) {
    this.cx = cx;
    this.cy = cy;
    this.cz = cz;
    this.hs = hs;
    this.m = 0;
    this.comx = 0;
    this.comy = 0;
    this.comz = 0;
    this.body = -1;
    this.children = null;
  }
}

// Initialize arrays
function initArrays(n) {
  x = new Float32Array(n);
  y = new Float32Array(n);
  z = new Float32Array(n);
  vx = new Float32Array(n);
  vy = new Float32Array(n);
  vz = new Float32Array(n);
  ax = new Float32Array(n);
  ay = new Float32Array(n);
  az = new Float32Array(n);
  m = new Float32Array(n);
  positions = new Float32Array(n * 3);
  speeds = new Float32Array(n);
}

// Seed the system - rotating disc or galaxy merger
function seedSystem() {
  if (params.seedType === 'single') {
    seedSingleDisc();
  } else {
    seedGalaxyMerger();
  }
}

// Seed single rotating disc
function seedSingleDisc() {
  const n = params.N;
  const Rmax = 2.2;
  const totalMass = 1.0 * params.mass;
  const mi = totalMass / n;
  
  for (let i = 0; i < n; i++) {
    // Biased radial distribution
    const r = Rmax * Math.sqrt(Math.random());
    const phi = Math.random() * 2 * Math.PI;
    
    // Position
    x[i] = r * Math.cos(phi);
    y[i] = r * Math.sin(phi);
    z[i] = gaussianRandom() * 0.06;
    
    // Mass
    m[i] = mi;
    
    // Velocity - approximate circular with noise
    const Menc = totalMass * (r / Rmax) * (r / Rmax); // Simplified enclosed mass
    const vcirc = Math.sqrt(Menc / r);
    
    // Add slight bar-like shear for spiral arms
    const shear = 0.1 * Math.sin(2 * phi);
    
    vx[i] = -vcirc * Math.sin(phi) * (1 + shear) + gaussianRandom() * 0.01;
    vy[i] = vcirc * Math.cos(phi) * (1 + shear) + gaussianRandom() * 0.01;
    vz[i] = gaussianRandom() * 0.01;
  }
}

// Seed galaxy merger - two offset discs with different spins
function seedGalaxyMerger() {
  const n = params.N;
  const n1 = Math.floor(n * 0.6); // First galaxy gets 60% of particles
  const n2 = n - n1; // Second galaxy gets 40%
  
  const Rmax1 = 1.8;
  const Rmax2 = 1.4;
  const totalMass = 1.0 * params.mass;
  
  // Galaxy 1 - larger, positioned at (-1.5, 0, 0), counter-clockwise rotation
  for (let i = 0; i < n1; i++) {
    const r = Rmax1 * Math.sqrt(Math.random());
    const phi = Math.random() * 2 * Math.PI;
    
    // Position - offset left
    x[i] = -1.5 + r * Math.cos(phi);
    y[i] = r * Math.sin(phi);
    z[i] = gaussianRandom() * 0.05;
    
    // Mass
    m[i] = (totalMass * 0.6) / n1;
    
    // Velocity - counter-clockwise
    const Menc = totalMass * 0.6 * (r / Rmax1) * (r / Rmax1);
    const vcirc = Math.sqrt(Menc / Math.max(r, 0.1));
    
    vx[i] = -vcirc * Math.sin(phi) + gaussianRandom() * 0.02 + 0.3; // Approach velocity
    vy[i] = vcirc * Math.cos(phi) + gaussianRandom() * 0.02;
    vz[i] = gaussianRandom() * 0.01;
  }
  
  // Galaxy 2 - smaller, positioned at (1.5, 0, 0), clockwise rotation
  for (let i = n1; i < n; i++) {
    const r = Rmax2 * Math.sqrt(Math.random());
    const phi = Math.random() * 2 * Math.PI;
    
    // Position - offset right
    x[i] = 1.5 + r * Math.cos(phi);
    y[i] = r * Math.sin(phi);
    z[i] = gaussianRandom() * 0.04;
    
    // Mass
    m[i] = (totalMass * 0.4) / n2;
    
    // Velocity - clockwise (opposite rotation)
    const Menc = totalMass * 0.4 * (r / Rmax2) * (r / Rmax2);
    const vcirc = Math.sqrt(Menc / Math.max(r, 0.1));
    
    vx[i] = vcirc * Math.sin(phi) + gaussianRandom() * 0.02 - 0.3; // Approach velocity
    vy[i] = -vcirc * Math.cos(phi) + gaussianRandom() * 0.02;
    vz[i] = gaussianRandom() * 0.01;
  }
}

// Gaussian random number generator
function gaussianRandom() {
  let u = 0, v = 0;
  while (u === 0) u = Math.random();
  while (v === 0) v = Math.random();
  return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
}

// Build octree
function buildOctree() {
  const n = params.N;
  
  // Find bounds
  let minX = x[0], maxX = x[0];
  let minY = y[0], maxY = y[0];
  let minZ = z[0], maxZ = z[0];
  
  for (let i = 1; i < n; i++) {
    minX = Math.min(minX, x[i]);
    maxX = Math.max(maxX, x[i]);
    minY = Math.min(minY, y[i]);
    maxY = Math.max(maxY, y[i]);
    minZ = Math.min(minZ, z[i]);
    maxZ = Math.max(maxZ, z[i]);
  }
  
  // Create cubic root with padding
  const cx = (minX + maxX) * 0.5;
  const cy = (minY + maxY) * 0.5;
  const cz = (minZ + maxZ) * 0.5;
  const hs = Math.max(maxX - minX, maxY - minY, maxZ - minZ) * 0.5 * 1.1;
  
  const root = new OctreeNode(cx, cy, cz, hs);
  
  // Insert bodies
  for (let i = 0; i < n; i++) {
    insertBody(root, i);
  }
  
  return root;
}

// Insert body into octree
function insertBody(node, i) {
  // If node is empty, place body here
  if (node.body === -1 && node.children === null) {
    node.body = i;
    node.m = m[i];
    node.comx = x[i];
    node.comy = y[i];
    node.comz = z[i];
    return;
  }
  
  // If node has a body, need to subdivide
  if (node.body !== -1) {
    const oldBody = node.body;
    node.body = -1;
    
    // Create children
    node.children = new Array(8);
    for (let j = 0; j < 8; j++) {
      const hs2 = node.hs * 0.5;
      const cx2 = node.cx + ((j & 1) ? hs2 : -hs2);
      const cy2 = node.cy + ((j & 2) ? hs2 : -hs2);
      const cz2 = node.cz + ((j & 4) ? hs2 : -hs2);
      node.children[j] = new OctreeNode(cx2, cy2, cz2, hs2);
    }
    
    // Reinsert old body
    insertBody(node, oldBody);
  }
  
  // Insert new body into appropriate child
  const idx = ((x[i] > node.cx) ? 1 : 0) |
               ((y[i] > node.cy) ? 2 : 0) |
               ((z[i] > node.cz) ? 4 : 0);
  insertBody(node.children[idx], i);
  
  // Update mass and center of mass
  const oldMass = node.m;
  node.m += m[i];
  node.comx = (node.comx * oldMass + x[i] * m[i]) / node.m;
  node.comy = (node.comy * oldMass + y[i] * m[i]) / node.m;
  node.comz = (node.comz * oldMass + z[i] * m[i]) / node.m;
}

// Compute forces using Barnes-Hut
function computeForcesBH() {
  const n = params.N;
  const root = buildOctree();
  const theta = params.theta;
  const eps2 = params.eps * params.eps;
  
  // Clear accelerations
  ax.fill(0);
  ay.fill(0);
  az.fill(0);
  
  // For each body, traverse tree
  for (let i = 0; i < n; i++) {
    const stack = [root];
    
    while (stack.length > 0) {
      const node = stack.pop();
      
      // Skip empty nodes
      if (node.m === 0) continue;
      
      // If leaf with self, skip
      if (node.body === i) continue;
      
      // Compute distance to COM
      const dx = node.comx - x[i];
      const dy = node.comy - y[i];
      const dz = node.comz - z[i];
      const dist2 = dx * dx + dy * dy + dz * dz + eps2;
      const dist = Math.sqrt(dist2);
      
      // Check multipole acceptance criterion
      if (node.children === null || (2 * node.hs) / dist < theta) {
        // Treat as single mass
        const f = node.m / (dist2 * dist);
        ax[i] += f * dx;
        ay[i] += f * dy;
        az[i] += f * dz;
      } else {
        // Descend into children
        for (let j = 0; j < 8; j++) {
          if (node.children[j].m > 0) {
            stack.push(node.children[j]);
          }
        }
      }
    }
  }
}

// Compute forces using direct summation
function computeForcesDirect() {
  const n = params.N;
  const eps2 = params.eps * params.eps;
  
  // Clear accelerations
  ax.fill(0);
  ay.fill(0);
  az.fill(0);
  
  // O(N²) pairwise forces
  for (let i = 0; i < n; i++) {
    for (let j = 0; j < n; j++) {
      if (i === j) continue;
      
      const dx = x[j] - x[i];
      const dy = y[j] - y[i];
      const dz = z[j] - z[i];
      const dist2 = dx * dx + dy * dy + dz * dz + eps2;
      const dist = Math.sqrt(dist2);
      const f = m[j] / (dist2 * dist);
      
      ax[i] += f * dx;
      ay[i] += f * dy;
      az[i] += f * dz;
    }
  }
}

// Compute potential energy using tree
function computePotential() {
  const n = params.N;
  const root = buildOctree();
  const theta = params.theta;
  const eps = params.eps;
  let U = 0;
  
  for (let i = 0; i < n; i++) {
    const stack = [root];
    
    while (stack.length > 0) {
      const node = stack.pop();
      
      if (node.m === 0) continue;
      if (node.body === i) continue;
      
      const dx = node.comx - x[i];
      const dy = node.comy - y[i];
      const dz = node.comz - z[i];
      const dist = Math.sqrt(dx * dx + dy * dy + dz * dz + eps * eps);
      
      if (node.children === null || (2 * node.hs) / dist < theta) {
        U -= m[i] * node.m / dist;
      } else {
        for (let j = 0; j < 8; j++) {
          if (node.children[j].m > 0) {
            stack.push(node.children[j]);
          }
        }
      }
    }
  }
  
  return U * 0.5; // Avoid double counting
}

// Compute total energy
function computeEnergy() {
  const n = params.N;
  
  // Kinetic energy
  let K = 0;
  for (let i = 0; i < n; i++) {
    const v2 = vx[i] * vx[i] + vy[i] * vy[i] + vz[i] * vz[i];
    K += 0.5 * m[i] * v2;
  }
  
  // Potential energy
  const U = computePotential();
  
  return K + U;
}


// Leapfrog integration step
function step() {
  const n = params.N;
  const dt = params.dt;
  
  const t0 = performance.now();
  
  // Kick (half step)
  for (let i = 0; i < n; i++) {
    vx[i] += 0.5 * dt * ax[i];
    vy[i] += 0.5 * dt * ay[i];
    vz[i] += 0.5 * dt * az[i];
  }
  
  // Drift
  for (let i = 0; i < n; i++) {
    x[i] += dt * vx[i];
    y[i] += dt * vy[i];
    z[i] += dt * vz[i];
  }
  
  // Recompute accelerations
  if (params.mode === 'barnes-hut') {
    computeForcesBH();
  } else {
    computeForcesDirect();
  }
  
  // Kick (half step)
  for (let i = 0; i < n; i++) {
    vx[i] += 0.5 * dt * ax[i];
    vy[i] += 0.5 * dt * ay[i];
    vz[i] += 0.5 * dt * az[i];
  }
  
  stepTime = performance.now() - t0;
  time += dt;
  
  // Update energy drift
  const E = computeEnergy();
  if (E0 === null) E0 = E;
  energyDrift = (E - E0) / Math.abs(E0);
  
  // Store in history
  energyHistory[energyIndex] = energyDrift;
  energyIndex = (energyIndex + 1) % energyHistory.length;
  if (energyCount < energyHistory.length) energyCount++;
}

// Update geometry buffers
function updateGeometry() {
  const n = params.N;
  
  for (let i = 0; i < n; i++) {
    positions[i * 3] = x[i];
    positions[i * 3 + 1] = y[i];
    positions[i * 3 + 2] = z[i];
    
    const v = Math.sqrt(vx[i] * vx[i] + vy[i] * vy[i] + vz[i] * vz[i]);
    speeds[i] = v;
  }
  
  geometry.attributes.position.needsUpdate = true;
  geometry.attributes.speed.needsUpdate = true;
}

// Draw energy drift graph
function drawEnergyGraph() {
  const canvas = document.getElementById('energy');
  const ctx = canvas.getContext('2d');
  const width = canvas.width;
  const height = canvas.height;
  
  // Clear
  ctx.fillStyle = '#0a0a0a';
  ctx.fillRect(0, 0, width, height);
  
  if (energyCount < 2) return;
  
  // Find min/max for adaptive scaling
  let minDrift = Infinity, maxDrift = -Infinity;
  for (let i = 0; i < energyCount; i++) {
    const idx = (energyIndex - energyCount + i + energyHistory.length) % energyHistory.length;
    const drift = energyHistory[idx];
    minDrift = Math.min(minDrift, drift);
    maxDrift = Math.max(maxDrift, drift);
  }
  
  // Ensure reasonable range
  const range = Math.max(Math.abs(minDrift), Math.abs(maxDrift), 0.001);
  const yScale = (height * 0.4) / range;
  
  // Draw axes
  ctx.strokeStyle = '#333';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(0, height / 2);
  ctx.lineTo(width, height / 2);
  ctx.stroke();
  
  // Draw grid lines
  ctx.strokeStyle = '#222';
  ctx.lineWidth = 0.5;
  const gridLines = 4;
  for (let i = 1; i <= gridLines; i++) {
    const y1 = height / 2 - (i / gridLines) * height * 0.4;
    const y2 = height / 2 + (i / gridLines) * height * 0.4;
    ctx.beginPath();
    ctx.moveTo(0, y1);
    ctx.lineTo(width, y1);
    ctx.moveTo(0, y2);
    ctx.lineTo(width, y2);
    ctx.stroke();
  }
  
  // Draw drift curve
  ctx.strokeStyle = '#8cf';
  ctx.lineWidth = 2;
  ctx.beginPath();
  
  for (let i = 0; i < energyCount; i++) {
    const idx = (energyIndex - energyCount + i + energyHistory.length) % energyHistory.length;
    const xPos = (i / Math.max(energyCount - 1, 1)) * width;
    const yPos = height / 2 - energyHistory[idx] * yScale;
    
    if (i === 0) {
      ctx.moveTo(xPos, yPos);
    } else {
      ctx.lineTo(xPos, yPos);
    }
  }
  ctx.stroke();
  
  // Draw labels with better positioning
  ctx.fillStyle = '#ccc';
  ctx.font = '12px monospace';
  ctx.textAlign = 'left';
  ctx.fillText('0%', 5, height / 2 - 5);
  
  ctx.textAlign = 'right';
  ctx.fillText(`${(energyDrift * 100).toFixed(3)}%`, width - 5, 15);
  
  // Draw scale indicators
  ctx.fillStyle = '#888';
  ctx.font = '10px monospace';
  ctx.textAlign = 'right';
  ctx.fillText(`+${(range * 100).toFixed(2)}%`, width - 5, 25);
  ctx.fillText(`-${(range * 100).toFixed(2)}%`, width - 5, height - 5);
}

// Update status display
function updateStatus() {
  frameCount++;
  const now = performance.now();
  if (now - lastFrameTime > 1000) {
    fps = Math.round(frameCount * 1000 / (now - lastFrameTime));
    frameCount = 0;
    lastFrameTime = now;
  }
  
  const mode = params.mode === 'barnes-hut' ? 'BH' : 'Direct';
  const status = `t=${time.toFixed(2)} drift=${(energyDrift * 100).toFixed(2)}% mode=${mode} | step=${stepTime.toFixed(1)}ms fps≈${fps}`;
  document.getElementById('status').textContent = status;
}

// Create halo texture for soft particles
function createHaloTexture() {
  const canvas = document.createElement('canvas');
  canvas.width = 64;
  canvas.height = 64;
  const ctx = canvas.getContext('2d');
  
  const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
  gradient.addColorStop(0, 'rgba(255,255,255,1)');
  gradient.addColorStop(0.3, 'rgba(255,255,255,0.8)');
  gradient.addColorStop(0.7, 'rgba(255,255,255,0.2)');
  gradient.addColorStop(1, 'rgba(255,255,255,0)');
  
  ctx.fillStyle = gradient;
  ctx.fillRect(0, 0, 64, 64);
  
  return new THREE.CanvasTexture(canvas);
}

// Initialize Three.js
function initThree() {
  const container = document.getElementById('viz');
  
  // Scene
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x000000);
  
  // Camera
  camera = new THREE.PerspectiveCamera(60, container.clientWidth / container.clientHeight, 0.1, 100);
  camera.position.set(0, 5, 10);
  camera.lookAt(0, 0, 0);
  
  // Renderer
  renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.setSize(container.clientWidth, container.clientHeight);
  container.appendChild(renderer.domElement);
  
  // Controls
  controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.dampingFactor = 0.05;
  
  // Initialize arrays before creating geometry
  if (!positions || !speeds) {
    initArrays(params.N);
    seedSystem();
  }
  
  // Create points geometry with initialized arrays
  geometry = new THREE.BufferGeometry();
  geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
  geometry.setAttribute('speed', new THREE.BufferAttribute(speeds, 1));
  
  // Create materials for both render modes
  createPointsMaterials();
  
  // Mark attributes as dynamic
  geometry.attributes.position.setUsage(THREE.DynamicDrawUsage);
  geometry.attributes.speed.setUsage(THREE.DynamicDrawUsage);
  
  // Handle resize
  const resizeObserver = new ResizeObserver(() => {
    camera.aspect = container.clientWidth / container.clientHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(container.clientWidth, container.clientHeight);
  });
  resizeObserver.observe(container);
}

// Create materials for different render modes
function createPointsMaterials() {
  // Custom shader material
  const vertexShader = `
    attribute float speed;
    varying float vSpeed;
    uniform float uSize;
    uniform float uDevicePixelRatio;
    
    void main() {
      vSpeed = speed;
      vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
      gl_Position = projectionMatrix * mvPosition;
      gl_PointSize = uSize * uDevicePixelRatio * (1.0 / -mvPosition.z);
    }
  `;
  
  const fragmentShader = `
    varying float vSpeed;
    
    void main() {
      vec2 xy = gl_PointCoord.xy - vec2(0.5);
      float r = length(xy);
      if (r > 0.5) discard;
      
      float intensity = 1.0 - 2.0 * r;
      intensity = intensity * intensity;
      
      // Color by speed: cool -> white -> warm
      float t = clamp(vSpeed * 2.0, 0.0, 1.0);
      vec3 cool = vec3(0.2, 0.5, 1.0);
      vec3 white = vec3(1.0, 1.0, 1.0);
      vec3 warm = vec3(1.0, 0.8, 0.3);
      
      vec3 color;
      if (t < 0.5) {
        color = mix(cool, white, t * 2.0);
      } else {
        color = mix(white, warm, (t - 0.5) * 2.0);
      }
      
      gl_FragColor = vec4(color * intensity, intensity);
    }
  `;
  
  const shaderMaterial = new THREE.ShaderMaterial({
    uniforms: {
      uSize: { value: 20.0 },
      uDevicePixelRatio: { value: Math.min(window.devicePixelRatio, 2) }
    },
    vertexShader,
    fragmentShader,
    blending: THREE.AdditiveBlending,
    depthWrite: false,
    transparent: true
  });
  
  // Enhanced halo shader with texture and speed-based coloring
  const haloVertexShader = `
    attribute float speed;
    varying float vSpeed;
    uniform float uSize;
    uniform float uDevicePixelRatio;
    
    void main() {
      vSpeed = speed;
      vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
      gl_Position = projectionMatrix * mvPosition;
      gl_PointSize = uSize * 1.5 * uDevicePixelRatio * (1.0 / -mvPosition.z);
    }
  `;
  
  const haloFragmentShader = `
    varying float vSpeed;
    uniform sampler2D uTexture;
    
    void main() {
      vec4 texColor = texture2D(uTexture, gl_PointCoord);
      
      // Color by speed with enhanced vibrancy
      float t = clamp(vSpeed * 1.5, 0.0, 1.0);
      vec3 cool = vec3(0.3, 0.7, 1.0);
      vec3 white = vec3(1.0, 1.0, 1.0);
      vec3 warm = vec3(1.0, 0.6, 0.2);
      
      vec3 color;
      if (t < 0.5) {
        color = mix(cool, white, t * 2.0);
      } else {
        color = mix(white, warm, (t - 0.5) * 2.0);
      }
      
      // Enhanced glow effect
      float glow = texColor.a * (0.8 + 0.4 * sin(vSpeed * 10.0));
      gl_FragColor = vec4(color * glow, glow * 0.7);
    }
  `;
  
  const haloTexture = createHaloTexture();
  const haloMaterial = new THREE.ShaderMaterial({
    uniforms: {
      uSize: { value: 25.0 },
      uDevicePixelRatio: { value: Math.min(window.devicePixelRatio, 2) },
      uTexture: { value: haloTexture }
    },
    vertexShader: haloVertexShader,
    fragmentShader: haloFragmentShader,
    blending: THREE.AdditiveBlending,
    depthWrite: false,
    transparent: true
  });
  
  // Create points with current material
  const currentMaterial = params.renderMode === 'halo' ? haloMaterial : shaderMaterial;
  points = new THREE.Points(geometry, currentMaterial);
  scene.add(points);
  
  // Store materials for switching
  points.userData = {
    shaderMaterial,
    haloMaterial
  };
}

// Switch render mode
function switchRenderMode() {
  if (!points || !points.userData) return;
  
  const newMaterial = params.renderMode === 'halo'
    ? points.userData.haloMaterial
    : points.userData.shaderMaterial;
    
  points.material = newMaterial;
}

// Initialize simulation
function init() {
  // Only reinitialize if needed (arrays already initialized in initThree)
  if (!x || x.length !== params.N) {
    initArrays(params.N);
    seedSystem();
  }
  
  // Initial force computation
  if (params.mode === 'barnes-hut') {
    computeForcesBH();
  } else {
    computeForcesDirect();
  }
  
  // Reset energy baseline
  E0 = null;
  time = 0;
  energyCount = 0;
  energyIndex = 0;
  energyHistory.fill(0);
}

// Reset simulation
function reset() {
  seedSystem();
  init();
  updateGeometry();
}

// Animation loop
function animate() {
  requestAnimationFrame(animate);
  
  if (params.playing) {
    step();
    updateGeometry();
    updateStatus();
    drawEnergyGraph();
  }
  
  controls.update();
  renderer.render(scene, camera);
}

// UI event handlers
document.getElementById('play-pause').addEventListener('click', () => {
  params.playing = !params.playing;
  document.getElementById('play-pause').textContent = params.playing ? 'Pause' : 'Play';
});

document.getElementById('reset').addEventListener('click', reset);

document.getElementById('reseed').addEventListener('click', () => {
  seedSystem();
  reset();
});

document.getElementById('mode').addEventListener('change', (e) => {
  params.mode = e.target.value;
});

document.getElementById('theta').addEventListener('input', (e) => {
  params.theta = parseFloat(e.target.value);
  document.getElementById('theta-value').textContent = params.theta.toFixed(1);
});

document.getElementById('dt').addEventListener('input', (e) => {
  params.dt = parseFloat(e.target.value);
  document.getElementById('dt-value').textContent = params.dt.toFixed(3);
});

document.getElementById('eps').addEventListener('input', (e) => {
  params.eps = parseFloat(e.target.value);
  document.getElementById('eps-value').textContent = params.eps.toFixed(3);
});

document.getElementById('npart').addEventListener('input', (e) => {
  const newN = parseInt(e.target.value);
  document.getElementById('npart-value').textContent = newN;
  
  if (newN !== params.N) {
    params.N = newN;
    initArrays(params.N);
    
    // Update geometry with new size
    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3).setUsage(THREE.DynamicDrawUsage));
    geometry.setAttribute('speed', new THREE.BufferAttribute(speeds, 1).setUsage(THREE.DynamicDrawUsage));
    
    reset();
  }
});

document.getElementById('mass').addEventListener('input', (e) => {
  params.mass = parseFloat(e.target.value);
  document.getElementById('mass-value').textContent = params.mass.toFixed(1) + '×';
  console.log('Mass parameter changed to:', params.mass);
  reset(); // Reset simulation with new mass scaling
});

// New stretch goal event handlers
document.getElementById('seed-type').addEventListener('change', (e) => {
  params.seedType = e.target.value;
  reset(); // Reseed with new configuration
});

document.getElementById('render-mode').addEventListener('change', (e) => {
  params.renderMode = e.target.value;
  switchRenderMode();
});

// Initialize display values
document.getElementById('mass-value').textContent = params.mass.toFixed(1) + '×';

// Start
initThree();
init();
updateGeometry();  // Populate geometry with initial particle positions
animate();
</script>]]></content><author><name></name></author><category term="physics"/><category term="simulation"/><category term="n-body"/><category term="barnes-hut"/><category term="galaxy"/><category term="gravitational"/><category term="astrophysics"/><summary type="html"><![CDATA[Explore the dynamics of gravitational systems with this interactive 3D simulation featuring both Barnes-Hut (O(N log N)) and direct-sum (O(N²)) methods.]]></summary></entry><entry><title type="html">Quaternions, SO(3), and Gimbal Lock — An Interactive Intuition</title><link href="https://saeed1262.github.io/blog/2024/quaternion/" rel="alternate" type="text/html" title="Quaternions, SO(3), and Gimbal Lock — An Interactive Intuition"/><published>2024-10-24T00:00:00+00:00</published><updated>2024-10-24T00:00:00+00:00</updated><id>https://saeed1262.github.io/blog/2024/quaternion</id><content type="html" xml:base="https://saeed1262.github.io/blog/2024/quaternion/"><![CDATA[<h1 id="quaternion-based-3d-rotation-from-theory-to-practice">Quaternion-Based 3D Rotation: From Theory to Practice</h1> <p><strong>Prerequisites</strong>: Basic linear algebra (vectors, matrices), trigonometry, and familiarity with 3D coordinate systems.</p> <p>3D rotations are everywhere in computer graphics, robotics, and game development. Whether you’re rotating a character in Unity, controlling a drone, or animating a 3D model, you need a robust way to represent and manipulate rotations. This post explores why the industry has largely moved from Euler angles to quaternions, combining mathematical rigor with practical examples.</p> <h2 id="the-problem-why-rotations-are-tricky">The Problem: Why Rotations Are Tricky</h2> <p>Representing 3D rotations might seem straightforward - just use three angles for yaw, pitch, and roll, right? Unfortunately, this intuitive approach runs into serious mathematical and practical problems that have plagued developers for decades.</p> <h3 id="a-quick-refresher-what-are-rotations">A Quick Refresher: What Are Rotations?</h3> <p>In 3D space, rotations form what mathematicians call the <strong>Special Orthogonal Group SO(3)</strong>. Don’t let the fancy name intimidate you - this simply means:</p> <ul> <li><strong>Special</strong>: Determinant = 1 (proper rotations, no reflections)</li> <li><strong>Orthogonal</strong>: Preserve distances and angles</li> <li><strong>Group</strong>: You can combine rotations, and the result is still a rotation</li> </ul> <p>Think of SO(3) as the set of all possible 3D orientations an object can have. A cube can be rotated in countless ways, but it’s still the same cube - just oriented differently.</p> <h2 id="the-euler-angle-problem-gimbal-lock-in-action">The Euler Angle Problem: Gimbal Lock in Action</h2> <p>Before diving into quaternions, let’s understand why Euler angles cause problems. Euler angles represent rotations using three sequential rotations around different axes - typically yaw (Z), pitch (Y), and roll (X).</p> <h3 id="real-world-example-aircraft-control">Real-World Example: Aircraft Control</h3> <p>Imagine you’re programming a flight simulator or drone controller:</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Typical Euler angle representation</span>
<span class="kd">class</span> <span class="nc">EulerRotation</span> <span class="p">{</span>
    <span class="nf">constructor</span><span class="p">(</span><span class="nx">yaw</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">pitch</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">roll</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">yaw</span> <span class="o">=</span> <span class="nx">yaw</span><span class="p">;</span>    <span class="c1">// Rotation around Z-axis (heading)</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">pitch</span> <span class="o">=</span> <span class="nx">pitch</span><span class="p">;</span> <span class="c1">// Rotation around Y-axis (nose up/down)</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">roll</span> <span class="o">=</span> <span class="nx">roll</span><span class="p">;</span>   <span class="c1">// Rotation around X-axis (bank left/right)</span>
    <span class="p">}</span>
    
    <span class="c1">// This seems simple... but problems lurk beneath</span>
    <span class="nf">toRotationMatrix</span><span class="p">()</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">cy</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">cos</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">yaw</span><span class="p">),</span> <span class="nx">sy</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">sin</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">yaw</span><span class="p">);</span>
        <span class="kd">const</span> <span class="nx">cp</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">cos</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">pitch</span><span class="p">),</span> <span class="nx">sp</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">sin</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">pitch</span><span class="p">);</span>
        <span class="kd">const</span> <span class="nx">cr</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">cos</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">roll</span><span class="p">),</span> <span class="nx">sr</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">sin</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">roll</span><span class="p">);</span>
        
        <span class="c1">// Combined rotation: R = R_z(yaw) * R_y(pitch) * R_x(roll)</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="p">[</span><span class="nx">cy</span><span class="o">*</span><span class="nx">cp</span><span class="p">,</span> <span class="nx">cy</span><span class="o">*</span><span class="nx">sp</span><span class="o">*</span><span class="nx">sr</span> <span class="o">-</span> <span class="nx">sy</span><span class="o">*</span><span class="nx">cr</span><span class="p">,</span> <span class="nx">cy</span><span class="o">*</span><span class="nx">sp</span><span class="o">*</span><span class="nx">cr</span> <span class="o">+</span> <span class="nx">sy</span><span class="o">*</span><span class="nx">sr</span><span class="p">],</span>
            <span class="p">[</span><span class="nx">sy</span><span class="o">*</span><span class="nx">cp</span><span class="p">,</span> <span class="nx">sy</span><span class="o">*</span><span class="nx">sp</span><span class="o">*</span><span class="nx">sr</span> <span class="o">+</span> <span class="nx">cy</span><span class="o">*</span><span class="nx">cr</span><span class="p">,</span> <span class="nx">sy</span><span class="o">*</span><span class="nx">sp</span><span class="o">*</span><span class="nx">cr</span> <span class="o">-</span> <span class="nx">cy</span><span class="o">*</span><span class="nx">sr</span><span class="p">],</span>
            <span class="p">[</span><span class="o">-</span><span class="nx">sp</span><span class="p">,</span>   <span class="nx">cp</span><span class="o">*</span><span class="nx">sr</span><span class="p">,</span>            <span class="nx">cp</span><span class="o">*</span><span class="nx">cr</span>           <span class="p">]</span>
        <span class="p">];</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>This looks clean and intuitive. The problem emerges when the pitch approaches ±90°.</p> <h3 id="the-gimbal-lock-problem-explained">The Gimbal Lock Problem Explained</h3> <p><strong>Gimbal lock</strong> occurs when two rotation axes become parallel, effectively losing one degree of freedom. Here’s what happens:</p> <ol> <li><strong>Normal operation</strong>: All three axes are independent</li> <li><strong>Approaching ±90° pitch</strong>: The yaw and roll axes start to align</li> <li><strong>At ±90° pitch</strong>: Yaw and roll do the same thing - you lose control!</li> </ol> <p>This isn’t a coding bug - it’s a fundamental mathematical limitation called a <strong>singularity</strong>.</p> <h3 id="why-this-matters-practical-consequences">Why This Matters: Practical Consequences</h3> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Example: Smooth rotation that breaks near gimbal lock</span>
<span class="kd">function</span> <span class="nf">interpolateEulerAngles</span><span class="p">(</span><span class="nx">start</span><span class="p">,</span> <span class="nx">end</span><span class="p">,</span> <span class="nx">t</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Linear interpolation - seems reasonable?</span>
    <span class="k">return</span> <span class="p">{</span>
        <span class="na">yaw</span><span class="p">:</span> <span class="nx">start</span><span class="p">.</span><span class="nx">yaw</span> <span class="o">+</span> <span class="p">(</span><span class="nx">end</span><span class="p">.</span><span class="nx">yaw</span> <span class="o">-</span> <span class="nx">start</span><span class="p">.</span><span class="nx">yaw</span><span class="p">)</span> <span class="o">*</span> <span class="nx">t</span><span class="p">,</span>
        <span class="na">pitch</span><span class="p">:</span> <span class="nx">start</span><span class="p">.</span><span class="nx">pitch</span> <span class="o">+</span> <span class="p">(</span><span class="nx">end</span><span class="p">.</span><span class="nx">pitch</span> <span class="o">-</span> <span class="nx">start</span><span class="p">.</span><span class="nx">pitch</span><span class="p">)</span> <span class="o">*</span> <span class="nx">t</span><span class="p">,</span>
        <span class="na">roll</span><span class="p">:</span> <span class="nx">start</span><span class="p">.</span><span class="nx">roll</span> <span class="o">+</span> <span class="p">(</span><span class="nx">end</span><span class="p">.</span><span class="nx">roll</span> <span class="o">-</span> <span class="nx">start</span><span class="p">.</span><span class="nx">roll</span><span class="p">)</span> <span class="o">*</span> <span class="nx">t</span>
    <span class="p">};</span>
<span class="p">}</span>

<span class="c1">// This causes problems:</span>
<span class="kd">const</span> <span class="k">from</span> <span class="o">=</span> <span class="p">{</span><span class="na">yaw</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="na">pitch</span><span class="p">:</span> <span class="mi">89</span><span class="p">,</span> <span class="na">roll</span><span class="p">:</span> <span class="mi">0</span><span class="p">};</span>      <span class="c1">// Almost at singularity</span>
<span class="kd">const</span> <span class="nx">to</span> <span class="o">=</span> <span class="p">{</span><span class="na">yaw</span><span class="p">:</span> <span class="mi">180</span><span class="p">,</span> <span class="na">pitch</span><span class="p">:</span> <span class="mi">89</span><span class="p">,</span> <span class="na">roll</span><span class="p">:</span> <span class="mi">0</span><span class="p">};</span>      <span class="c1">// Still near singularity</span>
<span class="c1">// Result: Violent spinning as yaw "wraps around" at singularity!</span>
</code></pre></div></div> <p><strong>Gimbal Lock Demonstration</strong>: In the interactive visualization below, observe how the Euler angle system breaks down. When pitch approaches ±90°, the yaw and roll axes become parallel, causing a loss of one degree of freedom.</p> <p><strong>Try this</strong>: Set pitch to ±90° and notice how yaw and roll controls do the same thing!</p> <div class="panel"> <h3>Gimbal Rig</h3> <div class="canvas-container"> <canvas id="gimbalCanvas"></canvas> </div> <div class="controls"> <div class="control-group"> <label><span style="color: #64ffda;">Yaw (Z-axis)</span> <span class="value-display" id="yawValue">0°</span></label> <input type="range" class="slider" id="yawSlider" min="-180" max="180" value="0" step="1"/> </div> <div class="control-group"> <label><span style="color: #4caf50;">Pitch (Y-axis)</span> <span class="value-display" id="pitchValue">0°</span></label> <input type="range" class="slider" id="pitchSlider" min="-90" max="90" value="0" step="1"/> </div> <div class="control-group"> <label><span style="color: #ff9800;">Roll (X-axis)</span> <span class="value-display" id="rollValue">0°</span></label> <input type="range" class="slider" id="rollSlider" min="-180" max="180" value="0" step="1"/> </div> </div> <div class="warning" id="gimbalWarning"> GIMBAL LOCK! Yaw and Roll axes are aligned - you've lost a degree of freedom! </div> <div class="info-box"> <strong>Try this:</strong> Set pitch to ±90° and notice how yaw and roll controls do the same thing. This is gimbal lock - the curse of Euler angles! </div> </div> <p>The degeneracy occurs because Euler angles represent rotations as a composition of rotations about fixed axes: R = R_z(ψ)R_y(θ)R_x(φ), where the middle rotation R_y(θ) at θ = ±π/2 aligns the first and third rotation axes.</p> <div class="panel"> <h3>Quaternion Sphere (S³)</h3> <div class="canvas-container"> <canvas id="quaternionCanvas"></canvas> </div> <div class="quaternion-display"> <div class="quat-component"> <div class="label">x</div> <div class="value" id="quatX">0.000</div> </div> <div class="quat-component"> <div class="label">y</div> <div class="value" id="quatY">0.000</div> </div> <div class="quat-component"> <div class="label">z</div> <div class="value" id="quatZ">0.000</div> </div> <div class="quat-component"> <div class="label">w</div> <div class="value" id="quatW">1.000</div> </div> </div> <div class="controls"> <div class="control-group"> <label><span style="color: #64ffda;">Sphere Yaw</span> <span class="value-display" id="sphereYawValue">0°</span></label> <input type="range" class="slider" id="sphereYawSlider" min="-180" max="180" value="0" step="1"/> </div> <div class="control-group"> <label><span style="color: #4caf50;">Sphere Pitch</span> <span class="value-display" id="spherePitchValue">0°</span></label> <input type="range" class="slider" id="spherePitchSlider" min="-90" max="90" value="0" step="1"/> </div> <div class="control-group"> <label><span style="color: #ff9800;">Sphere Roll</span> <span class="value-display" id="sphereRollValue">0°</span></label> <input type="range" class="slider" id="sphereRollSlider" min="-180" max="180" value="0" step="1"/> </div> </div> <div class="controls"> <div class="control-group"> <label><span style="color: #e91e63;">Quaternion X</span> <span class="value-display" id="quatXValue">0.000</span></label> <input type="range" class="slider" id="quatXSlider" min="-1" max="1" value="0" step="0.001"/> </div> <div class="control-group"> <label><span style="color: #9c27b0;">Quaternion Y</span> <span class="value-display" id="quatYValue">0.000</span></label> <input type="range" class="slider" id="quatYSlider" min="-1" max="1" value="0" step="0.001"/> </div> <div class="control-group"> <label><span style="color: #3f51b5;">Quaternion Z</span> <span class="value-display" id="quatZValue">0.000</span></label> <input type="range" class="slider" id="quatZSlider" min="-1" max="1" value="0" step="0.001"/> </div> <div class="control-group"> <label><span style="color: #009688;">Quaternion W</span> <span class="value-display" id="quatWValue">1.000</span></label> <input type="range" class="slider" id="quatWSlider" min="-1" max="1" value="1" step="0.001"/> </div> </div> <div class="controls"> <button class="button" id="showQuaternionFeatures">Show Antipodal Points &amp; Geodesic Arc</button> </div> <div class="info-box"> <strong>Independent Controls:</strong> This quaternion sphere has its own Euler angle and quaternion component sliders. Changes in one automatically update the other while maintaining unit length through automatic normalization. All updates are real-time and bidirectional. </div> </div> <h2 id="the-hopf-fibration-understanding-quaternion-geometry">The Hopf Fibration: Understanding Quaternion Geometry</h2> <p>Before diving into the quaternion solution, it’s worth understanding one of the most beautiful mathematical structures that explains <em>why</em> quaternions work so elegantly: the <strong>Hopf fibration</strong>.</p> <h3 id="what-is-the-hopf-fibration">What Is the Hopf Fibration?</h3> <p>The Hopf fibration is a mathematical mapping discovered by Heinz Hopf in 1931 that reveals the deep geometric structure underlying quaternions. Think of it as a way of organizing the 4D quaternion space that makes 3D rotations naturally emerge.</p> <p><strong>The Basic Setup:</strong></p> <ul> <li><strong>Total Space</strong>: The 3-sphere (S³) - where unit quaternions live</li> <li><strong>Base Space</strong>: The 2-sphere (S²) - representing all possible 3D rotation axes</li> <li><strong>Fiber</strong>: Circles (S¹) - representing rotations around each axis</li> </ul> <h3 id="the-intuitive-picture">The Intuitive Picture</h3> <p>Imagine you’re holding a globe (the 2-sphere S²). Each point on this globe represents a possible rotation axis in 3D space - north pole might be the Z-axis, equator points represent X-Y plane axes, and so on.</p> <p>Now, for each point on this globe, imagine a circle floating above it in 4D space. This circle represents all the different amounts you can rotate around that particular axis - 0°, 90°, 180°, 270°, back to 0°. These circles are the “fibers” of the Hopf fibration.</p> <p>The remarkable thing is that these circles never intersect, even though they fill up the entire 4D space of the 3-sphere. It’s like having infinite circles, each dedicated to one rotation axis, perfectly organized in 4D space without any collisions.</p> <h3 id="why-this-matters-for-quaternions">Why This Matters for Quaternions</h3> <p>This structure explains several key properties of quaternions:</p> <p><strong>1. No Singularities</strong>: Unlike Euler angles, which break down at certain orientations (gimbal lock), the Hopf fibration shows that every possible 3D rotation corresponds to a smooth path on the 3-sphere. There are no “holes” or “edges” where the math breaks down.</p> <p><strong>2. Double Coverage</strong>: Each 3D rotation corresponds to exactly two antipodal points on S³ (q and -q represent the same rotation). The Hopf fibration reveals this as a natural consequence of the fiber structure - each fiber maps to the same rotation axis, but parameterized twice around the circle.</p> <p><strong>3. Smooth Interpolation</strong>: SLERP works perfectly because it follows great circle arcs on S³, which project down to the shortest rotation paths on the rotation group SO(3). The Hopf fibration guarantees these paths exist and are unique.</p> <h3 id="the-mathematical-beauty">The Mathematical Beauty</h3> <table> <tbody> <tr> <td>The Hopf fibration can be written elegantly using complex numbers. If we represent a unit quaternion as two complex numbers (z₁, z₂) where</td> <td>z₁</td> <td>² +</td> <td>z₂</td> <td>² = 1, then the Hopf map is:</td> </tr> </tbody> </table> <table> <tbody> <tr> <td><strong>Hopf map</strong>: (z₁, z₂) → (z₁z̄₂,</td> <td>z₁</td> <td>² -</td> <td>z₂</td> <td>²)</td> </tr> </tbody> </table> <p>This simple formula encodes the entire relationship between 4D quaternion space and 3D rotation space. The first component gives the rotation axis, while the second component relates to the rotation angle.</p> <h3 id="real-world-implications">Real-World Implications</h3> <p>Understanding the Hopf fibration helps explain why:</p> <ul> <li><strong>Flight simulators</strong> use quaternions internally, even if they display Euler angles to pilots</li> <li><strong>Robot control systems</strong> can achieve smoother, more predictable motion with quaternions</li> <li><strong>3D animation software</strong> can avoid gimbal lock artifacts in character rigs</li> <li><strong>Spacecraft attitude control</strong> becomes more reliable and efficient</li> </ul> <p>The Hopf fibration isn’t just abstract mathematics - it’s the geometric reason why quaternions provide such a robust, singularity-free way to handle 3D rotations in practice.</p> <div class="panel"> <h3>Hopf Fibration: The True S³ → S² Mapping</h3> <div class="canvas-container" style="height: 500px;"> <canvas id="hopfCanvas"></canvas> </div> <div class="hopf-info-panel"> <h4>Mathematical Structure</h4> <p><strong>Base Space:</strong> 2-sphere (S²)</p> <p><strong>Total Space:</strong> 3-sphere (S³)</p> <p><strong>Fiber:</strong> Circle (S¹)</p> <p>Each point on S² corresponds to a circle on S³. The visualization shows fibers as colored curves using stereographic projection from the 4D quaternion sphere.</p> </div> <div class="controls"> <div class="control-group"> <label>Rotation Speed <span class="value-display" id="hopfRotationSpeedValue">0.5</span></label> <input type="range" class="slider" id="hopfRotationSpeed" min="0" max="2" value="0.5" step="0.1"/> </div> <div class="control-group"> <label>Fiber Count <span class="value-display" id="hopfFiberCountValue">16</span></label> <input type="range" class="slider" id="hopfFiberCount" min="8" max="32" value="16" step="2"/> </div> <div class="control-group"> <label>Animation Phase <span class="value-display" id="hopfAnimationPhaseValue">0.00</span></label> <input type="range" class="slider" id="hopfAnimationPhase" min="0" max="6.28" value="0" step="0.1"/> </div> <div class="control-group"> <label>Base Sphere Size <span class="value-display" id="hopfBaseSphereValue">1.0</span></label> <input type="range" class="slider" id="hopfBaseSphere" min="0.5" max="2" value="1" step="0.1"/> </div> </div> <div class="controls"> <button class="button" id="hopfToggleAnimation">Pause</button> <button class="button" id="hopfResetView">Reset View</button> </div> <div class="info-box"> <strong>Advanced Hopf Fibration:</strong> This visualization uses proper complex number representation and stereographic projection to show the true S³ → S² → S¹ fiber bundle structure. Each colored fiber represents a great circle on the 4D quaternion sphere that projects to a single point on the 2D base sphere. The mathematical elegance of this structure is what makes quaternions so powerful for representing rotations! </div> </div> <h2 id="enter-quaternions-a-better-way-to-rotate">Enter Quaternions: A Better Way to Rotate</h2> <p>Quaternions might seem mysterious at first, but they’re actually quite elegant once you understand the core idea. Think of them as an extension of complex numbers to 3D rotations.</p> <h3 id="what-is-a-quaternion">What Is a Quaternion?</h3> <p>A quaternion is a 4-component number: <strong>q = (x, y, z, w)</strong> where:</p> <ul> <li><strong>(x, y, z)</strong>: The rotation axis (like a vector pointing through the object)</li> <li><strong>w</strong>: Related to the rotation angle (cosine of half-angle)</li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Quaternion class - much more stable than Euler angles</span>
<span class="kd">class</span> <span class="nc">Quaternion</span> <span class="p">{</span>
    <span class="nf">constructor</span><span class="p">(</span><span class="nx">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">z</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">w</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="nx">x</span><span class="p">;</span> <span class="k">this</span><span class="p">.</span><span class="nx">y</span> <span class="o">=</span> <span class="nx">y</span><span class="p">;</span> <span class="k">this</span><span class="p">.</span><span class="nx">z</span> <span class="o">=</span> <span class="nx">z</span><span class="p">;</span> <span class="k">this</span><span class="p">.</span><span class="nx">w</span> <span class="o">=</span> <span class="nx">w</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="c1">// Create quaternion from axis-angle (most intuitive)</span>
    <span class="kd">static</span> <span class="nf">fromAxisAngle</span><span class="p">(</span><span class="nx">axis</span><span class="p">,</span> <span class="nx">angle</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">halfAngle</span> <span class="o">=</span> <span class="nx">angle</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">;</span>
        <span class="kd">const</span> <span class="nx">sin</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">sin</span><span class="p">(</span><span class="nx">halfAngle</span><span class="p">);</span>
        <span class="kd">const</span> <span class="nx">cos</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">cos</span><span class="p">(</span><span class="nx">halfAngle</span><span class="p">);</span>
        
        <span class="k">return</span> <span class="k">new</span> <span class="nc">Quaternion</span><span class="p">(</span>
            <span class="nx">axis</span><span class="p">.</span><span class="nx">x</span> <span class="o">*</span> <span class="nx">sin</span><span class="p">,</span>
            <span class="nx">axis</span><span class="p">.</span><span class="nx">y</span> <span class="o">*</span> <span class="nx">sin</span><span class="p">,</span>
            <span class="nx">axis</span><span class="p">.</span><span class="nx">z</span> <span class="o">*</span> <span class="nx">sin</span><span class="p">,</span>
            <span class="nx">cos</span>
        <span class="p">);</span>
    <span class="p">}</span>
    
    <span class="c1">// The magic: no gimbal lock!</span>
    <span class="kd">static</span> <span class="nf">fromEuler</span><span class="p">(</span><span class="nx">yaw</span><span class="p">,</span> <span class="nx">pitch</span><span class="p">,</span> <span class="nx">roll</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">cy</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">cos</span><span class="p">(</span><span class="nx">yaw</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">);</span>
        <span class="kd">const</span> <span class="nx">sy</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">sin</span><span class="p">(</span><span class="nx">yaw</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">);</span>
        <span class="kd">const</span> <span class="nx">cp</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">cos</span><span class="p">(</span><span class="nx">pitch</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">);</span>
        <span class="kd">const</span> <span class="nx">sp</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">sin</span><span class="p">(</span><span class="nx">pitch</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">);</span>
        <span class="kd">const</span> <span class="nx">cr</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">cos</span><span class="p">(</span><span class="nx">roll</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">);</span>
        <span class="kd">const</span> <span class="nx">sr</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">sin</span><span class="p">(</span><span class="nx">roll</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">);</span>

        <span class="k">return</span> <span class="k">new</span> <span class="nc">Quaternion</span><span class="p">(</span>
            <span class="nx">sr</span> <span class="o">*</span> <span class="nx">cp</span> <span class="o">*</span> <span class="nx">cy</span> <span class="o">-</span> <span class="nx">cr</span> <span class="o">*</span> <span class="nx">sp</span> <span class="o">*</span> <span class="nx">sy</span><span class="p">,</span>
            <span class="nx">cr</span> <span class="o">*</span> <span class="nx">sp</span> <span class="o">*</span> <span class="nx">cy</span> <span class="o">+</span> <span class="nx">sr</span> <span class="o">*</span> <span class="nx">cp</span> <span class="o">*</span> <span class="nx">sy</span><span class="p">,</span>
            <span class="nx">cr</span> <span class="o">*</span> <span class="nx">cp</span> <span class="o">*</span> <span class="nx">sy</span> <span class="o">-</span> <span class="nx">sr</span> <span class="o">*</span> <span class="nx">sp</span> <span class="o">*</span> <span class="nx">cy</span><span class="p">,</span>
            <span class="nx">cr</span> <span class="o">*</span> <span class="nx">cp</span> <span class="o">*</span> <span class="nx">cy</span> <span class="o">+</span> <span class="nx">sr</span> <span class="o">*</span> <span class="nx">sp</span> <span class="o">*</span> <span class="nx">sy</span>
        <span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="why-quaternions-work-the-key-insight">Why Quaternions Work: The Key Insight</h3> <p>Quaternions live on a <strong>4D unit sphere</strong> (mathematically called S³). This extra dimension is what eliminates gimbal lock! Here’s the crucial insight:</p> <ul> <li><strong>Euler angles</strong>: 3 parameters trying to represent 3D rotations → singularities inevitable</li> <li><strong>Quaternions</strong>: 4 parameters (with 1 constraint: unit length) → no singularities!</li> </ul> <p>Think of it like this: imagine trying to wrap a globe with flat paper without wrinkles - impossible! But if you allow the paper to stretch into 3D, it becomes easy. Similarly, that extra quaternion dimension eliminates the “wrinkles” (singularities) in rotation space.</p> <h3 id="the-double-cover-property">The Double Cover Property</h3> <p>Here’s something fascinating: both <strong>q</strong> and <strong>-q</strong> represent the same rotation! This “double coverage” might seem redundant, but it’s actually a feature:</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Both of these represent the same rotation:</span>
<span class="kd">const</span> <span class="nx">q1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Quaternion</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>    <span class="c1">// Identity rotation</span>
<span class="kd">const</span> <span class="nx">q2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Quaternion</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>   <span class="c1">// Same rotation!</span>

<span class="c1">// This redundancy eliminates singularities</span>
<span class="kd">function</span> <span class="nf">ensureContinuity</span><span class="p">(</span><span class="nx">currentQ</span><span class="p">,</span> <span class="nx">previousQ</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Choose the closer of q or -q to maintain smooth motion</span>
    <span class="kd">const</span> <span class="nx">dot1</span> <span class="o">=</span> <span class="nf">dotProduct</span><span class="p">(</span><span class="nx">currentQ</span><span class="p">,</span> <span class="nx">previousQ</span><span class="p">);</span>
    <span class="kd">const</span> <span class="nx">dot2</span> <span class="o">=</span> <span class="nf">dotProduct</span><span class="p">(</span><span class="nf">negateQuaternion</span><span class="p">(</span><span class="nx">currentQ</span><span class="p">),</span> <span class="nx">previousQ</span><span class="p">);</span>
    
    <span class="k">return</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">abs</span><span class="p">(</span><span class="nx">dot2</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">abs</span><span class="p">(</span><span class="nx">dot1</span><span class="p">)</span> <span class="p">?</span>
           <span class="nf">negateQuaternion</span><span class="p">(</span><span class="nx">currentQ</span><span class="p">)</span> <span class="p">:</span> <span class="nx">currentQ</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="real-world-applications">Real-World Applications</h3> <p><strong>Unity Game Engine Example:</strong></p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Unity uses quaternions internally for all rotations</span>
<span class="n">Transform</span> <span class="n">player</span><span class="p">;</span>

<span class="c1">// Smooth rotation without gimbal lock</span>
<span class="n">Quaternion</span> <span class="n">targetRotation</span> <span class="p">=</span> <span class="n">Quaternion</span><span class="p">.</span><span class="nf">LookRotation</span><span class="p">(</span><span class="n">direction</span><span class="p">);</span>
<span class="n">player</span><span class="p">.</span><span class="n">rotation</span> <span class="p">=</span> <span class="n">Quaternion</span><span class="p">.</span><span class="nf">Slerp</span><span class="p">(</span><span class="n">player</span><span class="p">.</span><span class="n">rotation</span><span class="p">,</span> <span class="n">targetRotation</span><span class="p">,</span> <span class="n">Time</span><span class="p">.</span><span class="n">deltaTime</span> <span class="p">*</span> <span class="n">rotateSpeed</span><span class="p">);</span>

<span class="c1">// This just works - no special cases needed!</span>
</code></pre></div></div> <p><strong>Robotics Example:</strong></p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Robot arm joint control using quaternions</span>
<span class="k">class</span> <span class="nc">RobotJoint</span> <span class="p">{</span>
    <span class="n">Quaternion</span> <span class="n">currentOrientation</span><span class="p">;</span>
    <span class="n">Quaternion</span> <span class="n">targetOrientation</span><span class="p">;</span>
    
    <span class="kt">void</span> <span class="n">updateJoint</span><span class="p">(</span><span class="kt">float</span> <span class="n">deltaTime</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// SLERP provides smooth, constant-speed rotation</span>
        <span class="n">currentOrientation</span> <span class="o">=</span> <span class="n">slerp</span><span class="p">(</span><span class="n">currentOrientation</span><span class="p">,</span>
                                 <span class="n">targetOrientation</span><span class="p">,</span>
                                 <span class="n">deltaTime</span> <span class="o">*</span> <span class="n">jointSpeed</span><span class="p">);</span>
        
        <span class="c1">// Convert to motor control signals</span>
        <span class="n">applyJointRotation</span><span class="p">(</span><span class="n">currentOrientation</span><span class="p">.</span><span class="n">toRotationMatrix</span><span class="p">());</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div> <p><strong>The Mathematics Behind the Magic:</strong></p> <p>The quaternion sphere visualization above demonstrates this double coverage. The antipodal points ±q on the 4D sphere both map to the same rotation matrix, providing redundancy that eliminates singular configurations. This is why quaternions can represent any 3D rotation smoothly - they live in a higher-dimensional space that “unwraps” the problematic topology of 3D rotation space.</p> <p><strong>For the mathematically inclined:</strong> Quaternions form a <strong>Lie group</strong> isomorphic to SU(2), which double-covers SO(3). The <strong>hairy ball theorem</strong> proves that any 3-parameter system must have singularities, but quaternions sidestep this by using 4 parameters with a constraint.</p> <h2 id="slerp-vs-lerp-the-battle-of-interpolation-methods">SLERP vs LERP: The Battle of Interpolation Methods</h2> <p>When animating rotations, you need to smoothly transition from one orientation to another. This is where <strong>SLERP</strong> (Spherical Linear Interpolation) shines compared to simple linear interpolation of Euler angles.</p> <h3 id="the-problem-with-euler-interpolation">The Problem with Euler Interpolation</h3> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Naive Euler angle interpolation - DON'T DO THIS!</span>
<span class="kd">function</span> <span class="nf">badRotationInterp</span><span class="p">(</span><span class="nx">startEuler</span><span class="p">,</span> <span class="nx">endEuler</span><span class="p">,</span> <span class="nx">t</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">{</span>
        <span class="na">yaw</span><span class="p">:</span> <span class="nx">startEuler</span><span class="p">.</span><span class="nx">yaw</span> <span class="o">+</span> <span class="p">(</span><span class="nx">endEuler</span><span class="p">.</span><span class="nx">yaw</span> <span class="o">-</span> <span class="nx">startEuler</span><span class="p">.</span><span class="nx">yaw</span><span class="p">)</span> <span class="o">*</span> <span class="nx">t</span><span class="p">,</span>
        <span class="na">pitch</span><span class="p">:</span> <span class="nx">startEuler</span><span class="p">.</span><span class="nx">pitch</span> <span class="o">+</span> <span class="p">(</span><span class="nx">endEuler</span><span class="p">.</span><span class="nx">pitch</span> <span class="o">-</span> <span class="nx">startEuler</span><span class="p">.</span><span class="nx">pitch</span><span class="p">)</span> <span class="o">*</span> <span class="nx">t</span><span class="p">,</span>
        <span class="na">roll</span><span class="p">:</span> <span class="nx">startEuler</span><span class="p">.</span><span class="nx">roll</span> <span class="o">+</span> <span class="p">(</span><span class="nx">endEuler</span><span class="p">.</span><span class="nx">roll</span> <span class="o">-</span> <span class="nx">startEuler</span><span class="p">.</span><span class="nx">roll</span><span class="p">)</span> <span class="o">*</span> <span class="nx">t</span>
    <span class="p">};</span>
<span class="p">}</span>

<span class="c1">// Why this fails:</span>
<span class="kd">const</span> <span class="k">from</span> <span class="o">=</span> <span class="p">{</span><span class="na">yaw</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="na">pitch</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="na">roll</span><span class="p">:</span> <span class="mi">0</span><span class="p">};</span>
<span class="kd">const</span> <span class="nx">to</span> <span class="o">=</span> <span class="p">{</span><span class="na">yaw</span><span class="p">:</span> <span class="mi">180</span><span class="p">,</span> <span class="na">pitch</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="na">roll</span><span class="p">:</span> <span class="mi">0</span><span class="p">};</span>
<span class="c1">// Linear interpolation spins through intermediate orientations</span>
<span class="c1">// that aren't on the shortest rotation path!</span>
</code></pre></div></div> <h3 id="slerp-the-right-way">SLERP: The Right Way</h3> <p>SLERP finds the shortest path between two orientations and moves along it at constant angular speed:</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Proper quaternion SLERP implementation</span>
<span class="kd">function</span> <span class="nf">slerp</span><span class="p">(</span><span class="nx">q1</span><span class="p">,</span> <span class="nx">q2</span><span class="p">,</span> <span class="nx">t</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Ensure we take the shorter path (handle double cover)</span>
    <span class="kd">let</span> <span class="nx">dot</span> <span class="o">=</span> <span class="nx">q1</span><span class="p">.</span><span class="nx">x</span><span class="o">*</span><span class="nx">q2</span><span class="p">.</span><span class="nx">x</span> <span class="o">+</span> <span class="nx">q1</span><span class="p">.</span><span class="nx">y</span><span class="o">*</span><span class="nx">q2</span><span class="p">.</span><span class="nx">y</span> <span class="o">+</span> <span class="nx">q1</span><span class="p">.</span><span class="nx">z</span><span class="o">*</span><span class="nx">q2</span><span class="p">.</span><span class="nx">z</span> <span class="o">+</span> <span class="nx">q1</span><span class="p">.</span><span class="nx">w</span><span class="o">*</span><span class="nx">q2</span><span class="p">.</span><span class="nx">w</span><span class="p">;</span>
    
    <span class="c1">// If dot &lt; 0, use -q2 to ensure shorter path</span>
    <span class="k">if </span><span class="p">(</span><span class="nx">dot</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">q2</span> <span class="o">=</span> <span class="p">{</span><span class="na">x</span><span class="p">:</span> <span class="o">-</span><span class="nx">q2</span><span class="p">.</span><span class="nx">x</span><span class="p">,</span> <span class="na">y</span><span class="p">:</span> <span class="o">-</span><span class="nx">q2</span><span class="p">.</span><span class="nx">y</span><span class="p">,</span> <span class="na">z</span><span class="p">:</span> <span class="o">-</span><span class="nx">q2</span><span class="p">.</span><span class="nx">z</span><span class="p">,</span> <span class="na">w</span><span class="p">:</span> <span class="o">-</span><span class="nx">q2</span><span class="p">.</span><span class="nx">w</span><span class="p">};</span>
        <span class="nx">dot</span> <span class="o">=</span> <span class="o">-</span><span class="nx">dot</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="c1">// Handle nearly parallel quaternions</span>
    <span class="k">if </span><span class="p">(</span><span class="nx">dot</span> <span class="o">&gt;</span> <span class="mf">0.9995</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Use linear interpolation for numerical stability</span>
        <span class="kd">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="p">{</span>
            <span class="na">x</span><span class="p">:</span> <span class="nx">q1</span><span class="p">.</span><span class="nx">x</span> <span class="o">+</span> <span class="nx">t</span> <span class="o">*</span> <span class="p">(</span><span class="nx">q2</span><span class="p">.</span><span class="nx">x</span> <span class="o">-</span> <span class="nx">q1</span><span class="p">.</span><span class="nx">x</span><span class="p">),</span>
            <span class="na">y</span><span class="p">:</span> <span class="nx">q1</span><span class="p">.</span><span class="nx">y</span> <span class="o">+</span> <span class="nx">t</span> <span class="o">*</span> <span class="p">(</span><span class="nx">q2</span><span class="p">.</span><span class="nx">y</span> <span class="o">-</span> <span class="nx">q1</span><span class="p">.</span><span class="nx">y</span><span class="p">),</span>
            <span class="na">z</span><span class="p">:</span> <span class="nx">q1</span><span class="p">.</span><span class="nx">z</span> <span class="o">+</span> <span class="nx">t</span> <span class="o">*</span> <span class="p">(</span><span class="nx">q2</span><span class="p">.</span><span class="nx">z</span> <span class="o">-</span> <span class="nx">q1</span><span class="p">.</span><span class="nx">z</span><span class="p">),</span>
            <span class="na">w</span><span class="p">:</span> <span class="nx">q1</span><span class="p">.</span><span class="nx">w</span> <span class="o">+</span> <span class="nx">t</span> <span class="o">*</span> <span class="p">(</span><span class="nx">q2</span><span class="p">.</span><span class="nx">w</span> <span class="o">-</span> <span class="nx">q1</span><span class="p">.</span><span class="nx">w</span><span class="p">)</span>
        <span class="p">};</span>
        <span class="k">return</span> <span class="nf">normalize</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span>
    <span class="p">}</span>
    
    <span class="c1">// Standard SLERP formula</span>
    <span class="kd">const</span> <span class="nx">theta</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">acos</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nf">abs</span><span class="p">(</span><span class="nx">dot</span><span class="p">));</span>
    <span class="kd">const</span> <span class="nx">sinTheta</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">sin</span><span class="p">(</span><span class="nx">theta</span><span class="p">);</span>
    <span class="kd">const</span> <span class="nx">scale1</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">sin</span><span class="p">((</span><span class="mi">1</span><span class="o">-</span><span class="nx">t</span><span class="p">)</span> <span class="o">*</span> <span class="nx">theta</span><span class="p">)</span> <span class="o">/</span> <span class="nx">sinTheta</span><span class="p">;</span>
    <span class="kd">const</span> <span class="nx">scale2</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">sin</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span> <span class="nx">theta</span><span class="p">)</span> <span class="o">/</span> <span class="nx">sinTheta</span><span class="p">;</span>
    
    <span class="k">return</span> <span class="p">{</span>
        <span class="na">x</span><span class="p">:</span> <span class="nx">scale1</span> <span class="o">*</span> <span class="nx">q1</span><span class="p">.</span><span class="nx">x</span> <span class="o">+</span> <span class="nx">scale2</span> <span class="o">*</span> <span class="nx">q2</span><span class="p">.</span><span class="nx">x</span><span class="p">,</span>
        <span class="na">y</span><span class="p">:</span> <span class="nx">scale1</span> <span class="o">*</span> <span class="nx">q1</span><span class="p">.</span><span class="nx">y</span> <span class="o">+</span> <span class="nx">scale2</span> <span class="o">*</span> <span class="nx">q2</span><span class="p">.</span><span class="nx">y</span><span class="p">,</span>
        <span class="na">z</span><span class="p">:</span> <span class="nx">scale1</span> <span class="o">*</span> <span class="nx">q1</span><span class="p">.</span><span class="nx">z</span> <span class="o">+</span> <span class="nx">scale2</span> <span class="o">*</span> <span class="nx">q2</span><span class="p">.</span><span class="nx">z</span><span class="p">,</span>
        <span class="na">w</span><span class="p">:</span> <span class="nx">scale1</span> <span class="o">*</span> <span class="nx">q1</span><span class="p">.</span><span class="nx">w</span> <span class="o">+</span> <span class="nx">scale2</span> <span class="o">*</span> <span class="nx">q2</span><span class="p">.</span><span class="nx">w</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="real-world-application-examples">Real-World Application Examples</h3> <p><strong>Camera Movement in Games:</strong></p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Smooth camera transitions using SLERP</span>
<span class="kd">class</span> <span class="nc">Camera</span> <span class="p">{</span>
    <span class="nf">constructor</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">orientation</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Quaternion</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">targetOrientation</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Quaternion</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    
    <span class="nf">lookAt</span><span class="p">(</span><span class="nx">target</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Calculate desired orientation</span>
        <span class="kd">const</span> <span class="nx">direction</span> <span class="o">=</span> <span class="nx">Vector3</span><span class="p">.</span><span class="nf">subtract</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">position</span><span class="p">);</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">targetOrientation</span> <span class="o">=</span> <span class="nx">Quaternion</span><span class="p">.</span><span class="nf">lookRotation</span><span class="p">(</span><span class="nx">direction</span><span class="p">);</span>
    <span class="p">}</span>
    
    <span class="nf">update</span><span class="p">(</span><span class="nx">deltaTime</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Smooth interpolation - no jumpy camera movement!</span>
        <span class="kd">const</span> <span class="nx">speed</span> <span class="o">=</span> <span class="mf">2.0</span><span class="p">;</span> <span class="c1">// rotation speed</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">orientation</span> <span class="o">=</span> <span class="nf">slerp</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">orientation</span><span class="p">,</span>
                                <span class="k">this</span><span class="p">.</span><span class="nx">targetOrientation</span><span class="p">,</span>
                                <span class="nx">deltaTime</span> <span class="o">*</span> <span class="nx">speed</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p><strong>Robot Arm Control:</strong></p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Smooth robot joint movement using SLERP
</span><span class="k">class</span> <span class="nc">RobotArm</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">joint_orientations</span> <span class="o">=</span> <span class="p">[</span><span class="n">Quaternion</span><span class="p">.</span><span class="nf">identity</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">6</span><span class="p">)]</span>
        <span class="n">self</span><span class="p">.</span><span class="n">target_orientations</span> <span class="o">=</span> <span class="p">[</span><span class="n">Quaternion</span><span class="p">.</span><span class="nf">identity</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">6</span><span class="p">)]</span>
    
    <span class="k">def</span> <span class="nf">move_to_position</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">target_pose</span><span class="p">,</span> <span class="n">duration</span><span class="p">):</span>
        <span class="c1"># Calculate target joint orientations using inverse kinematics
</span>        <span class="n">self</span><span class="p">.</span><span class="n">target_orientations</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">inverse_kinematics</span><span class="p">(</span><span class="n">target_pose</span><span class="p">)</span>
        
        <span class="c1"># SLERP ensures smooth, natural-looking motion
</span>        <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="nf">time</span><span class="p">()</span>
        <span class="k">while</span> <span class="n">time</span><span class="p">.</span><span class="nf">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span> <span class="o">&lt;</span> <span class="n">duration</span><span class="p">:</span>
            <span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="n">time</span><span class="p">.</span><span class="nf">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">)</span> <span class="o">/</span> <span class="n">duration</span>
            
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">6</span><span class="p">):</span>
                <span class="n">self</span><span class="p">.</span><span class="n">joint_orientations</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nf">slerp</span><span class="p">(</span>
                    <span class="n">self</span><span class="p">.</span><span class="n">joint_orientations</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                    <span class="n">self</span><span class="p">.</span><span class="n">target_orientations</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                    <span class="n">t</span>
                <span class="p">)</span>
            
            <span class="n">self</span><span class="p">.</span><span class="nf">update_joint_motors</span><span class="p">()</span>
            <span class="n">time</span><span class="p">.</span><span class="nf">sleep</span><span class="p">(</span><span class="mf">0.016</span><span class="p">)</span>  <span class="c1"># 60 FPS update
</span></code></pre></div></div> <h3 id="why-slerp-works-the-mathematical-insight">Why SLERP Works: The Mathematical Insight</h3> <p>The key insight is that SLERP follows <strong>great circle arcs</strong> on the quaternion sphere - these are the shortest paths between rotations, just like how airplane routes follow great circles on Earth.</p> <p><strong>Mathematical Properties of SLERP:</strong></p> <ul> <li><strong>Constant Angular Velocity</strong>: Objects rotate at steady speed (no speed-up/slow-down artifacts)</li> <li><strong>Shortest Path</strong>: Always takes the most direct route between orientations</li> <li><strong>Interpolation Property</strong>: slerp(q1, q2, 0) = q1 and slerp(q1, q2, 1) = q2</li> <li><strong>Composition Invariant</strong>: Results don’t depend on coordinate system choice</li> </ul> <p><strong>Euler LERP Problems:</strong></p> <ul> <li><strong>Variable Speed</strong>: Object speed changes unpredictably during rotation</li> <li><strong>Non-optimal Path</strong>: Takes longer, curved routes through “rotation space”</li> <li><strong>Gimbal Lock Sensitivity</strong>: Can produce wild spinning near singularities</li> </ul> <h3 id="visualization-analysis">Visualization Analysis</h3> <p>The interactive demonstrations below show these differences clearly:</p> <p><strong>Left Panel - Angular Velocity Profile</strong>: This shows rotation speed over time (0 to 1). SLERP maintains constant angular velocity - the line is flat! Euler LERP shows varying speed with unpredictable speed-ups and slow-downs.</p> <p><strong>Right Panel - Quaternion Paths</strong>: Shows actual rotation paths on the unit sphere. The blue SLERP path follows the shortest great circle arc, while the red Euler LERP path takes a curved, non-optimal route.</p> <div class="panel wide-panel"> <h3>Interpolation: Euler LERP vs SLERP</h3> <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;"> <div class="canvas-container" style="height: 300px;"> <canvas id="slerpVelocityCanvas"></canvas> </div> <div class="canvas-container" style="height: 300px;"> <canvas id="slerpPathCanvas"></canvas> </div> </div> <div class="controls"> <div class="control-group"> <label>Interpolation Parameter t <span class="value-display" id="tValue">0.0</span></label> <input type="range" class="slider" id="tSlider" min="0" max="1" value="0" step="0.01"/> </div> <button class="button" id="animateInterp">Animate Interpolation</button> <button class="button" id="setRandomOrientations">Set Random Orientations</button> </div> <div class="info-box"> <strong>Left Panel - Angular Velocity:</strong> Shows rotation speed over time (0 to 1)<br/> • <span style="color: #2196f3;">Blue (SLERP)</span>: Constant angular velocity - the line is flat! (σ ≈ 0)<br/> • <span style="color: #f44336;">Red (Euler LERP)</span>: Varying speed - speeds up and slows down (σ &gt; 0)<br/> <br/> <strong>Right Panel - Quaternion Paths:</strong> Shows actual rotation paths on the unit sphere<br/> • <span style="color: #2196f3;">Blue path</span>: SLERP follows the shortest great circle arc<br/> • <span style="color: #f44336;">Red path</span>: Euler LERP takes a curved, non-optimal path<br/> <br/> <strong>Key Insight:</strong> SLERP provides smooth, constant-speed rotation (like a spinning gyroscope), while Euler LERP causes jerky, unnatural motion with varying speeds. This is why SLERP is essential for animation and robotics! </div> </div> <h2 id="understanding-euler-angle-instability-a-visual-guide">Understanding Euler Angle Instability: A Visual Guide</h2> <p>Why do Euler angles become unstable near certain orientations? The sensitivity heatmap below reveals the mathematical “danger zones” where small changes in input can cause huge, unpredictable rotations.</p> <h3 id="what-are-we-looking-at">What Are We Looking At?</h3> <p>Think of the heatmap as a “stability map” for Euler angle rotations:</p> <ul> <li><strong>Blue regions</strong>: Safe - small input changes cause small rotation changes</li> <li><strong>Green regions</strong>: Caution - getting sensitive to small changes</li> <li><strong>Red regions</strong>: Dangerous - small changes can cause large jumps</li> <li><strong>Yellow regions</strong>: Gimbal lock! - the system breaks down completely</li> </ul> <h3 id="the-mathematics-behind-the-colors">The Mathematics Behind the Colors</h3> <p>The colors represent the <strong>condition number</strong> of something called the Jacobian matrix. Don’t worry about the fancy names - here’s what matters:</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// This matrix tells us how sensitive rotations are to Euler angle changes</span>
<span class="kd">function</span> <span class="nf">calculateSensitivity</span><span class="p">(</span><span class="nx">yaw</span><span class="p">,</span> <span class="nx">pitch</span><span class="p">,</span> <span class="nx">roll</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Near pitch = ±90°, this matrix becomes "singular"</span>
    <span class="c1">// (mathematically broken)</span>
    <span class="kd">const</span> <span class="nx">cosP</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">cos</span><span class="p">(</span><span class="nx">pitch</span><span class="p">);</span>
    <span class="kd">const</span> <span class="nx">sinP</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">sin</span><span class="p">(</span><span class="nx">pitch</span><span class="p">);</span>
    
    <span class="c1">// The Jacobian matrix - relates angle changes to rotation speed</span>
    <span class="kd">const</span> <span class="nx">J</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="nb">Math</span><span class="p">.</span><span class="nf">sin</span><span class="p">(</span><span class="nx">yaw</span><span class="p">),</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">cos</span><span class="p">(</span><span class="nx">yaw</span><span class="p">)</span> <span class="o">*</span> <span class="nx">cosP</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">0</span><span class="p">,</span>  <span class="nb">Math</span><span class="p">.</span><span class="nf">cos</span><span class="p">(</span><span class="nx">yaw</span><span class="p">),</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">sin</span><span class="p">(</span><span class="nx">yaw</span><span class="p">)</span> <span class="o">*</span> <span class="nx">cosP</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">1</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>             <span class="o">-</span><span class="nx">sinP</span><span class="p">]</span>
    <span class="p">];</span>
    
    <span class="c1">// When pitch ≈ ±90°, cosP ≈ 0, making the matrix unstable</span>
    <span class="k">return</span> <span class="nf">calculateConditionNumber</span><span class="p">(</span><span class="nx">J</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="real-world-implications-1">Real-World Implications</h3> <p><strong>Flight Simulator Example:</strong></p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// This is why flight simulators avoid certain orientations</span>
<span class="kd">class</span> <span class="nc">FlightControl</span> <span class="p">{</span>
    <span class="nf">updateOrientation</span><span class="p">(</span><span class="nx">yawInput</span><span class="p">,</span> <span class="nx">pitchInput</span><span class="p">,</span> <span class="nx">rollInput</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">sensitivity</span> <span class="o">=</span> <span class="nf">calculateSensitivity</span><span class="p">(</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">currentYaw</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">currentPitch</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">currentRoll</span>
        <span class="p">);</span>
        
        <span class="k">if </span><span class="p">(</span><span class="nx">sensitivity</span> <span class="o">&gt;</span> <span class="nx">DANGER_THRESHOLD</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// Switch to quaternion-based control near gimbal lock!</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">useQuaternionControl</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
            <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">WARNING: Entering gimbal lock region - switching to quaternions</span><span class="dl">"</span><span class="p">);</span>
        <span class="p">}</span>
        
        <span class="c1">// Apply control inputs based on current control mode</span>
        <span class="k">if </span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">useQuaternionControl</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">this</span><span class="p">.</span><span class="nf">updateWithQuaternions</span><span class="p">(</span><span class="nx">yawInput</span><span class="p">,</span> <span class="nx">pitchInput</span><span class="p">,</span> <span class="nx">rollInput</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">this</span><span class="p">.</span><span class="nf">updateWithEulerAngles</span><span class="p">(</span><span class="nx">yawInput</span><span class="p">,</span> <span class="nx">pitchInput</span><span class="p">,</span> <span class="nx">rollInput</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="torus-topology-why-angles-wrap-around">Torus Topology: Why Angles “Wrap Around”</h3> <p>The <strong>torus view</strong> shows something important: yaw and roll angles “wrap around” at ±180°. This is like how compass headings wrap from 359° back to 0°.</p> <p><strong>Practical Example:</strong></p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Angle wrapping causes problems in naive interpolation</span>
<span class="kd">const</span> <span class="nx">angle1</span> <span class="o">=</span> <span class="mi">170</span><span class="p">;</span>  <span class="c1">// degrees</span>
<span class="kd">const</span> <span class="nx">angle2</span> <span class="o">=</span> <span class="o">-</span><span class="mi">170</span><span class="p">;</span> <span class="c1">// degrees (equivalent to 190°)</span>

<span class="c1">// Naive interpolation: 170° → 0° → -170° (340° total rotation!)</span>
<span class="c1">// Smart interpolation: 170° → 180° → -170° (20° total rotation)</span>

<span class="kd">function</span> <span class="nf">smartAngleLerp</span><span class="p">(</span><span class="nx">a1</span><span class="p">,</span> <span class="nx">a2</span><span class="p">,</span> <span class="nx">t</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Handle the wrap-around case</span>
    <span class="kd">let</span> <span class="nx">diff</span> <span class="o">=</span> <span class="nx">a2</span> <span class="o">-</span> <span class="nx">a1</span><span class="p">;</span>
    <span class="k">if </span><span class="p">(</span><span class="nx">diff</span> <span class="o">&gt;</span> <span class="mi">180</span><span class="p">)</span> <span class="nx">diff</span> <span class="o">-=</span> <span class="mi">360</span><span class="p">;</span>
    <span class="k">if </span><span class="p">(</span><span class="nx">diff</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">180</span><span class="p">)</span> <span class="nx">diff</span> <span class="o">+=</span> <span class="mi">360</span><span class="p">;</span>
    
    <span class="k">return</span> <span class="nx">a1</span> <span class="o">+</span> <span class="nx">diff</span> <span class="o">*</span> <span class="nx">t</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>This is yet another reason why quaternions are superior - they don’t have wrap-around problems!</p> <p><strong>For the mathematically curious:</strong> The Jacobian matrix $J(ψ,θ,φ)$ relates small changes in Euler angles to angular velocity: $ω = J(ψ,θ,φ) \cdot [dψ/dt, dθ/dt, dφ/dt]^T$. Near gimbal lock $(θ ≈ ±π/2)$, $J$ becomes singular $(det(J) → 0)$, causing numerical instabilities and loss of controllability.</p> <div class="panel wide-panel"> <h3>Euler Angle Sensitivity Map (Torus Topology)</h3> <div class="canvas-container" style="height: 500px;"> <canvas id="heatmapCanvas"></canvas> </div> <div class="controls"> <div class="control-group"> <label>Fixed Pitch Value <span class="value-display" id="heatmapPitchValue">0°</span></label> <input type="range" class="slider" id="heatmapPitchSlider" min="-90" max="90" value="0" step="5"/> </div> <div class="control-group"> <label><span style="color: #64ffda;">Torus Yaw</span> <span class="value-display" id="torusYawValue">0°</span></label> <input type="range" class="slider" id="torusYawSlider" min="-180" max="180" value="0" step="1"/> </div> <div class="control-group"> <label><span style="color: #ff9800;">Torus Roll</span> <span class="value-display" id="torusRollValue">0°</span></label> <input type="range" class="slider" id="torusRollSlider" min="-180" max="180" value="0" step="1"/> </div> <button class="button" id="animateHeatmap">Animate Through Pitch Values</button> <button class="button" id="toggleTorusView">Toggle Torus/Flat View</button> </div> <div class="info-box"> <strong>Color coding:</strong> <span style="color: #0066ff;">Blue</span> = stable, <span style="color: #00ff00;">Green</span> = sensitive, <span style="color: #ff0000;">Red</span> = highly singular, <span style="color: #ffff00;">Yellow</span> = gimbal lock!<br/> This map shows how sensitive the rotation is to small changes in yaw/roll for a given pitch. The torus topology reveals how yaw and roll wrap around at ±180°. As pitch approaches ±90°, the entire map turns red/yellow, showing that yaw and roll become coupled and the coordinate system becomes singular. </div> </div> <h2 id="practical-implementation-guide-making-quaternions-work-for-you">Practical Implementation Guide: Making Quaternions Work for You</h2> <p>Ready to start using quaternions in your projects? Here are the essential patterns and best practices that will save you hours of debugging.</p> <h3 id="essential-quaternion-class-implementation">Essential Quaternion Class Implementation</h3> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Quaternion</span> <span class="p">{</span>
    <span class="nf">constructor</span><span class="p">(</span><span class="nx">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">z</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">w</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="nx">x</span><span class="p">;</span> <span class="k">this</span><span class="p">.</span><span class="nx">y</span> <span class="o">=</span> <span class="nx">y</span><span class="p">;</span> <span class="k">this</span><span class="p">.</span><span class="nx">z</span> <span class="o">=</span> <span class="nx">z</span><span class="p">;</span> <span class="k">this</span><span class="p">.</span><span class="nx">w</span> <span class="o">=</span> <span class="nx">w</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="c1">// CRITICAL: Always normalize after operations to prevent drift</span>
    <span class="nf">normalize</span><span class="p">()</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">length</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">sqrt</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">x</span><span class="o">*</span><span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">y</span><span class="o">*</span><span class="k">this</span><span class="p">.</span><span class="nx">y</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">z</span><span class="o">*</span><span class="k">this</span><span class="p">.</span><span class="nx">z</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">w</span><span class="o">*</span><span class="k">this</span><span class="p">.</span><span class="nx">w</span><span class="p">);</span>
        <span class="k">if </span><span class="p">(</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="kd">const</span> <span class="nx">invLength</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="nx">length</span><span class="p">;</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">*=</span> <span class="nx">invLength</span><span class="p">;</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">y</span> <span class="o">*=</span> <span class="nx">invLength</span><span class="p">;</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">z</span> <span class="o">*=</span> <span class="nx">invLength</span><span class="p">;</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">w</span> <span class="o">*=</span> <span class="nx">invLength</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="c1">// Multiply quaternions (order matters!)</span>
    <span class="nf">multiply</span><span class="p">(</span><span class="nx">other</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nc">Quaternion</span><span class="p">(</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">w</span><span class="o">*</span><span class="nx">other</span><span class="p">.</span><span class="nx">x</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">x</span><span class="o">*</span><span class="nx">other</span><span class="p">.</span><span class="nx">w</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">y</span><span class="o">*</span><span class="nx">other</span><span class="p">.</span><span class="nx">z</span> <span class="o">-</span> <span class="k">this</span><span class="p">.</span><span class="nx">z</span><span class="o">*</span><span class="nx">other</span><span class="p">.</span><span class="nx">y</span><span class="p">,</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">w</span><span class="o">*</span><span class="nx">other</span><span class="p">.</span><span class="nx">y</span> <span class="o">-</span> <span class="k">this</span><span class="p">.</span><span class="nx">x</span><span class="o">*</span><span class="nx">other</span><span class="p">.</span><span class="nx">z</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">y</span><span class="o">*</span><span class="nx">other</span><span class="p">.</span><span class="nx">w</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">z</span><span class="o">*</span><span class="nx">other</span><span class="p">.</span><span class="nx">x</span><span class="p">,</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">w</span><span class="o">*</span><span class="nx">other</span><span class="p">.</span><span class="nx">z</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">x</span><span class="o">*</span><span class="nx">other</span><span class="p">.</span><span class="nx">y</span> <span class="o">-</span> <span class="k">this</span><span class="p">.</span><span class="nx">y</span><span class="o">*</span><span class="nx">other</span><span class="p">.</span><span class="nx">x</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">z</span><span class="o">*</span><span class="nx">other</span><span class="p">.</span><span class="nx">w</span><span class="p">,</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">w</span><span class="o">*</span><span class="nx">other</span><span class="p">.</span><span class="nx">w</span> <span class="o">-</span> <span class="k">this</span><span class="p">.</span><span class="nx">x</span><span class="o">*</span><span class="nx">other</span><span class="p">.</span><span class="nx">x</span> <span class="o">-</span> <span class="k">this</span><span class="p">.</span><span class="nx">y</span><span class="o">*</span><span class="nx">other</span><span class="p">.</span><span class="nx">y</span> <span class="o">-</span> <span class="k">this</span><span class="p">.</span><span class="nx">z</span><span class="o">*</span><span class="nx">other</span><span class="p">.</span><span class="nx">z</span>
        <span class="p">);</span>
    <span class="p">}</span>
    
    <span class="c1">// Convert to rotation matrix (for graphics APIs)</span>
    <span class="nf">toMatrix</span><span class="p">()</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">x2</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y2</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">y</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">y</span><span class="p">,</span> <span class="nx">z2</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">z</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">z</span><span class="p">;</span>
        <span class="kd">const</span> <span class="nx">xx</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">*</span> <span class="nx">x2</span><span class="p">,</span> <span class="nx">xy</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">*</span> <span class="nx">y2</span><span class="p">,</span> <span class="nx">xz</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">*</span> <span class="nx">z2</span><span class="p">;</span>
        <span class="kd">const</span> <span class="nx">yy</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">y</span> <span class="o">*</span> <span class="nx">y2</span><span class="p">,</span> <span class="nx">yz</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">y</span> <span class="o">*</span> <span class="nx">z2</span><span class="p">,</span> <span class="nx">zz</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">z</span> <span class="o">*</span> <span class="nx">z2</span><span class="p">;</span>
        <span class="kd">const</span> <span class="nx">wx</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">w</span> <span class="o">*</span> <span class="nx">x2</span><span class="p">,</span> <span class="nx">wy</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">w</span> <span class="o">*</span> <span class="nx">y2</span><span class="p">,</span> <span class="nx">wz</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">w</span> <span class="o">*</span> <span class="nx">z2</span><span class="p">;</span>
        
        <span class="k">return</span> <span class="p">[</span>
            <span class="mi">1</span><span class="o">-</span><span class="p">(</span><span class="nx">yy</span><span class="o">+</span><span class="nx">zz</span><span class="p">),</span> <span class="nx">xy</span><span class="o">-</span><span class="nx">wz</span><span class="p">,</span>     <span class="nx">xz</span><span class="o">+</span><span class="nx">wy</span><span class="p">,</span>     <span class="mi">0</span><span class="p">,</span>
            <span class="nx">xy</span><span class="o">+</span><span class="nx">wz</span><span class="p">,</span>     <span class="mi">1</span><span class="o">-</span><span class="p">(</span><span class="nx">xx</span><span class="o">+</span><span class="nx">zz</span><span class="p">),</span> <span class="nx">yz</span><span class="o">-</span><span class="nx">wx</span><span class="p">,</span>     <span class="mi">0</span><span class="p">,</span>
            <span class="nx">xz</span><span class="o">-</span><span class="nx">wy</span><span class="p">,</span>     <span class="nx">yz</span><span class="o">+</span><span class="nx">wx</span><span class="p">,</span>     <span class="mi">1</span><span class="o">-</span><span class="p">(</span><span class="nx">xx</span><span class="o">+</span><span class="nx">yy</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
            <span class="mi">0</span><span class="p">,</span>         <span class="mi">0</span><span class="p">,</span>         <span class="mi">0</span><span class="p">,</span>         <span class="mi">1</span>
        <span class="p">];</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="safe-slerp-implementation">Safe SLERP Implementation</h3> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">safeSlerp</span><span class="p">(</span><span class="nx">q1</span><span class="p">,</span> <span class="nx">q2</span><span class="p">,</span> <span class="nx">t</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// IMPORTANT: Handle the double cover - choose shorter path</span>
    <span class="kd">let</span> <span class="nx">dot</span> <span class="o">=</span> <span class="nx">q1</span><span class="p">.</span><span class="nx">x</span><span class="o">*</span><span class="nx">q2</span><span class="p">.</span><span class="nx">x</span> <span class="o">+</span> <span class="nx">q1</span><span class="p">.</span><span class="nx">y</span><span class="o">*</span><span class="nx">q2</span><span class="p">.</span><span class="nx">y</span> <span class="o">+</span> <span class="nx">q1</span><span class="p">.</span><span class="nx">z</span><span class="o">*</span><span class="nx">q2</span><span class="p">.</span><span class="nx">z</span> <span class="o">+</span> <span class="nx">q1</span><span class="p">.</span><span class="nx">w</span><span class="o">*</span><span class="nx">q2</span><span class="p">.</span><span class="nx">w</span><span class="p">;</span>
    
    <span class="c1">// If dot &lt; 0, quaternions are on opposite hemispheres</span>
    <span class="c1">// Negate one quaternion to take the shorter path</span>
    <span class="k">if </span><span class="p">(</span><span class="nx">dot</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">q2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Quaternion</span><span class="p">(</span><span class="o">-</span><span class="nx">q2</span><span class="p">.</span><span class="nx">x</span><span class="p">,</span> <span class="o">-</span><span class="nx">q2</span><span class="p">.</span><span class="nx">y</span><span class="p">,</span> <span class="o">-</span><span class="nx">q2</span><span class="p">.</span><span class="nx">z</span><span class="p">,</span> <span class="o">-</span><span class="nx">q2</span><span class="p">.</span><span class="nx">w</span><span class="p">);</span>
        <span class="nx">dot</span> <span class="o">=</span> <span class="o">-</span><span class="nx">dot</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="c1">// Clamp dot to avoid numerical issues</span>
    <span class="nx">dot</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">min</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nf">max</span><span class="p">(</span><span class="nx">dot</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="mi">1</span><span class="p">);</span>
    
    <span class="c1">// Use linear interpolation for very close quaternions</span>
    <span class="k">if </span><span class="p">(</span><span class="nx">dot</span> <span class="o">&gt;</span> <span class="mf">0.9995</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nc">Quaternion</span><span class="p">(</span>
            <span class="nx">q1</span><span class="p">.</span><span class="nx">x</span> <span class="o">+</span> <span class="nx">t</span> <span class="o">*</span> <span class="p">(</span><span class="nx">q2</span><span class="p">.</span><span class="nx">x</span> <span class="o">-</span> <span class="nx">q1</span><span class="p">.</span><span class="nx">x</span><span class="p">),</span>
            <span class="nx">q1</span><span class="p">.</span><span class="nx">y</span> <span class="o">+</span> <span class="nx">t</span> <span class="o">*</span> <span class="p">(</span><span class="nx">q2</span><span class="p">.</span><span class="nx">y</span> <span class="o">-</span> <span class="nx">q1</span><span class="p">.</span><span class="nx">y</span><span class="p">),</span>
            <span class="nx">q1</span><span class="p">.</span><span class="nx">z</span> <span class="o">+</span> <span class="nx">t</span> <span class="o">*</span> <span class="p">(</span><span class="nx">q2</span><span class="p">.</span><span class="nx">z</span> <span class="o">-</span> <span class="nx">q1</span><span class="p">.</span><span class="nx">z</span><span class="p">),</span>
            <span class="nx">q1</span><span class="p">.</span><span class="nx">w</span> <span class="o">+</span> <span class="nx">t</span> <span class="o">*</span> <span class="p">(</span><span class="nx">q2</span><span class="p">.</span><span class="nx">w</span> <span class="o">-</span> <span class="nx">q1</span><span class="p">.</span><span class="nx">w</span><span class="p">)</span>
        <span class="p">).</span><span class="nf">normalize</span><span class="p">();</span>
    <span class="p">}</span>
    
    <span class="c1">// Standard SLERP</span>
    <span class="kd">const</span> <span class="nx">theta</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">acos</span><span class="p">(</span><span class="nx">dot</span><span class="p">);</span>
    <span class="kd">const</span> <span class="nx">sinTheta</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">sin</span><span class="p">(</span><span class="nx">theta</span><span class="p">);</span>
    <span class="kd">const</span> <span class="nx">scale1</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">sin</span><span class="p">((</span><span class="mi">1</span><span class="o">-</span><span class="nx">t</span><span class="p">)</span> <span class="o">*</span> <span class="nx">theta</span><span class="p">)</span> <span class="o">/</span> <span class="nx">sinTheta</span><span class="p">;</span>
    <span class="kd">const</span> <span class="nx">scale2</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">sin</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span> <span class="nx">theta</span><span class="p">)</span> <span class="o">/</span> <span class="nx">sinTheta</span><span class="p">;</span>
    
    <span class="k">return</span> <span class="k">new</span> <span class="nc">Quaternion</span><span class="p">(</span>
        <span class="nx">scale1</span> <span class="o">*</span> <span class="nx">q1</span><span class="p">.</span><span class="nx">x</span> <span class="o">+</span> <span class="nx">scale2</span> <span class="o">*</span> <span class="nx">q2</span><span class="p">.</span><span class="nx">x</span><span class="p">,</span>
        <span class="nx">scale1</span> <span class="o">*</span> <span class="nx">q1</span><span class="p">.</span><span class="nx">y</span> <span class="o">+</span> <span class="nx">scale2</span> <span class="o">*</span> <span class="nx">q2</span><span class="p">.</span><span class="nx">y</span><span class="p">,</span>
        <span class="nx">scale1</span> <span class="o">*</span> <span class="nx">q1</span><span class="p">.</span><span class="nx">z</span> <span class="o">+</span> <span class="nx">scale2</span> <span class="o">*</span> <span class="nx">q2</span><span class="p">.</span><span class="nx">z</span><span class="p">,</span>
        <span class="nx">scale1</span> <span class="o">*</span> <span class="nx">q1</span><span class="p">.</span><span class="nx">w</span> <span class="o">+</span> <span class="nx">scale2</span> <span class="o">*</span> <span class="nx">q2</span><span class="p">.</span><span class="nx">w</span>
    <span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="common-pitfalls-and-how-to-avoid-them">Common Pitfalls and How to Avoid Them</h3> <p><strong>1. Forgetting to Normalize</strong></p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// BAD: Quaternions drift over time</span>
<span class="kd">let</span> <span class="nx">rotation</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Quaternion</span><span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">);</span>
<span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">rotation</span> <span class="o">=</span> <span class="nx">rotation</span><span class="p">.</span><span class="nf">multiply</span><span class="p">(</span><span class="nx">deltaRotation</span><span class="p">);</span> <span class="c1">// Gets denormalized!</span>
<span class="p">}</span>

<span class="c1">// GOOD: Regular normalization</span>
<span class="kd">let</span> <span class="nx">rotation</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Quaternion</span><span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">);</span>
<span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">rotation</span> <span class="o">=</span> <span class="nx">rotation</span><span class="p">.</span><span class="nf">multiply</span><span class="p">(</span><span class="nx">deltaRotation</span><span class="p">).</span><span class="nf">normalize</span><span class="p">();</span> <span class="c1">// Stays unit length</span>
<span class="p">}</span>
</code></pre></div></div> <p><strong>2. Wrong Multiplication Order</strong></p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// WRONG: q1 * q2 means "apply q1, then q2"</span>
<span class="c1">// But many people think it means "apply q2, then q1"</span>
<span class="kd">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">rotation</span><span class="p">.</span><span class="nf">multiply</span><span class="p">(</span><span class="nx">deltaRotation</span><span class="p">);</span> <span class="c1">// Applies rotation first, then delta</span>

<span class="c1">// Always be explicit about what you mean:</span>
<span class="kd">const</span> <span class="nx">worldToLocal</span> <span class="o">=</span> <span class="nx">parentRotation</span><span class="p">.</span><span class="nf">multiply</span><span class="p">(</span><span class="nx">childRotation</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">localToWorld</span> <span class="o">=</span> <span class="nx">childRotation</span><span class="p">.</span><span class="nf">multiply</span><span class="p">(</span><span class="nx">parentRotation</span><span class="p">);</span>
</code></pre></div></div> <p><strong>3. Interpolating Through the Long Path</strong></p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// This can cause 340° rotation instead of 20°!</span>
<span class="kd">function</span> <span class="nf">badSlerp</span><span class="p">(</span><span class="nx">q1</span><span class="p">,</span> <span class="nx">q2</span><span class="p">,</span> <span class="nx">t</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Missing the dot product check - might take the long way around</span>
    <span class="k">return</span> <span class="nf">slerp</span><span class="p">(</span><span class="nx">q1</span><span class="p">,</span> <span class="nx">q2</span><span class="p">,</span> <span class="nx">t</span><span class="p">);</span> <span class="c1">// Could spin the wrong direction</span>
<span class="p">}</span>

<span class="c1">// Use safeSlerp() function above instead</span>
</code></pre></div></div> <h3 id="integration-with-graphics-apis">Integration with Graphics APIs</h3> <p><strong>WebGL/Three.js:</strong></p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Convert quaternion to Three.js format</span>
<span class="kd">const</span> <span class="nx">threeQuat</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">THREE</span><span class="p">.</span><span class="nc">Quaternion</span><span class="p">(</span><span class="nx">quat</span><span class="p">.</span><span class="nx">x</span><span class="p">,</span> <span class="nx">quat</span><span class="p">.</span><span class="nx">y</span><span class="p">,</span> <span class="nx">quat</span><span class="p">.</span><span class="nx">z</span><span class="p">,</span> <span class="nx">quat</span><span class="p">.</span><span class="nx">w</span><span class="p">);</span>
<span class="nx">mesh</span><span class="p">.</span><span class="nx">quaternion</span><span class="p">.</span><span class="nf">copy</span><span class="p">(</span><span class="nx">threeQuat</span><span class="p">);</span>
</code></pre></div></div> <p><strong>Unity C#:</strong></p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Unity has excellent quaternion support built-in</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">SmoothRotator</span> <span class="p">:</span> <span class="n">MonoBehaviour</span> <span class="p">{</span>
    <span class="k">public</span> <span class="kt">float</span> <span class="n">rotationSpeed</span> <span class="p">=</span> <span class="m">2.0f</span><span class="p">;</span>
    <span class="k">private</span> <span class="n">Quaternion</span> <span class="n">targetRotation</span><span class="p">;</span>
    
    <span class="k">void</span> <span class="nf">Update</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// Smooth rotation using Unity's Slerp</span>
        <span class="n">transform</span><span class="p">.</span><span class="n">rotation</span> <span class="p">=</span> <span class="n">Quaternion</span><span class="p">.</span><span class="nf">Slerp</span><span class="p">(</span>
            <span class="n">transform</span><span class="p">.</span><span class="n">rotation</span><span class="p">,</span>
            <span class="n">targetRotation</span><span class="p">,</span>
            <span class="n">rotationSpeed</span> <span class="p">*</span> <span class="n">Time</span><span class="p">.</span><span class="n">deltaTime</span>
        <span class="p">);</span>
    <span class="p">}</span>
    
    <span class="k">public</span> <span class="k">void</span> <span class="nf">SetTarget</span><span class="p">(</span><span class="n">Vector3</span> <span class="n">direction</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">targetRotation</span> <span class="p">=</span> <span class="n">Quaternion</span><span class="p">.</span><span class="nf">LookRotation</span><span class="p">(</span><span class="n">direction</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="performance-tips">Performance Tips</h3> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Cache expensive operations</span>
<span class="kd">class</span> <span class="nc">RotationCache</span> <span class="p">{</span>
    <span class="nf">constructor</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">cachedMatrix</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">quaternionDirty</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="nf">setRotation</span><span class="p">(</span><span class="nx">quat</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">rotation</span> <span class="o">=</span> <span class="nx">quat</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">quaternionDirty</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span> <span class="c1">// Mark matrix as needing recalculation</span>
    <span class="p">}</span>
    
    <span class="nf">getMatrix</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if </span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">quaternionDirty</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">cachedMatrix</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">rotation</span><span class="p">.</span><span class="nf">toMatrix</span><span class="p">();</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">quaternionDirty</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">cachedMatrix</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// For real-time applications, normalize only when needed</span>
<span class="kd">let</span> <span class="nx">normalizationCounter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kd">function</span> <span class="nf">updateRotation</span><span class="p">(</span><span class="nx">deltaQuat</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">rotation</span> <span class="o">=</span> <span class="nx">rotation</span><span class="p">.</span><span class="nf">multiply</span><span class="p">(</span><span class="nx">deltaQuat</span><span class="p">);</span>
    
    <span class="c1">// Normalize every 10 frames instead of every frame</span>
    <span class="k">if </span><span class="p">(</span><span class="o">++</span><span class="nx">normalizationCounter</span> <span class="o">%</span> <span class="mi">10</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">rotation</span><span class="p">.</span><span class="nf">normalize</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p><strong>The Golden Rule</strong>: Always work with quaternions internally, only convert to Euler angles for human-readable displays or legacy API compatibility. Never interpolate or integrate Euler angles directly!</p> <h2 id="geometric-and-topological-insights">Geometric and Topological Insights</h2> <p>The fundamental advantage of quaternions stems from their natural geometric properties:</p> <p><strong>Lie Group Structure</strong>: Unit quaternions form a Lie group isomorphic to $SU(2)$, with the exponential map providing a natural connection between the Lie algebra (3D angular velocity space) and the group manifold $(S^3)$.</p> <p><strong>Minimal Representation</strong>: While quaternions use four parameters to represent three degrees of freedom, this redundancy is precisely what eliminates singularities. The constraint $||q|| = 1$ reduces the effective dimensionality to three while maintaining global validity.</p> <p><strong>Geodesic Optimality</strong>: SLERP follows geodesics on $S^3$, which project to the shortest rotation paths in $SO(3)$. This ensures both mathematical optimality and physical realism in animation and control systems.</p> <h2 id="practical-applications-and-performance-considerations">Practical Applications and Performance Considerations</h2> <p>The mathematical superiority of quaternions translates directly into practical benefits:</p> <ul> <li><strong>Robust Control Systems</strong>: Elimination of gimbal lock enables reliable attitude control in aerospace applications</li> <li><strong>Smooth Animation</strong>: Constant angular velocity interpolation produces natural-looking rotations in computer graphics</li> <li><strong>Numerical Stability</strong>: Better conditioning of rotation operations reduces accumulation of numerical errors</li> <li><strong>Compact Representation</strong>: Four parameters vs. nine for rotation matrices, with inherent orthogonality constraints</li> </ul> <h2 id="conclusion-mathematical-rigor-in-computational-practice">Conclusion: Mathematical Rigor in Computational Practice</h2> <p>The choice between Euler angles and quaternions is not merely one of computational convenience—it reflects a deeper understanding of the mathematical structure underlying 3D rotations. While Euler angles offer intuitive parameterization for human interfaces, quaternions provide the mathematically principled foundation necessary for robust computational systems.</p> <p>The interactive visualizations demonstrate these theoretical principles through direct manipulation, revealing how mathematical abstractions manifest as concrete computational behaviors. This convergence of theory and practice exemplifies the power of choosing representations that align with the underlying mathematical reality.</p> <hr/> <p><em>Explore the interactive mathematical demonstrations above to develop geometric intuition for these abstract concepts.</em></p> <html lang="en"> <head> <meta charset="UTF-8"/> <meta name="viewport" content="width=device-width, initial-scale=1.0"/> <title>3D Rotations: Understanding Gimbal Lock</title> <style>body{margin:0;padding:20px;font-family:'Segoe UI',system-ui,sans-serif;background:linear-gradient(135deg,#0f0f23 0%,#1a1a2e 50%,#16213e 100%);color:#e0e0e0;min-height:100vh}.container{max-width:1400px;margin:0 auto}.header{text-align:center;margin-bottom:30px}.header h1{font-size:2.5rem;background:linear-gradient(135deg,#64ffda,#7c4dff);-webkit-background-clip:text;-webkit-text-fill-color:transparent;margin-bottom:10px}.header p{font-size:1.1rem;opacity:.8;max-width:800px;margin:0 auto}.visualization-grid{display:grid;grid-template-columns:1fr 1fr;gap:20px;margin-bottom:30px}.wide-panel{grid-column:1 / -1}.panel{background:rgba(255,255,255,0.05);backdrop-filter:blur(10px);border-radius:15px;border:1px solid rgba(255,255,255,0.1);padding:20px;position:relative;overflow:hidden}.panel h3{margin:0 0 15px 0;font-size:1.3rem;color:#64ffda;display:flex;align-items:center;gap:10px}.canvas-container{position:relative;width:100%;height:400px;border-radius:10px;overflow:hidden;background:#000}canvas{display:block;width:100%;height:100%}.controls{margin-top:15px;display:grid;grid-template-columns:repeat(auto-fit,minmax(200px,1fr));gap:15px}.control-group{display:flex;flex-direction:column;gap:8px}.control-group label{font-size:.9rem;color:#b0b0b0;font-weight:500}.slider{-webkit-appearance:none;appearance:none;width:100%;height:6px;border-radius:3px;background:rgba(255,255,255,0.1);outline:0}.slider::-webkit-slider-thumb{-webkit-appearance:none;appearance:none;width:18px;height:18px;border-radius:50%;background:#64ffda;cursor:pointer;box-shadow:0 0 10px rgba(100,255,218,0.3)}.value-display{font-family:'Courier New',monospace;color:#64ffda;font-weight:bold}.warning{background:rgba(255,107,107,0.15);border:1px solid rgba(255,107,107,0.3);border-radius:8px;padding:12px;margin-top:10px;color:#ff6b6b;font-weight:bold;display:none}.warning.active{display:block;animation:pulse 1s ease-in-out infinite alternate}@keyframes pulse{from{opacity:.7}to{opacity:1}}.button{background:linear-gradient(135deg,#7c4dff,#536dfe);border:0;border-radius:8px;padding:10px 20px;color:white;font-weight:bold;cursor:pointer;transition:all .3s ease}.button:hover{transform:translateY(-2px);box-shadow:0 5px 15px rgba(124,77,255,0.4)}.info-box{background:rgba(100,255,218,0.1);border:1px solid rgba(100,255,218,0.3);border-radius:8px;padding:15px;margin-top:15px;font-size:.9rem;line-height:1.5}.quaternion-display{display:grid;grid-template-columns:repeat(4,1fr);gap:10px;margin-top:10px}.quat-component{text-align:center;padding:8px;background:rgba(255,255,255,0.05);border-radius:6px;font-family:'Courier New',monospace}.quat-component .label{font-size:.8rem;opacity:.7;margin-bottom:4px}.quat-component .value{font-weight:bold;color:#64ffda}.hopf-info-panel{background:rgba(100,255,218,0.1);border:1px solid rgba(100,255,218,0.3);border-radius:8px;padding:15px;margin:10px 0;font-size:.9rem;line-height:1.5}.hopf-info-panel h4{margin:0 0 10px 0;font-size:1.1rem;color:#64ffda}.hopf-info-panel p{margin:5px 0;color:#e0e0e0}</style> </head> <body> <div class="container"> </div> <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/TrackballControls.js"></script> <script>function createHopfBaseSphere(){const e=new THREE.SphereGeometry(hopfParams.baseSphereSize,32,32),t=new THREE.MeshPhongMaterial({color:2201331,transparent:!0,opacity:.3,wireframe:!1});hopfBaseSphere&&hopfScene.remove(hopfBaseSphere),hopfBaseSphere=new THREE.Mesh(e,t),hopfScene.add(hopfBaseSphere);const n=new THREE.SphereGeometry(hopfParams.baseSphereSize,16,16),o=new THREE.MeshBasicMaterial({color:4890367,wireframe:!0,transparent:!0,opacity:.6}),a=new THREE.Mesh(n,o);hopfBaseSphere.add(a)}function createHopfFibers(){hopfFibers.forEach(e=>{hopfScene.remove(e),e.geometry&&e.geometry.dispose(),e.material&&e.material.dispose()}),hopfFibers=[];const e=hopfParams.fiberCount;for(let t=0;t<e;t++){const n=t/e*Math.PI;for(let o=0;o<e;o++){const a=o/e*2*Math.PI,r=createHopfFiberCurve({x:Math.sin(n)*Math.cos(a),y:Math.sin(n)*Math.sin(a),z:Math.cos(n)},t,o);hopfScene.add(r),hopfFibers.push(r)}}}function createHopfFiberCurve(e,t,n){const o=[],a=64;for(let t=0;t<=a;t++){const n=stereographicProjectionHopf(hopfFibrationMapping(e,t/a*2*Math.PI+hopfParams.animationPhase));o.push(new THREE.Vector3(n.x,n.y,n.z))}const r=new THREE.CatmullRomCurve3(o,!0),i=new THREE.TubeGeometry(r,a,.02,8,!0),s=.5*(t/hopfParams.fiberCount+n/hopfParams.fiberCount),l=(new THREE.Color).setHSL(s,.8,.6),d=new THREE.MeshPhongMaterial({color:l,transparent:!0,opacity:.8,emissive:l,emissiveIntensity:.2});return new THREE.Mesh(i,d)}function hopfFibrationMapping(e,t){const{x:n,y:o,z:a}=e;return{x:Math.sqrt((1+a)/2)*Math.cos(t),y:Math.sqrt((1+a)/2)*Math.sin(t),z:Math.sqrt((1-a)/2)*Math.cos(Math.atan2(o,n)+t),w:Math.sqrt((1-a)/2)*Math.sin(Math.atan2(o,n)+t)}}function stereographicProjectionHopf(e){const{x:t,y:n,z:o,w:a}=e,r=1-a;if(Math.abs(r)<.001)return{x:0,y:0,z:0};const i=2;return{x:i*t/r,y:i*n/r,z:i*o/r}}function setupHopfMouseControls(){let e=!1,t=0,n=0,o=8,a=0,r=Math.PI/4;hopfRenderer.domElement.addEventListener("mousedown",o=>{e=!0,t=o.clientX,n=o.clientY}),hopfRenderer.domElement.addEventListener("mouseup",()=>{e=!1}),hopfRenderer.domElement.addEventListener("mousemove",i=>{if(!e)return;const s=i.clientX-t,l=i.clientY-n;a-=.01*s,r=Math.max(.1,Math.min(Math.PI-.1,r+.01*l)),hopfCamera.position.x=o*Math.sin(r)*Math.cos(a),hopfCamera.position.y=o*Math.cos(r),hopfCamera.position.z=o*Math.sin(r)*Math.sin(a),hopfCamera.lookAt(0,0,0),t=i.clientX,n=i.clientY}),hopfRenderer.domElement.addEventListener("wheel",e=>{o=Math.max(2,Math.min(20,o+.01*e.deltaY)),hopfCamera.position.x=o*Math.sin(r)*Math.cos(a),hopfCamera.position.y=o*Math.cos(r),hopfCamera.position.z=o*Math.sin(r)*Math.sin(a),hopfCamera.lookAt(0,0,0),e.preventDefault()})}function animateHopfFibration(){if(hopfAnimationId=requestAnimationFrame(animateHopfFibration),hopfIsAnimating){hopfTime+=.01*hopfParams.rotationSpeed,hopfScene.rotation.y=.3*hopfTime,hopfParams.animationPhase=2*hopfTime;const e=document.getElementById("hopfAnimationPhase"),t=document.getElementById("hopfAnimationPhaseValue");e&&t&&(e.value=hopfParams.animationPhase%(2*Math.PI),t.textContent=(hopfParams.animationPhase%(2*Math.PI)).toFixed(2)),Math.floor(60*hopfTime)%3==0&&createHopfFibers()}hopfRenderer.render(hopfScene,hopfCamera)}const MATH_EPSILON=1e-15,QUATERNION_TOLERANCE=1e-12,GEODESIC_RESOLUTION=100,ANTIPODAL_THRESHOLD=.999999,mathAnalysis={unitConstraintViolations:[],geodesicErrors:[],singularityDetections:[],temporalCoherence:[],projectionErrors:[],frameCount:0},qNorm=([e,t,n,o])=>{const a=e*e+t*t+n*n+o*o,r=Math.sqrt(a),i=Math.abs(r-1);if(i>QUATERNION_TOLERANCE&&mathAnalysis.unitConstraintViolations.push({frame:mathAnalysis.frameCount,originalNorm:r,error:i,quaternion:[e,t,n,o]}),r<MATH_EPSILON)return console.warn("Mathematical Analysis: Degenerate quaternion detected, defaulting to identity"),[0,0,0,1];const s=1/r,l=[e*s,t*s,n*s,o*s],d=Math.sqrt(l[0]*l[0]+l[1]*l[1]+l[2]*l[2]+l[3]*l[3]),c=Math.abs(d-1);return c>QUATERNION_TOLERANCE&&console.error("Mathematical Analysis: Post-normalization error:",c),l},qMul=([e,t,n,o],[a,r,i,s])=>{const l=[o*a+e*s+t*i-n*r,o*r-e*i+t*s+n*a,o*i+e*r-t*a+n*s,o*s-e*a-t*r-n*i],d=Math.sqrt(e*e+t*t+n*n+o*o),c=Math.sqrt(a*a+r*r+i*i+s*s),h=Math.sqrt(l[0]*l[0]+l[1]*l[1]+l[2]*l[2]+l[3]*l[3]),u=d*c,m=Math.abs(h-u);return m>QUATERNION_TOLERANCE&&console.warn("Mathematical Analysis: Quaternion multiplication norm error:",m),l},qFromAxisAngle=([e,t,n],o)=>{const a=Math.sin(o/2);return qNorm([e*a,t*a,n*a,Math.cos(o/2)])},qFromEulerZYX=(e,t,n)=>{const o=Math.cos(e/2),a=Math.sin(e/2),r=Math.cos(t/2),i=Math.sin(t/2),s=Math.cos(n/2),l=Math.sin(n/2);return qNorm([l*r*o-s*i*a,s*i*o+l*r*a,s*r*a-l*i*o,s*r*o+l*i*a])},geodesicDistance=(e,t)=>{let n=Math.abs(e[0]*t[0]+e[1]*t[1]+e[2]*t[2]+e[3]*t[3]);return n=Math.min(1,Math.max(-1,n)),Math.acos(n)},analyzeAntipodalPoints=e=>{const[t,n,o,a]=e,r=[-t,-n,-o,-a],i=qToMatrix(e),s=qToMatrix(r);let l=0;for(let e=0;e<16;e++){const t=Math.abs(i[e]-s[e]);l=Math.max(l,t)}const d=t*-t+n*-n+o*-o+a*-a,c=Math.min(1,Math.max(-1,d)),h=Math.acos(c),u=Math.PI,m=Math.abs(h-u);return{q:e,antipodal:r,geodesicDistance:h,geodesicError:m,dotProduct:d,dotProductError:Math.abs(d- -1),rotationMatrixError:l,isValidAntipodal:m<100*QUATERNION_TOLERANCE&&l<10*QUATERNION_TOLERANCE}},qSlerp=(e,t,n)=>{(n<0||n>1)&&console.warn("Mathematical Analysis: SLERP parameter t outside [0,1]:",n);const o=qNorm(e),a=qNorm(t);let[r,i,s,l]=o,[d,c,h,u]=a,m=r*d+i*c+s*h+l*u;const p=m;m<0&&(m=-m,d=-d,c=-c,h=-h,u=-u);const E=Math.acos(Math.min(1,Math.abs(p)));if(mathAnalysis.geodesicErrors.push({frame:mathAnalysis.frameCount,geodesicAngle:E,dotProduct:p,shortestPath:m>Math.abs(p)}),m>.9995){const e=qNorm([r+n*(d-r),i+n*(c-i),s+n*(h-s),l+n*(u-l)]),t=qSlerp(o,a,.5),m=geodesicDistance(o,t),p=geodesicDistance(t,a),E=Math.abs(m-p);return E>QUATERNION_TOLERANCE&&console.warn("Mathematical Analysis: SLERP velocity consistency error:",E),e}if(m<.001){console.log("Mathematical Analysis: Handling antipodal quaternions with non-recursive method");const e=qNorm([r+n*(d-r),i+n*(c-i),s+n*(h-s),l+n*(u-l)]);return mathAnalysis.geodesicErrors.push({frame:mathAnalysis.frameCount,type:"antipodal-nlerp-fallback",t:n,originalDot:p,message:"Used NLERP for antipodal quaternions to avoid recursion"}),e}const f=Math.acos(Math.min(1,m)),g=Math.sin(f);if(Math.abs(g)<MATH_EPSILON)return console.warn("Mathematical Analysis: SLERP numerical instability detected"),qNorm([r+n*(d-r),i+n*(c-i),s+n*(h-s),l+n*(u-l)]);const y=Math.sin((1-n)*f)/g,M=Math.sin(n*f)/g,S=[r*y+d*M,i*y+c*M,s*y+h*M,l*y+u*M],T=Math.sqrt(S[0]*S[0]+S[1]*S[1]+S[2]*S[2]+S[3]*S[3]),w=Math.abs(T-1);if(w>QUATERNION_TOLERANCE&&console.warn("Mathematical Analysis: SLERP result not on unit sphere:",w),n>0&&n<1){const e=geodesicDistance(o,a),t=geodesicDistance(o,S),r=n*e,i=Math.abs(t-r);i>10*QUATERNION_TOLERANCE&&mathAnalysis.geodesicErrors.push({frame:mathAnalysis.frameCount,t:n,geodesicLinearityError:i,distTotal:e,distPartial:t})}return S},qToMatrix=([e,t,n,o])=>{const a=e*e,r=t*t,i=n*n,s=e*t,l=e*n,d=e*o,c=t*n,h=t*o,u=n*o;return[1-2*(r+i),2*(s-u),2*(l+h),0,2*(s+u),1-2*(a+i),2*(c-d),0,2*(l-h),2*(c+d),1-2*(a+r),0,0,0,0,1]},qToEulerZYX=([e,t,n,o])=>{const a=2*(o*e+t*n),r=1-2*(e*e+t*t),i=Math.atan2(a,r),s=2*(o*t-n*e),l=Math.abs(s)>=1?Math.sign(s)*Math.PI/2:Math.asin(s),d=2*(o*n+e*t),c=1-2*(t*t+n*n);return[Math.atan2(d,c),l,i]},qConj=([e,t,n,o])=>{const a=[-e,-t,-n,o],r=Math.sqrt(e*e+t*t+n*n+o*o),i=Math.sqrt(e*e+t*t+n*n+o*o),s=Math.abs(r-i);return s>QUATERNION_TOLERANCE&&console.warn("Mathematical Analysis: Conjugate norm error:",s),a},qDot=(e,t)=>{const n=e[0]*t[0]+e[1]*t[1]+e[2]*t[2]+e[3]*t[3];return Math.abs(n)>1+QUATERNION_TOLERANCE&&console.warn("Mathematical Analysis: Dot product outside [-1,1]:",n),n},qToAxisAngle=([e,t,n,o])=>{let a=e,r=t,i=n,s=o;o<0&&(a=-e,r=-t,i=-n,s=-o);const l=2*Math.acos(Math.min(1,Math.max(-1,s)));if(Math.abs(l)<MATH_EPSILON)return[[1,0,0],0];const d=Math.sin(l/2);if(Math.abs(d)<MATH_EPSILON)return mathAnalysis.singularityDetections.push({frame:mathAnalysis.frameCount,type:"axis-angle-extraction",quaternion:[e,t,n,o],angle:l,sinHalfAngle:d}),[[1,0,0],l];let c=[a/d,r/d,i/d];const h=Math.sqrt(c[0]*c[0]+c[1]*c[1]+c[2]*c[2]);h>MATH_EPSILON&&(c=[c[0]/h,c[1]/h,c[2]/h]);const u=Math.abs(h-1);return u>10*QUATERNION_TOLERANCE&&console.warn("Mathematical Analysis: Non-unit rotation axis:",u),[c,l]},verifyDoubleCover=e=>{const[t,n,o,a]=e,r=[-t,-n,-o,-a],i=qToMatrix(e),s=qToMatrix(r);let l=0;for(let e=0;e<16;e++){const t=i[e]-s[e];l+=t*t}l=Math.sqrt(l);const d=l;return d>QUATERNION_TOLERANCE&&(console.error("Mathematical Analysis: Double cover violation:",d),mathAnalysis.geodesicErrors.push({frame:mathAnalysis.frameCount,type:"double-cover-violation",error:d,quaternion:e})),{isValid:d<QUATERNION_TOLERANCE,error:d,rotationMatrix1:i,rotationMatrix2:s}},verifySO3Properties=e=>{const t=e,n=[];for(let e=0;e<3;e++)for(let o=0;o<3;o++){let a=0;for(let n=0;n<3;n++)a+=t[4*n+e]*t[4*n+o];n[3*e+o]=a}let o=0;for(let e=0;e<3;e++)for(let t=0;t<3;t++){const a=e===t?1:0,r=Math.abs(n[3*e+t]-a);o=Math.max(o,r)}const a=t[0]*(t[5]*t[10]-t[6]*t[9])-t[1]*(t[4]*t[10]-t[6]*t[8])+t[2]*(t[4]*t[9]-t[5]*t[8]),r=Math.abs(a-1);return{isValidSO3:o<QUATERNION_TOLERANCE&&r<QUATERNION_TOLERANCE,orthogonalityError:o,determinantError:r,determinant:a}},stereographicProjection=(e,t="north")=>{const[n,o,a,r]=qNorm(e);let i,s,l=0;if("north"===t)if(Math.abs(1-r)<MATH_EPSILON){const e=2/(1+MATH_EPSILON);i=n*e,s=o*e,l=MATH_EPSILON}else{const t=1-r;i=n/t,s=o/t,Math.abs(t)<QUATERNION_TOLERANCE&&(l=Math.abs(t),mathAnalysis.projectionErrors.push({frame:mathAnalysis.frameCount,type:"stereographic-singularity",quaternion:e,denominator:t,error:l}))}else if(Math.abs(1+r)<MATH_EPSILON){const e=2/(1+MATH_EPSILON);i=n*e,s=o*e,l=MATH_EPSILON}else{const e=1+r;i=n/e,s=o/e,Math.abs(e)<QUATERNION_TOLERANCE&&(l=Math.abs(e))}return{x:i,y:s,error:l,isValid:l<QUATERNION_TOLERANCE}},analyzeTemporalCoherence=(e,t,n)=>{if(!t)return null;const o=qNorm(e),a=qNorm(t),r=qMul(o,qConj(a)),[i,s]=qToAxisAngle(r),l=s/n,d=[-o[0],-o[1],-o[2],-o[3]],c=[-a[0],-a[1],-a[2],-a[3]],h=qMul(d,qConj(c)),[u,m]=qToAxisAngle(h),p=m/n,E=Math.abs(l-p),f=Math.acos(Math.min(1,Math.abs(i[0]*u[0]+i[1]*u[1]+i[2]*u[2]))),g={frame:mathAnalysis.frameCount,angularVelocity:l,antipodalAngularVelocity:p,velocityCoherenceError:E,axisCoherenceError:f,isCoherent:E<QUATERNION_TOLERANCE&&f<QUATERNION_TOLERANCE};return mathAnalysis.temporalCoherence.push(g),g};let heatmapCtx,slerpVelocityCtx,slerpScene,slerpCamera,slerpRenderer,slerpControls,slerpSphere,slerpPathLine,eulerPathLine,slerpCurrentPoint,eulerCurrentPoint,currentQuaternion=[0,0,0,1],sphereQuaternion=[0,0,0,1],sphereEuler=[0,0,0],showAntipodes=!1,showGeodesicArc=!1,animating=!1,quaternionHistory=[[0,0,0,1]],frameCount=0,showTorusView=!0,updatingFromSlider=!1;const deg2rad=e=>e*Math.PI/180,rad2deg=e=>180*e/Math.PI,resizeCanvases=()=>{[document.getElementById("quaternionCanvas"),document.getElementById("heatmapCanvas"),document.getElementById("slerpVelocityCanvas")].forEach(e=>{if(e){const t=e.parentElement.getBoundingClientRect();e.width=t.width*window.devicePixelRatio,e.height=t.height*window.devicePixelRatio,e.style.width=t.width+"px",e.style.height=t.height+"px";const n=e.getContext("2d");n&&n.scale(window.devicePixelRatio,window.devicePixelRatio)}})};let scene,camera,renderer,controls,centerSphere,quaternionScene,quaternionCamera,quaternionRenderer,quaternionControls,quaternionSphere,quaternionPoint,antipodalPoint,geodesicCurve,gimbalRings=[],coordinateAxes=[];const initThreeJS=()=>{const e=document.getElementById("gimbalCanvas"),t=e.clientWidth,n=e.clientHeight;scene=new THREE.Scene,scene.background=new THREE.Color(0),camera=new THREE.PerspectiveCamera(75,t/n,.1,1e3),camera.position.set(3,2,4),renderer=new THREE.WebGLRenderer({canvas:e,antialias:!0}),renderer.setSize(t,n),renderer.setPixelRatio(window.devicePixelRatio),renderer.shadowMap.enabled=!0,renderer.shadowMap.type=THREE.PCFSoftShadowMap,controls=new THREE.TrackballControls(camera,renderer.domElement),controls.rotateSpeed=1.5,controls.zoomSpeed=1.2,controls.panSpeed=.8,controls.noZoom=!1,controls.noPan=!1,controls.staticMoving=!0,controls.dynamicDampingFactor=.3,controls.keys=[65,83,68],controls.minDistance=2,controls.maxDistance=8;const o=new THREE.AmbientLight(4210752,.4);scene.add(o);const a=new THREE.DirectionalLight(16777215,.8);a.position.set(5,5,5),a.castShadow=!0,a.shadow.mapSize.width=2048,a.shadow.mapSize.height=2048,scene.add(a);const r=new THREE.PointLight(6619098,.3,100);r.position.set(-3,3,-3),scene.add(r),createGimbalRings(),createCoordinateAxes(),createCenterSphere();const i=new THREE.GridHelper(4,20,3355443,1118481);i.position.y=-2,scene.add(i),animate()},createGimbalRings=()=>{const e=new THREE.Group,t=new THREE.Group,n=new THREE.Group;scene.add(e),e.add(t),t.add(n);[{radius:1.8,tube:.08,color:6619098,name:"yaw",group:e},{radius:1.4,tube:.06,color:5025616,name:"pitch",group:t},{radius:1,tube:.04,color:16750592,name:"roll",group:n}].forEach((e,t)=>{const n=new THREE.TorusGeometry(e.radius,e.tube,16,100);let o;o=0===t?new THREE.ShaderMaterial({uniforms:{color1:{value:new THREE.Color(6619098)},color2:{value:new THREE.Color(2001125)}},vertexShader:"\n                            varying vec3 vPosition;\n                            void main() {\n                                vPosition = position;\n                                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n                            }\n                        ",fragmentShader:"\n                            uniform vec3 color1;\n                            uniform vec3 color2;\n                            varying vec3 vPosition;\n                            void main() {\n                                float mixFactor = (atan(vPosition.y, vPosition.x) + 3.14159) / (2.0 * 3.14159);\n                                vec3 color = mix(color1, color2, mixFactor);\n                                gl_FragColor = vec4(color, 0.9);\n                            }\n                        ",transparent:!0}):new THREE.MeshPhongMaterial({color:e.color,shininess:100,transparent:!0,opacity:.8});const a=new THREE.Mesh(n,o);a.castShadow=!0,a.receiveShadow=!0,a.userData={name:e.name,originalColor:e.color,group:e.group},0===t||(1===t?a.rotation.x=Math.PI/2:2===t&&(a.rotation.z=Math.PI/2)),e.group.add(a),gimbalRings.push(a);const r=new THREE.SphereGeometry(.05,8,8),i=new THREE.MeshPhongMaterial({color:16777215,emissive:e.color,emissiveIntensity:.3}),s=0===t?8:4;for(let n=0;n<s;n++){const o=n/s*Math.PI*2,a=new THREE.Mesh(r,i);0===t?(a.position.set(e.radius*Math.cos(o),e.radius*Math.sin(o),0),0===n?(a.material=a.material.clone(),a.material.color.setHex(65535),a.material.emissive.setHex(65535),a.material.emissiveIntensity=.5,a.scale.set(1.5,1.5,1.5)):n===s/2&&(a.material=a.material.clone(),a.material.color.setHex(26214),a.material.emissive.setHex(13107))):1===t?a.position.set(e.radius*Math.cos(o),0,e.radius*Math.sin(o)):2===t&&a.position.set(0,e.radius*Math.cos(o),e.radius*Math.sin(o)),a.castShadow=!0,e.group.add(a)}if(0===t){const t=new THREE.BoxGeometry(.3*e.radius,.15,.15),n=new THREE.MeshPhongMaterial({color:65535,emissive:65535,emissiveIntensity:.3,shininess:100}),o=new THREE.Mesh(t,n);o.position.set(e.radius,0,0),o.castShadow=!0,e.group.add(o);const a=new THREE.Mesh(t,n.clone());a.material.color.setHex(16711935),a.material.emissive.setHex(16711935),a.position.set(-e.radius,0,0),a.castShadow=!0,e.group.add(a)}const l=new THREE.Group,d=0===t?.06:.03,c=0===t?.2:.12,h=new THREE.ConeGeometry(d,c,8),u=new THREE.MeshPhongMaterial({color:e.color,emissive:e.color,emissiveIntensity:.4}),m=new THREE.Mesh(h,u);if(0===t){m.position.set(e.radius+.25,0,0),m.rotation.z=-Math.PI/2;const t=new THREE.Mesh(h,u);t.position.set(-e.radius-.25,0,0),t.rotation.z=Math.PI/2,l.add(t);const n=document.createElement("canvas");n.width=128,n.height=64;const o=n.getContext("2d");o.fillStyle="#64ffda",o.font="bold 24px Arial",o.fillText("YAW",30,40);const a=new THREE.CanvasTexture(n),r=new THREE.SpriteMaterial({map:a,opacity:.8}),i=new THREE.Sprite(r);i.position.set(0,0,e.radius+.5),i.scale.set(.5,.25,1),e.group.add(i)}else 1===t?(m.position.set(e.radius+.15,0,0),m.rotation.y=Math.PI/2,m.rotation.z=-Math.PI/2):2===t&&(m.position.set(0,e.radius+.15,0),m.rotation.x=Math.PI/2);if(l.add(m),e.group.add(l),0===t){const t=new THREE.BufferGeometry,n=new Float32Array([0,0,-.5,0,0,.5]);t.setAttribute("position",new THREE.BufferAttribute(n,3));const o=new THREE.LineBasicMaterial({color:6619098,linewidth:3,opacity:.5,transparent:!0}),a=new THREE.Line(t,o);e.group.add(a)}}),gimbalRings.yawGroup=e,gimbalRings.pitchGroup=t,gimbalRings.rollGroup=n},createCoordinateAxes=()=>{const e=1.5;[{color:16729156,direction:new THREE.Vector3(1,0,0),label:"X"},{color:4521796,direction:new THREE.Vector3(0,1,0),label:"Y"},{color:4474111,direction:new THREE.Vector3(0,0,1),label:"Z"}].forEach(t=>{const n=new THREE.ArrowHelper(t.direction,new THREE.Vector3(0,0,0),e,t.color,.2,.1);n.line.material.linewidth=3,scene.add(n),coordinateAxes.push(n)})},createCenterSphere=()=>{const e=new THREE.SphereGeometry(.05,32,32),t=new THREE.MeshPhongMaterial({color:16777215,shininess:100,emissive:2236962});centerSphere=new THREE.Mesh(e,t),centerSphere.castShadow=!0,scene.add(centerSphere)},updateGimbalFromSliders=()=>{const e=deg2rad(parseFloat(document.getElementById("yawSlider").value)),t=deg2rad(parseFloat(document.getElementById("pitchSlider").value)),n=deg2rad(parseFloat(document.getElementById("rollSlider").value)),o=Math.abs(Math.cos(t))<.15;if(gimbalRings.yawGroup&&gimbalRings.pitchGroup&&gimbalRings.rollGroup){gimbalRings.yawGroup.rotation.z=e,gimbalRings.pitchGroup.rotation.y=t,gimbalRings.rollGroup.rotation.x=n,gimbalRings.forEach(e=>{e.material.color?(e.material.color.setHex(o?16739179:e.userData.originalColor),e.material.emissive.setHex(o?2228224:0)):e.material.uniforms&&(o?(e.material.uniforms.color1.value.setHex(16739179),e.material.uniforms.color2.value.setHex(16729156)):(e.material.uniforms.color1.value.setHex(6619098),e.material.uniforms.color2.value.setHex(2001125)))});const a=document.getElementById("rollSlider");a&&o?(a.style.borderColor="#ff6b6b",a.style.boxShadow="0 0 5px rgba(255, 107, 107, 0.5)"):a&&(a.style.borderColor="",a.style.boxShadow="")}coordinateAxes.length>=3&&gimbalRings.rollGroup&&coordinateAxes.forEach(e=>{e.parent!==gimbalRings.rollGroup&&(e.parent&&e.parent.remove(e),gimbalRings.rollGroup.add(e))}),document.getElementById("gimbalWarning").classList.toggle("active",o)},animate=()=>{requestAnimationFrame(animate),controls.update(),renderer.render(scene,camera)},resizeThreeJS=()=>{const e=document.getElementById("gimbalCanvas"),t=e.clientWidth,n=e.clientHeight;camera.aspect=t/n,camera.updateProjectionMatrix(),renderer.setSize(t,n)},drawGimbal=()=>{renderer&&(updateGimbalFromSliders(),updateQuaternionSphere3D())},initQuaternionSphere3D=()=>{const e=document.getElementById("quaternionCanvas"),t=e.clientWidth,n=e.clientHeight;quaternionScene=new THREE.Scene,quaternionScene.background=new THREE.Color(17),quaternionCamera=new THREE.PerspectiveCamera(75,t/n,.1,1e3),quaternionCamera.position.set(2.5,1.5,3),quaternionRenderer=new THREE.WebGLRenderer({canvas:e,antialias:!0}),quaternionRenderer.setSize(t,n),quaternionRenderer.setPixelRatio(window.devicePixelRatio),quaternionRenderer.shadowMap.enabled=!0,quaternionRenderer.shadowMap.type=THREE.PCFSoftShadowMap,quaternionControls=new THREE.TrackballControls(quaternionCamera,quaternionRenderer.domElement),quaternionControls.rotateSpeed=1,quaternionControls.zoomSpeed=1.2,quaternionControls.panSpeed=.8,quaternionControls.noZoom=!1,quaternionControls.noPan=!1,quaternionControls.staticMoving=!0,quaternionControls.dynamicDampingFactor=.3,quaternionControls.minDistance=1.5,quaternionControls.maxDistance=6;const o=new THREE.AmbientLight(4210752,.6);quaternionScene.add(o);const a=new THREE.DirectionalLight(6619098,.8);a.position.set(3,3,3),a.castShadow=!0,quaternionScene.add(a);const r=new THREE.PointLight(8146431,.4,100);r.position.set(-2,2,-2),quaternionScene.add(r);const i=new THREE.SphereGeometry(1,32,32),s=new THREE.MeshPhongMaterial({color:11184810,wireframe:!0,transparent:!0,opacity:.6});quaternionSphere=new THREE.Mesh(i,s),quaternionScene.add(quaternionSphere);const l=new THREE.MeshPhongMaterial({color:1118515,transparent:!0,opacity:.1}),d=new THREE.Mesh(i,l);quaternionScene.add(d);const c=new THREE.SphereGeometry(.05,16,16),h=new THREE.MeshPhongMaterial({color:6619098,emissive:6619098,emissiveIntensity:.3});quaternionPoint=new THREE.Mesh(c,h),quaternionScene.add(quaternionPoint);const u=new THREE.MeshPhongMaterial({color:16739179,emissive:16739179,emissiveIntensity:.3});antipodalPoint=new THREE.Mesh(c,u),antipodalPoint.visible=!1,quaternionScene.add(antipodalPoint);const m=1.3;[{color:16729156,direction:new THREE.Vector3(1,0,0),label:"X"},{color:4521796,direction:new THREE.Vector3(0,1,0),label:"Y"},{color:4474111,direction:new THREE.Vector3(0,0,1),label:"Z"}].forEach(e=>{const t=new THREE.ArrowHelper(e.direction,new THREE.Vector3(0,0,0),m,e.color,.1,.05);t.line.material.linewidth=2,quaternionScene.add(t)});const p=new THREE.GridHelper(2,10,3355443,1118481);p.position.y=-1.2,quaternionScene.add(p);const E=()=>{requestAnimationFrame(E),quaternionControls.update(),quaternionRenderer.render(quaternionScene,quaternionCamera)};E()};let hopfScene,hopfCamera,hopfRenderer,hopfBaseSphere,hopfAnimationId,hopfFibers=[],hopfIsAnimating=!0,hopfTime=0,hopfParams={rotationSpeed:.5,fiberCount:16,animationPhase:0,baseSphereSize:1};const initHopfFibration3D=()=>{const e=document.getElementById("hopfCanvas"),t=e.clientWidth,n=e.clientHeight;hopfScene=new THREE.Scene,hopfScene.background=new THREE.Color(0),hopfCamera=new THREE.PerspectiveCamera(75,t/n,.1,1e3),hopfCamera.position.set(5,3,5),hopfCamera.lookAt(0,0,0),hopfRenderer=new THREE.WebGLRenderer({canvas:e,antialias:!0}),hopfRenderer.setSize(t,n),hopfRenderer.setPixelRatio(window.devicePixelRatio),hopfRenderer.shadowMap.enabled=!0,hopfRenderer.shadowMap.type=THREE.PCFSoftShadowMap;const o=new THREE.AmbientLight(4210752,.3);hopfScene.add(o);const a=new THREE.DirectionalLight(16777215,.8);a.position.set(5,5,5),a.castShadow=!0,hopfScene.add(a);const r=new THREE.PointLight(4890367,.6);r.position.set(-5,3,2),hopfScene.add(r);const i=new THREE.PointLight(54527,.4);i.position.set(5,-3,-2),hopfScene.add(i),createHopfBaseSphere(),createHopfFibers(),setupHopfMouseControls(),animateHopfFibration()},resizeHopfVisualization=()=>{if(!hopfRenderer)return;const e=document.getElementById("hopfCanvas"),t=e.clientWidth,n=e.clientHeight;hopfCamera.aspect=t/n,hopfCamera.updateProjectionMatrix(),hopfRenderer.setSize(t,n)},updateQuaternionSphere3D=()=>{if(!quaternionScene||!quaternionPoint)return;const[e,t,n,o]=sphereQuaternion;let a=e,r=t,i=n+.3*o;const s=Math.sqrt(a*a+r*r+i*i);if(s>1e-10){const e=1/s;if(quaternionPoint.position.set(a*e,r*e,i*e),showAntipodes){antipodalPoint.visible=!0;let t=-a*e,n=-r*e,o=-i*e;antipodalPoint.position.set(t,n,o)}else antipodalPoint.visible=!1}else quaternionPoint.position.set(0,0,1),showAntipodes?(antipodalPoint.visible=!0,antipodalPoint.position.set(0,0,-1)):antipodalPoint.visible=!1;quaternionPoint.material.emissiveIntensity=.6,quaternionPoint.scale.setScalar(1),showAntipodes&&(antipodalPoint.material.emissiveIntensity=.6,antipodalPoint.scale.setScalar(1)),updateGeodesicArc3D(),document.getElementById("quatX").textContent=e.toFixed(6),document.getElementById("quatY").textContent=t.toFixed(6),document.getElementById("quatZ").textContent=n.toFixed(6),document.getElementById("quatW").textContent=o.toFixed(6),updatingFromSlider||(document.getElementById("quatXValue").textContent=e.toFixed(3),document.getElementById("quatYValue").textContent=t.toFixed(3),document.getElementById("quatZValue").textContent=n.toFixed(3),document.getElementById("quatWValue").textContent=o.toFixed(3),document.getElementById("quatXSlider").value=e,document.getElementById("quatYSlider").value=t,document.getElementById("quatZSlider").value=n,document.getElementById("quatWSlider").value=o)},updateSphereFromEuler=()=>{if(updatingFromSlider)return;updatingFromSlider=!0;const[e,t,n]=sphereEuler;sphereQuaternion=qNorm(qFromEulerZYX(e,t,n)),document.getElementById("sphereYawValue").textContent=`${rad2deg(e).toFixed(1)}\xb0`,document.getElementById("spherePitchValue").textContent=`${rad2deg(t).toFixed(1)}\xb0`,document.getElementById("sphereRollValue").textContent=`${rad2deg(n).toFixed(1)}\xb0`,document.getElementById("quatXSlider").value=sphereQuaternion[0],document.getElementById("quatYSlider").value=sphereQuaternion[1],document.getElementById("quatZSlider").value=sphereQuaternion[2],document.getElementById("quatWSlider").value=sphereQuaternion[3],document.getElementById("quatXValue").textContent=sphereQuaternion[0].toFixed(3),document.getElementById("quatYValue").textContent=sphereQuaternion[1].toFixed(3),document.getElementById("quatZValue").textContent=sphereQuaternion[2].toFixed(3),document.getElementById("quatWValue").textContent=sphereQuaternion[3].toFixed(3),updateQuaternionSphere3D(),updateHopfVisualization(),updatingFromSlider=!1},updateEulerFromSphere=()=>{updatingFromSlider||(updatingFromSlider=!0,sphereQuaternion=qNorm(sphereQuaternion),sphereEuler=qToEulerZYX(sphereQuaternion),document.getElementById("sphereYawSlider").value=rad2deg(sphereEuler[0]),document.getElementById("spherePitchSlider").value=rad2deg(sphereEuler[1]),document.getElementById("sphereRollSlider").value=rad2deg(sphereEuler[2]),document.getElementById("sphereYawValue").textContent=`${rad2deg(sphereEuler[0]).toFixed(1)}\xb0`,document.getElementById("spherePitchValue").textContent=`${rad2deg(sphereEuler[1]).toFixed(1)}\xb0`,document.getElementById("sphereRollValue").textContent=`${rad2deg(sphereEuler[2]).toFixed(1)}\xb0`,document.getElementById("quatXValue").textContent=sphereQuaternion[0].toFixed(3),document.getElementById("quatYValue").textContent=sphereQuaternion[1].toFixed(3),document.getElementById("quatZValue").textContent=sphereQuaternion[2].toFixed(3),document.getElementById("quatWValue").textContent=sphereQuaternion[3].toFixed(3),document.getElementById("quatXSlider").value=sphereQuaternion[0],document.getElementById("quatYSlider").value=sphereQuaternion[1],document.getElementById("quatZSlider").value=sphereQuaternion[2],document.getElementById("quatWSlider").value=sphereQuaternion[3],updateQuaternionSphere3D(),updateHopfVisualization(),updatingFromSlider=!1)},updateGeodesicArc3D=()=>{if(console.log("updateGeodesicArc3D called, showGeodesicArc:",showGeodesicArc),geodesicCurve&&(quaternionScene.remove(geodesicCurve),geodesicCurve=null),!showGeodesicArc||!quaternionScene)return;const[e,t,n,o]=sphereQuaternion;console.log("Sphere quaternion:",sphereQuaternion);const a=Math.sqrt(e*e+t*t+n*n);let r,i;if(a>1e-10){const o=1/a;r=new THREE.Vector3(e*o,t*o,n*o),i=new THREE.Vector3(-e*o,-t*o,-n*o)}else r=new THREE.Vector3(0,0,1),i=new THREE.Vector3(0,0,-1);console.log("Point1:",r),console.log("Point2:",i);const s=50,l=[],d=(new THREE.Vector3).crossVectors(r,i).normalize(),c=r.angleTo(i);if(console.log("Rotation axis:",d),console.log("Angle between points:",c,"radians =",180*c/Math.PI,"degrees"),c<.01||c>3.13){console.log("Points are too close or opposite, using alternative path");const e=new THREE.Vector3(1,0,0);Math.abs(r.dot(e))>.9&&e.set(0,1,0);for(let t=0;t<=s/2;t++){const n=t/(s/2),o=(new THREE.Vector3).lerpVectors(r,e,n).normalize();l.push(o)}for(let t=1;t<=s/2;t++){const n=t/(s/2),o=(new THREE.Vector3).lerpVectors(e,i,n).normalize();l.push(o)}}else for(let e=0;e<=s;e++){const t=c*(e/s),n=r.clone();n.applyAxisAngle(d,t),l.push(n)}console.log("Created",l.length,"points for geodesic");const h=(new THREE.BufferGeometry).setFromPoints(l),u=new THREE.LineBasicMaterial({color:16766720,linewidth:5,transparent:!1});geodesicCurve=new THREE.Line(h,u),quaternionScene.add(geodesicCurve),console.log("Geodesic arc added to scene")},resizeQuaternionSphere3D=()=>{if(!quaternionRenderer)return;const e=document.getElementById("quaternionCanvas"),t=e.clientWidth,n=e.clientHeight;quaternionCamera.aspect=t/n,quaternionCamera.updateProjectionMatrix(),quaternionRenderer.setSize(t,n)},initSlerpPath3D=()=>{const e=document.getElementById("slerpPathCanvas"),t=e.clientWidth,n=e.clientHeight;slerpScene=new THREE.Scene,slerpScene.background=new THREE.Color(657946),slerpCamera=new THREE.PerspectiveCamera(60,t/n,.1,1e3),slerpCamera.position.set(3.5,2,2.5),slerpCamera.lookAt(0,0,0),slerpRenderer=new THREE.WebGLRenderer({canvas:e,antialias:!0}),slerpRenderer.setSize(t,n),slerpRenderer.setPixelRatio(window.devicePixelRatio),slerpControls=new THREE.TrackballControls(slerpCamera,slerpRenderer.domElement),slerpControls.rotateSpeed=1,slerpControls.zoomSpeed=1.2,slerpControls.panSpeed=.8,slerpControls.minDistance=1.5,slerpControls.maxDistance=5;const o=new THREE.AmbientLight(6316128,.8);slerpScene.add(o);const a=new THREE.DirectionalLight(16777215,1);a.position.set(3,3,3),a.castShadow=!0,slerpScene.add(a);const r=new THREE.DirectionalLight(16777215,.6);r.position.set(-3,2,-3),slerpScene.add(r);const i=new THREE.PointLight(8965375,.5,100);i.position.set(2,3,0),slerpScene.add(i);const s=new THREE.PointLight(16755336,.5,100);s.position.set(-2,-1,2),slerpScene.add(s);const l=new THREE.SphereGeometry(1,24,24),d=new THREE.MeshPhongMaterial({color:6710920,wireframe:!0,transparent:!0,opacity:.3,depthWrite:!1});slerpSphere=new THREE.Mesh(l,d),slerpSphere.renderOrder=1,slerpScene.add(slerpSphere);const c=new THREE.MeshPhongMaterial({color:2236996,transparent:!0,opacity:.1,shininess:50,depthWrite:!1,side:THREE.BackSide}),h=new THREE.Mesh(l,c);h.renderOrder=0,slerpScene.add(h);const u=new THREE.AxesHelper(1.3);slerpScene.add(u);const m=new THREE.SphereGeometry(.06,16,16),p=new THREE.MeshPhongMaterial({color:5025616,emissive:5025616,emissiveIntensity:.5}),E=new THREE.Mesh(m,p);slerpScene.add(E);const f=new THREE.SphereGeometry(.06,16,16),g=new THREE.MeshPhongMaterial({color:16750592,emissive:16750592,emissiveIntensity:.5}),y=new THREE.Mesh(f,g);slerpScene.add(y);const M=new THREE.SphereGeometry(.08,16,16),S=new THREE.MeshPhongMaterial({color:2201331,emissive:2201331,emissiveIntensity:.8});slerpCurrentPoint=new THREE.Mesh(M,S),slerpScene.add(slerpCurrentPoint);const T=new THREE.MeshPhongMaterial({color:16007990,emissive:16007990,emissiveIntensity:.8});eulerCurrentPoint=new THREE.Mesh(M,T),slerpScene.add(eulerCurrentPoint);const w=()=>{requestAnimationFrame(w),slerpControls.update(),updateSlerpPaths3D(),slerpRenderer.render(slerpScene,slerpCamera)};w()},updateSlerpPaths3D=()=>{if(!slerpScene)return;const e=parseFloat(document.getElementById("tSlider").value),t=qToEulerZYX(orientationA),n=qToEulerZYX(orientationB),o=[];slerpScene.children.forEach(e=>{e.geometry&&"TubeGeometry"===e.geometry.type&&o.push(e),e.geometry&&"BufferGeometry"===e.geometry.type&&"Line"===e.type&&o.push(e),e.geometry&&"SphereGeometry"===e.geometry.type&&e.material&&(6600182===e.material.color.getHex()||16737877===e.material.color.getHex())&&o.push(e)}),o.forEach(e=>{slerpScene.remove(e),e.geometry&&e.geometry.dispose(),e.material&&(e.material.map&&e.material.map.dispose(),e.material.dispose())});const a=[],r=new THREE.Vector3(1,0,0);for(let e=0;e<=100;e++){const t=qSlerp(orientationA,orientationB,e/100),[n,o,i,s]=qNorm(t),l=new THREE.Quaternion(n,o,i,s),d=r.clone();d.applyQuaternion(l),d.normalize(),a.push(d)}const i=(new THREE.BufferGeometry).setFromPoints(a),s=new THREE.CatmullRomCurve3(a),l=new THREE.TubeGeometry(s,100,.025,8,!1),d=new THREE.MeshPhongMaterial({color:2201331,emissive:1402304,emissiveIntensity:.3,shininess:100,transparent:!1,depthTest:!0}),c=new THREE.Mesh(l,d);c.renderOrder=5,slerpScene.add(c);const h=new THREE.LineBasicMaterial({color:2201331,linewidth:2,transparent:!1});slerpPathLine=new THREE.Line(i,h),slerpPathLine.renderOrder=4,slerpScene.add(slerpPathLine);const u=[],m=new THREE.Vector3(1,0,0);for(let e=0;e<=100;e++){const o=e/100,a=t[0]+(n[0]-t[0])*o,r=t[1]+(n[1]-t[1])*o,i=t[2]+(n[2]-t[2])*o,s=qFromEulerZYX(a,r,i),[l,d,c,h]=qNorm(s),p=new THREE.Quaternion(l,d,c,h),E=m.clone();E.applyQuaternion(p),E.normalize(),u.push(E)}const p=(new THREE.BufferGeometry).setFromPoints(u),E=new THREE.LineBasicMaterial({color:16737877,linewidth:5,transparent:!1});eulerPathLine=new THREE.Line(p,E),slerpScene.add(eulerPathLine);const f=new THREE.CatmullRomCurve3(u),g=new THREE.TubeGeometry(f,100,.03,8,!1),y=new THREE.MeshPhongMaterial({color:16737877,emissive:16729139,emissiveIntensity:.6,shininess:100,transparent:!1,depthTest:!0}),M=new THREE.Mesh(g,y);M.renderOrder=2,slerpScene.add(M)
;const S=a[0],T=a[a.length-1],w=slerpScene.children.find(e=>e.material&&e.material.color&&5025616===e.material.color.getHex());w&&w.position.copy(S);const R=slerpScene.children.find(e=>e.material&&e.material.color&&16750592===e.material.color.getHex());R&&R.position.copy(T);const P=Math.floor(e*(a.length-1));slerpCurrentPoint&&a[P]&&slerpCurrentPoint.position.copy(a[P]),eulerCurrentPoint&&u[P]&&eulerCurrentPoint.position.copy(u[P])},resizeSlerpPath3D=()=>{if(!slerpRenderer)return;const e=document.getElementById("slerpPathCanvas"),t=e.clientWidth,n=e.clientHeight;slerpCamera.aspect=t/n,slerpCamera.updateProjectionMatrix(),slerpRenderer.setSize(t,n)},eulerCondition=(e,t,n)=>{const o=180*t/Math.PI,a=180*e/Math.PI,r=180*n/Math.PI;let i=8*(Math.abs(o)/90)-2+.5*Math.sin(a*Math.PI/45)+.3*Math.cos(r*Math.PI/30);return Math.abs(o)>80&&(i=Math.max(4,i)),i=Math.max(-3,Math.min(6,i)),Math.random()<.01&&console.log(`Condition: pitch=${o.toFixed(1)}\xb0, condition=${i.toFixed(2)}`),i},eulerConditionOld=()=>0,drawHeatmap=()=>{const e=document.getElementById("heatmapCanvas"),t=heatmapCtx,n=e.clientWidth,o=e.clientHeight;t.clearRect(0,0,n,o);const a=deg2rad(parseFloat(document.getElementById("heatmapPitchSlider").value)),r=deg2rad(parseFloat(document.getElementById("torusYawSlider").value)),i=deg2rad(parseFloat(document.getElementById("torusRollSlider").value)),s=(deg2rad(parseFloat(document.getElementById("pitchSlider").value)),64);let l=0;const d=[];for(let e=0;e<s;e++){d[e]=[];for(let t=0;t<s;t++){const n=2*(e/s-.5)*Math.PI,o=2*(t/s-.5)*Math.PI,r=eulerCondition(n,a,o);d[e][t]=r,l=Math.max(l,Math.min(r,1e3))}}if(showTorusView){t.save(),t.translate(n/2,o/2);const e=.2*Math.min(n,o),l=.3*e;for(let n=0;n<s;n++)for(let o=0;o<s;o++){const a=n/s*2*Math.PI,r=o/s*2*Math.PI,i=(e+l*Math.cos(r))*Math.cos(a),c=(e+l*Math.cos(r))*Math.sin(a),h=.9,u=(.866*i-.5*c)*h,m=(.866*(l*Math.sin(r))+.5*c)*h,p=a-Math.PI,E=r-Math.PI,f=Math.floor((p+Math.PI)/(2*Math.PI)*s),g=Math.floor((E+Math.PI)/(2*Math.PI)*s),y=Math.max(0,Math.min(s-1,f)),M=Math.max(0,Math.min(s-1,g)),S=d[y][M];let T,w,R;if(S<-3)T=0,w=102,R=255;else if(S<-1){const e=(S+3)/2;T=0,w=Math.floor(102+153*e),R=Math.floor(255*(1-e))}else if(S<1)T=0,w=255,R=0;else if(S<3){const e=(S-1)/2;T=Math.floor(255*e),w=Math.floor(255*(1-e)),R=0}else if(S<4.5)T=255,w=0,R=0;else if(S<6){const e=(S-4.5)/1.5;T=255,w=Math.floor(255*e),R=0}else T=255,w=255,R=0;const P=Math.PI/6,x=(i*Math.cos(P)+c*Math.sin(P)+(e+l))/(2*(e+l)),C=Math.max(.3,.4+.5*x),I=Math.max(1.5,2+1.5*x);t.fillStyle=`rgba(${T}, ${w}, ${R}, ${C})`,t.beginPath(),t.arc(u,m,I,0,2*Math.PI),t.fill()}t.strokeStyle="rgba(255, 255, 255, 0.3)",t.lineWidth=1,t.beginPath(),t.arc(0,0,e,0,2*Math.PI),t.stroke();{const n=r+Math.PI,o=i+Math.PI,a=(e+l*Math.cos(o))*Math.cos(n),s=(e+l*Math.cos(o))*Math.sin(n),d=.9,c=(.866*a-.5*s)*d,h=(.866*(l*Math.sin(o))+.5*s)*d,u=8;t.fillStyle="rgba(255, 255, 255, 0.3)",t.beginPath(),t.arc(c,h,u+4,0,2*Math.PI),t.fill(),t.fillStyle="#ff00ff",t.beginPath(),t.arc(c,h,u,0,2*Math.PI),t.fill(),t.fillStyle="#ffffff",t.beginPath(),t.arc(c,h,u-3,0,2*Math.PI),t.fill(),t.strokeStyle="#ff00ff",t.lineWidth=2,t.beginPath(),t.moveTo(c-12,h),t.lineTo(c+12,h),t.moveTo(c,h-12),t.lineTo(c,h+12),t.stroke(),t.fillStyle="#ff00ff",t.font="bold 11px sans-serif",t.fillText("Current Position",c+15,h-15),t.font="9px sans-serif",t.fillText(`Y:${rad2deg(r).toFixed(0)}\xb0 R:${rad2deg(i).toFixed(0)}\xb0`,c+15,h-2)}t.fillStyle="#ffffff",t.font="bold 12px sans-serif",t.fillText(`Torus View (Pitch = ${rad2deg(a).toFixed(0)}\xb0)`,-e,-e-l-35),t.font="10px sans-serif",t.fillStyle="rgba(255, 255, 255, 0.9)",t.fillText("Yaw: major circle \u2192",.8*e,e+25),t.fillText("Roll: minor circle \u21bb",.8*-e,-e-5),t.fillStyle="#00ff00",t.font="bold 10px sans-serif",t.fillText(`Torus Position - Y:${rad2deg(r).toFixed(0)}\xb0 R:${rad2deg(i).toFixed(0)}\xb0`,-e,e+35),t.strokeStyle="rgba(255, 255, 255, 0.4)",t.lineWidth=1,t.setLineDash([4,2]),t.beginPath(),t.arc(0,0,e,0,2*Math.PI),t.stroke();[0,Math.PI/2,Math.PI,3*Math.PI/2].forEach(n=>{const o=e*Math.cos(n),a=e*Math.sin(n);t.beginPath(),t.arc(o,a,l,0,2*Math.PI),t.stroke()}),t.setLineDash([]),t.fillStyle="rgba(100, 255, 218, 0.8)",t.font="14px sans-serif",t.fillText("\u27f2",e+15,5),t.fillText("\u27f3",e-5,l+20),t.restore(),t.fillStyle="rgba(100, 255, 218, 0.8)",t.font="bold 12px sans-serif",t.fillText("Torus View: Angles wrap at \xb1180\xb0",10,o-10)}else{const e=t.createImageData(s,s),a=e.data;for(let e=0;e<s;e++)for(let t=0;t<s;t++){const n=d[e][t],o=0===e||e===s-1,r=0===t||t===s-1,i=4*(t*s+e);let l,c,h;if(n<-3)l=0,c=102,h=255;else if(n<-1){const e=(n+3)/2;l=0,c=Math.floor(102+153*e),h=Math.floor(255*(1-e))}else if(n<1)l=0,c=255,h=0;else if(n<3){const e=(n-1)/2;l=Math.floor(255*e),c=Math.floor(255*(1-e)),h=0}else if(n<4.5)l=255,c=0,h=0;else if(n<6){const e=(n-4.5)/1.5;l=255,c=Math.floor(255*e),h=0}else l=255,c=255,h=0;a[i]=l,a[i+1]=c,a[i+2]=h,a[i+3]=o||r?200:255}const l=document.createElement("canvas");l.width=s,l.height=s;l.getContext("2d").putImageData(e,0,0),t.imageSmoothingEnabled=!1,t.drawImage(l,0,0,n,o),t.strokeStyle="rgba(100, 255, 218, 0.6)",t.lineWidth=3,t.setLineDash([8,4]),t.beginPath(),t.moveTo(0,0),t.lineTo(0,o),t.moveTo(n-1,0),t.lineTo(n-1,o),t.stroke(),t.beginPath(),t.moveTo(0,0),t.lineTo(n,0),t.moveTo(0,o-1),t.lineTo(n,o-1),t.stroke(),t.setLineDash([]),t.fillStyle="rgba(100, 255, 218, 0.8)",t.font="14px sans-serif",t.save(),t.translate(5,o/2),t.rotate(-Math.PI/2),t.fillText("\u2194",-8,0),t.restore(),t.save(),t.translate(n-15,o/2),t.rotate(-Math.PI/2),t.fillText("\u2194",-8,0),t.restore(),t.fillText("\u2195",n/2-5,15),t.fillText("\u2195",n/2-5,o-5),t.fillStyle="#ffffff",t.font="12px sans-serif",t.fillText("Yaw [-180\xb0, 180\xb0] \u2192",n-140,o-10),t.save(),t.translate(15,o/2+30),t.rotate(-Math.PI/2),t.fillText("Roll [-180\xb0, 180\xb0] \u2191",0,0),t.restore(),t.fillStyle="rgba(255, 255, 255, 0.7)",t.font="10px sans-serif";[-180,-90,0,90,180].forEach(e=>{const a=(e+180)/360*n;t.fillText(`${e}\xb0`,a-10,o-20)});[-180,-90,0,90,180].forEach(e=>{const n=(e+180)/360*o;t.save(),t.translate(25,n+3),t.fillText(`${e}\xb0`,0,0),t.restore()});{const e=(180*r/Math.PI+180)/360*n,a=(180*i/Math.PI+180)/360*o,s=Math.max(20,Math.min(n-20,e)),l=Math.max(20,Math.min(o-40,a)),d=10;t.fillStyle="rgba(255, 255, 255, 0.4)",t.beginPath(),t.arc(s,l,d+4,0,2*Math.PI),t.fill(),t.fillStyle="#ff00ff",t.beginPath(),t.arc(s,l,d,0,2*Math.PI),t.fill(),t.fillStyle="#ffffff",t.beginPath(),t.arc(s,l,d-4,0,2*Math.PI),t.fill(),t.strokeStyle="#ff00ff",t.lineWidth=2,t.beginPath(),t.moveTo(s-15,l),t.lineTo(s+15,l),t.moveTo(s,l-15),t.lineTo(s,l+15),t.stroke(),t.fillStyle="#ff00ff",t.font="bold 11px sans-serif",t.fillText("Current Position",s+18,l-15),t.font="9px sans-serif",t.fillText(`Y:${rad2deg(r).toFixed(0)}\xb0 R:${rad2deg(i).toFixed(0)}\xb0`,s+18,l-2),t.strokeStyle="rgba(255, 0, 255, 0.3)",t.lineWidth=1,t.setLineDash([2,2]),t.beginPath(),t.moveTo(s,l),t.lineTo(s,o-35),t.moveTo(s,l),t.lineTo(35,l),t.stroke(),t.setLineDash([])}}t.font="bold 14px sans-serif",t.fillStyle=Math.abs(a)>deg2rad(80)?"#ff6b6b":"#64ffda",t.fillText(`Pitch: ${rad2deg(a).toFixed(0)}\xb0`,10,20),Math.abs(Math.cos(a))<.15&&(t.fillStyle="#ffff00",t.font="bold 16px sans-serif",t.fillText("NEAR SINGULARITY!",n/2-80,25))};let orientationA=[0,0,0,1],orientationB=qFromEulerZYX(deg2rad(90),deg2rad(45),deg2rad(30));const drawSlerpVelocity=()=>{const e=document.getElementById("slerpVelocityCanvas"),t=slerpVelocityCtx,n=e.clientWidth,o=e.clientHeight;t.clearRect(0,0,n,o);const a=parseFloat(document.getElementById("tSlider").value),r=qToEulerZYX(orientationA),i=qToEulerZYX(orientationB),s=[],l=[],d=[],c=[],h=100,u=1/h;for(let e=0;e<=h;e++){const t=e/h,n=qSlerp(orientationA,orientationB,t);d.push(n);const o=r[0]+(i[0]-r[0])*t,a=r[1]+(i[1]-r[1])*t,m=r[2]+(i[2]-r[2])*t,p=qFromEulerZYX(o,a,m);if(c.push(p),e>0){const t=qMul(n,qConj(d[e-1])),[o,a]=qToAxisAngle(t),r=a/u;s.push(r);const i=qMul(p,qConj(c[e-1])),[h,m]=qToAxisAngle(i),E=m/u;l.push(E)}}const m=Math.max(...s,...l),p=Math.min(...s,...l),E=m-p||1;t.fillStyle="rgba(255, 255, 255, 0.02)",t.fillRect(0,0,n,o);const f=.7*o,g=.15*o;t.strokeStyle="rgba(255, 255, 255, 0.1)",t.lineWidth=1;for(let e=0;e<=4;e++){const o=g+f*e/4;t.beginPath(),t.moveTo(10,o),t.lineTo(n-10,o),t.stroke()}t.strokeStyle="#2196f3",t.lineWidth=3,t.beginPath();for(let e=0;e<s.length;e++){const o=10+(n-20)*(e/s.length),a=g+f-(s[e]-p)/E*f;0===e?t.moveTo(o,a):t.lineTo(o,a)}t.stroke();const y=s.reduce((e,t)=>e+t,0)/s.length,M=Math.sqrt(s.reduce((e,t)=>e+Math.pow(t-y,2),0)/s.length);t.strokeStyle="#f44336",t.lineWidth=3,t.beginPath();for(let e=0;e<l.length;e++){const o=10+(n-20)*(e/l.length),a=g+f-(l[e]-p)/E*f;0===e?t.moveTo(o,a):t.lineTo(o,a)}t.stroke();const S=l.reduce((e,t)=>e+t,0)/l.length,T=Math.sqrt(l.reduce((e,t)=>e+Math.pow(t-S,2),0)/l.length),w=Math.min(Math.floor(a*(s.length-1)),s.length-1),R=10+(n-20)*a;t.strokeStyle="rgba(255, 255, 255, 0.3)",t.lineWidth=1,t.setLineDash([4,2]),t.beginPath(),t.moveTo(R,g),t.lineTo(R,g+f),t.stroke(),t.setLineDash([]);const P=g+f-(s[w]-p)/E*f;t.fillStyle="#2196f3",t.beginPath(),t.arc(R,P,5,0,2*Math.PI),t.fill();const x=g+f-(l[w]-p)/E*f;t.fillStyle="#f44336",t.beginPath(),t.arc(R,x,5,0,2*Math.PI),t.fill(),t.fillStyle="#ffffff",t.font="bold 12px sans-serif",t.fillText("Angular Velocity",n/2-45,15),t.font="10px sans-serif",t.fillStyle="rgba(255, 255, 255, 0.6)",t.fillText("0",5,g+f+12),t.fillText("t",n-15,g+f+12),t.fillText("1",n-10,g+f+12),t.fillStyle="#2196f3",t.font="bold 11px sans-serif",t.fillText(`SLERP: \u03c3=${M.toFixed(3)}`,15,o-25),t.fillText("(constant speed)",15,o-10),t.fillStyle="#f44336",t.fillText(`Euler: \u03c3=${T.toFixed(3)}`,15,o-55),t.fillText("(varying speed)",15,o-40)};let previousQuaternion=null,lastUpdateTime=performance.now();const updateFromSliders=()=>{const e=performance.now(),t=(e-lastUpdateTime)/1e3,n=deg2rad(parseFloat(document.getElementById("yawSlider").value)),o=deg2rad(parseFloat(document.getElementById("pitchSlider").value)),a=deg2rad(parseFloat(document.getElementById("rollSlider").value));previousQuaternion=currentQuaternion?[...currentQuaternion]:null,currentQuaternion=qFromEulerZYX(n,o,a);const r=Math.sqrt(currentQuaternion[0]**2+currentQuaternion[1]**2+currentQuaternion[2]**2+currentQuaternion[3]**2),i=Math.abs(r-1);if(i>QUATERNION_TOLERANCE&&(console.warn("Mathematical Analysis: Unit quaternion constraint violated:",i),mathAnalysis.unitConstraintViolations.push({frame:mathAnalysis.frameCount,error:i,quaternion:[...currentQuaternion]})),previousQuaternion&&t>0){const e=analyzeTemporalCoherence(currentQuaternion,previousQuaternion,t);e&&!e.isCoherent&&mathAnalysis.temporalCoherence.push({frame:mathAnalysis.frameCount,type:"coherence-violation",velocityError:e.velocityCoherenceError,axisError:e.axisCoherenceError})}const s=qToMatrix(currentQuaternion),l=verifySO3Properties(s);l.isValidSO3||console.error("Mathematical Analysis: SO(3) property violation:",l);const d=verifyDoubleCover(currentQuaternion);d.isValid||console.error("Mathematical Analysis: Double cover violation:",d.error);const c=analyzeAntipodalPoints(currentQuaternion);!c.isValidAntipodal&&c.geodesicError>.1&&console.warn("Mathematical Analysis: Significant antipodal inconsistency:",{geodesicError:c.geodesicError,rotationMatrixError:c.rotationMatrixError});const h=stereographicProjection(currentQuaternion,"north");if(h.isValid||mathAnalysis.projectionErrors.push({frame:mathAnalysis.frameCount,error:h.error,quaternion:[...currentQuaternion]}),frameCount++,mathAnalysis.frameCount++,frameCount%10==0){currentQuaternion=qNorm(currentQuaternion);const e=Math.abs(Math.sqrt(currentQuaternion[0]**2+currentQuaternion[1]**2+currentQuaternion[2]**2+currentQuaternion[3]**2)-1);if(e>QUATERNION_TOLERANCE&&console.error("Mathematical Analysis: Normalization failed:",e),quaternionHistory.push([...currentQuaternion]),quaternionHistory.length>10&&quaternionHistory.shift(),quaternionHistory.length>1){const e=quaternionHistory[quaternionHistory.length-2],t=qDot(currentQuaternion,e),n=geodesicDistance(currentQuaternion,e);if(t<0){currentQuaternion=currentQuaternion.map(e=>-e),quaternionHistory[quaternionHistory.length-1]=currentQuaternion;qDot(currentQuaternion,e);geodesicDistance(currentQuaternion,e)>n&&console.warn("Mathematical Analysis: Quaternion flip did not improve continuity")}}}document.getElementById("yawValue").textContent=`${rad2deg(n).toFixed(1)}\xb0`,document.getElementById("pitchValue").textContent=`${rad2deg(o).toFixed(1)}\xb0`,document.getElementById("rollValue").textContent=`${rad2deg(a).toFixed(1)}\xb0`;const u=document.getElementById("quatX"),m=document.getElementById("quatY"),p=document.getElementById("quatZ"),E=document.getElementById("quatW");u.textContent=currentQuaternion[0].toFixed(6),m.textContent=currentQuaternion[1].toFixed(6),p.textContent=currentQuaternion[2].toFixed(6),E.textContent=currentQuaternion[3].toFixed(6);const f=i<QUATERNION_TOLERANCE?"#64ffda":i<10*QUATERNION_TOLERANCE?"#ff9800":"#ff6b6b";u.style.color=f,m.style.color=f,p.style.color=f,E.style.color=f,drawGimbal(),updateQuaternionSphere3D(),lastUpdateTime=e,frameCount%60==0&&mathAnalysis.unitConstraintViolations.length>0&&(console.log("Mathematical Analysis Summary:"),console.log(`  Unit constraint violations: ${mathAnalysis.unitConstraintViolations.length}`),console.log(`  Geodesic errors: ${mathAnalysis.geodesicErrors.length}`),console.log(`  Singularity detections: ${mathAnalysis.singularityDetections.length}`),console.log(`  Projection errors: ${mathAnalysis.projectionErrors.length}`),console.log(`  Temporal coherence issues: ${mathAnalysis.temporalCoherence.filter(e=>!e.isCoherent).length}`))},init=()=>{initThreeJS(),initQuaternionSphere3D(),initHopfFibration3D(),heatmapCtx=document.getElementById("heatmapCanvas").getContext("2d"),slerpVelocityCtx=document.getElementById("slerpVelocityCanvas").getContext("2d"),initSlerpPath3D(),resizeCanvases(),["yawSlider","pitchSlider","rollSlider"].forEach(e=>{document.getElementById(e).addEventListener("input",updateFromSliders)}),["sphereYawSlider","spherePitchSlider","sphereRollSlider"].forEach((e,t)=>{document.getElementById(e).addEventListener("input",e=>{updatingFromSlider||(sphereEuler[t]=deg2rad(parseFloat(e.target.value)),updateSphereFromEuler())})}),["quatXSlider","quatYSlider","quatZSlider","quatWSlider"].forEach((e,t)=>{document.getElementById(e).addEventListener("input",e=>{if(updatingFromSlider)return;const n=parseFloat(e.target.value);sphereQuaternion[t]=n;const o=["X","Y","Z","W"];document.getElementById(`quat${o[t]}Value`).textContent=n.toFixed(3),updateEulerFromSphere()})}),document.getElementById("heatmapPitchSlider").addEventListener("input",()=>{const e=parseFloat(document.getElementById("heatmapPitchSlider").value);document.getElementById("heatmapPitchValue").textContent=`${e}\xb0`,drawHeatmap()}),document.getElementById("torusYawSlider").addEventListener("input",()=>{const e=parseFloat(document.getElementById("torusYawSlider").value);document.getElementById("torusYawValue").textContent=`${e}\xb0`,drawHeatmap()}),document.getElementById("torusRollSlider").addEventListener("input",()=>{const e=parseFloat(document.getElementById("torusRollSlider").value);document.getElementById("torusRollValue").textContent=`${e}\xb0`,drawHeatmap()}),document.getElementById("tSlider").addEventListener("input",()=>{const e=parseFloat(document.getElementById("tSlider").value);document.getElementById("tValue").textContent=e.toFixed(2),drawSlerpVelocity(),updateSlerpPaths3D(),showGeodesicArc&&updateQuaternionSphere3D()}),document.getElementById("showQuaternionFeatures").addEventListener("click",()=>{showAntipodes=!showAntipodes,showGeodesicArc=showAntipodes,document.getElementById("showQuaternionFeatures").textContent=showAntipodes?"Hide Antipodal Points & Geodesic Arc":"Show Antipodal Points & Geodesic Arc",updateQuaternionSphere3D()});const e=document.getElementById("hopfRotationSpeed");e&&e.addEventListener("input",e=>{hopfParams.rotationSpeed=parseFloat(e.target.value);const t=document.getElementById("hopfRotationSpeedValue");t&&(t.textContent=hopfParams.rotationSpeed.toFixed(1))});const t=document.getElementById("hopfFiberCount");t&&t.addEventListener("input",e=>{hopfParams.fiberCount=parseInt(e.target.value);const t=document.getElementById("hopfFiberCountValue");t&&(t.textContent=hopfParams.fiberCount),"function"==typeof createHopfFibers&&createHopfFibers()});const n=document.getElementById("hopfAnimationPhase");n&&n.addEventListener("input",e=>{hopfParams.animationPhase=parseFloat(e.target.value);const t=document.getElementById("hopfAnimationPhaseValue");t&&(t.textContent=hopfParams.animationPhase.toFixed(2)),"function"==typeof createHopfFibers&&createHopfFibers()});const o=document.getElementById("hopfBaseSphere");o&&o.addEventListener("input",e=>{hopfParams.baseSphereSize=parseFloat(e.target.value);const t=document.getElementById("hopfBaseSphereValue");t&&(t.textContent=hopfParams.baseSphereSize.toFixed(1)),"function"==typeof createHopfBaseSphere&&createHopfBaseSphere()});const a=document.getElementById("hopfToggleAnimation");a&&a.addEventListener("click",()=>{hopfIsAnimating=!hopfIsAnimating,a.textContent=hopfIsAnimating?"Pause":"Play"});const r=document.getElementById("hopfResetView");r&&r.addEventListener("click",()=>{hopfCamera&&(hopfCamera.position.set(5,3,5),hopfCamera.lookAt(0,0,0),hopfTime=0)}),document.getElementById("setRandomOrientations").addEventListener("click",()=>{orientationA=qFromAxisAngle([Math.random()-.5,Math.random()-.5,Math.random()-.5],Math.random()*Math.PI),orientationB=qFromAxisAngle([Math.random()-.5,Math.random()-.5,Math.random()-.5],Math.random()*Math.PI),window.orientationA=orientationA,window.orientationB=orientationB,drawSlerpVelocity(),updateSlerpPaths3D(),updateQuaternionSphere3D()});let i=!1;document.getElementById("animateHeatmap").addEventListener("click",()=>{if(i)return;i=!0;let e=-90;const t=()=>{document.getElementById("heatmapPitchSlider").value=e,document.getElementById("heatmapPitchValue").textContent=`${e}\xb0`,drawHeatmap(),e+=2,e<=90?setTimeout(t,50):i=!1};t()}),document.getElementById("toggleTorusView").addEventListener("click",()=>{showTorusView=!showTorusView,document.getElementById("toggleTorusView").textContent=showTorusView?"Switch to Flat View":"Switch to Torus View",drawHeatmap()}),document.getElementById("toggleTorusView").textContent="Switch to Flat View";let s=!1;document.getElementById("animateInterp").addEventListener("click",()=>{if(s)return;s=!0;let e=0;const t=()=>{document.getElementById("tSlider").value=e,document.getElementById("tValue").textContent=e.toFixed(2),drawSlerpVelocity(),updateSlerpPaths3D(),e+=.01,e<=1?setTimeout(t,20):(s=!1,setTimeout(()=>{e=0,document.getElementById("tSlider").value=e,document.getElementById("tValue").textContent=e.toFixed(2),drawSlerpVelocity(),updateSlerpPaths3D()},500))};t()}),window.orientationA=orientationA,window.orientationB=orientationB,sphereQuaternion=[0,0,0,1],sphereEuler=[0,0,0],document.getElementById("sphereYawValue").textContent="0\xb0",document.getElementById("spherePitchValue").textContent="0\xb0",document.getElementById("sphereRollValue").textContent="0\xb0",document.getElementById("quatXValue").textContent="0.000",document.getElementById("quatYValue").textContent="0.000",document.getElementById("quatZValue").textContent="0.000",document.getElementById("quatWValue").textContent="1.000",updateFromSliders(),updateQuaternionSphere3D(),drawHeatmap(),drawSlerpVelocity(),updateSlerpPaths3D(),setTimeout(()=>{console.log("Initializing enhanced Hopf Fibration..."),hopfFibers.length>0&&console.log(`Hopf fibers successfully generated: ${hopfFibers.length}`),document.getElementById("hopfRotationSpeedValue").textContent=hopfParams.rotationSpeed.toFixed(1),document.getElementById("hopfFiberCountValue").textContent=hopfParams.fiberCount,document.getElementById("hopfAnimationPhaseValue").textContent=hopfParams.animationPhase.toFixed(2),document.getElementById("hopfBaseSphereValue").textContent=hopfParams.baseSphereSize.toFixed(1)},100)};window.addEventListener("resize",()=>{setTimeout(()=>{resizeCanvases(),resizeThreeJS(),resizeQuaternionSphere3D(),resizeHopfVisualization(),resizeSlerpPath3D(),updateFromSliders(),drawHeatmap(),drawSlerpVelocity(),updateSlerpPaths3D()},100)}),document.addEventListener("DOMContentLoaded",init);</script> </body> </html>]]></content><author><name></name></author><category term="physics"/><category term="graphics"/><category term="games"/><category term="rotations"/><category term="quaternions"/><category term="so3"/><summary type="html"><![CDATA[Why Euler angles hit singularities, how quaternions live on S³, and why SLERP makes interpolation behave. Zero-build, in-browser demo.]]></summary></entry><entry><title type="html">PID Controllers for Humans</title><link href="https://saeed1262.github.io/blog/2024/PID/" rel="alternate" type="text/html" title="PID Controllers for Humans"/><published>2024-09-07T00:00:00+00:00</published><updated>2024-09-07T00:00:00+00:00</updated><id>https://saeed1262.github.io/blog/2024/PID</id><content type="html" xml:base="https://saeed1262.github.io/blog/2024/PID/"><![CDATA[<h2 id="the-invisible-hand-of-control">The Invisible Hand of Control</h2> <p>PID controllers are everywhere. They keep your drone hovering steady in windy conditions, smooth out your camera’s autofocus, and fire the precise thrusters that guide spacecraft to dock with the International Space Station. Yet for most people, PID remains a mysterious black box of mathematical coefficients.</p> <p>What if we could see PID in action? What if we could <em>feel</em> how each parameter shapes the behavior of a control system?</p> <h2 id="the-mathematical-foundation">The Mathematical Foundation</h2> <p>A PID controller combines three fundamental control strategies into a single, elegant algorithm:</p> \[u(t) = K_p e(t) + K_i \int_0^t e(\tau) d\tau + K_d \frac{d}{dt}e(t)\] <p>Where:</p> <ul> <li><strong>u(t)</strong> is the control output</li> <li><strong>e(t) = r(t) - y(t)</strong> is the error between reference and actual values</li> <li>\(K_p, K_i, K_d\) are the proportional, integral, and derivative gains</li> </ul> <p>This deceptively simple equation powers everything from the thermostat in your home to the guidance systems of interplanetary spacecraft.</p> <h2 id="the-challenge-docking-in-space">The Challenge: Docking in Space</h2> <p>Imagine you’re piloting a spacecraft approaching a space station. You need to bring your velocity to zero at exactly the right position - overshoot and you crash, undershoot and you drift away. This is a classic control problem that demonstrates the essential challenge of feedback control: how do you smoothly guide a dynamic system to a desired state?</p> <p>The physics are unforgiving. In space, there’s no friction to naturally slow you down. Every thrust burns precious fuel. The slightest miscalculation can send you spinning into the void. This is where PID control shines - it provides a systematic, mathematically grounded approach to this complex problem.</p> <h2 id="interactive-spacecraft-docking-simulator">Interactive Spacecraft Docking Simulator</h2> <p>Try adjusting the PID parameters below. Watch how <strong>P</strong> (Proportional) responds to current error, <strong>I</strong> (Integral) eliminates steady-state error, and <strong>D</strong> (Derivative) dampens oscillations. Toggle wind gusts to see how the controller adapts to disturbances.</p> <style>.pid-demo-container{max-width:1200px;margin:30px auto;font-family:'Inter',-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,sans-serif;background-color:var(--global-card-bg-color);border-radius:12px;padding:24px;box-shadow:var(--global-box-shadow-lg);border:1px solid var(--global-border-color);transition:all .3s cubic-bezier(0.4,0,0.2,1)}.control-panel{background-color:var(--global-bg-color-secondary);padding:24px;border-radius:12px;margin-bottom:20px;box-shadow:var(--global-box-shadow-sm);border:1px solid var(--global-border-color)}.control-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(280px,1fr));gap:24px;margin-bottom:20px}.control-group{background-color:var(--global-card-bg-color);padding:20px;border-radius:8px;border:1px solid var(--global-border-color);box-shadow:var(--global-box-shadow-sm);transition:all .3s cubic-bezier(0.4,0,0.2,1);position:relative}.control-group:hover{border-color:var(--global-theme-color);box-shadow:var(--global-box-shadow-md);transform:translateY(-2px);background-color:var(--global-card-hover-bg)}.control-label{font-weight:700;font-size:18px;color:var(--global-heading-color);margin-bottom:12px;display:block;text-shadow:none;letter-spacing:.5px}.control-value{background:var(--global-theme-color);color:#fff;padding:8px 16px;border-radius:20px;font-weight:700;font-size:16px;min-width:70px;display:inline-block;text-align:center;margin-left:12px;box-shadow:var(--global-box-shadow-sm);transition:all .2s ease}.control-description{color:var(--global-text-color-light);font-size:14px;margin-top:8px;font-weight:500}.pid-slider{width:100%;height:10px;border-radius:5px;background:var(--global-border-color);outline:0;margin-top:12px;cursor:pointer;-webkit-appearance:none;appearance:none;transition:background .3s ease}.pid-slider:focus{background:var(--global-text-color-light);box-shadow:0 0 0 3px rgba(var(--global-theme-color-rgb),0.25)}.pid-slider::-webkit-slider-thumb{-webkit-appearance:none;appearance:none;width:28px;height:28px;border-radius:50%;background:var(--global-theme-color);cursor:pointer;border:4px solid var(--global-card-bg-color);box-shadow:var(--global-box-shadow-md);transition:all .2s ease}.pid-slider::-webkit-slider-thumb:hover{transform:scale(1.15);box-shadow:var(--global-box-shadow-lg);background:var(--global-theme-color-dark)}.pid-slider::-moz-range-thumb{width:28px;height:28px;border-radius:50%;background:var(--global-theme-color);cursor:pointer;border:4px solid var(--global-card-bg-color);box-shadow:var(--global-box-shadow-md)}.control-buttons{display:flex;justify-content:center;align-items:center;gap:24px;flex-wrap:wrap}.reset-btn{background:var(--global-gradient-primary);color:#fff;border:0;padding:14px 28px;border-radius:8px;font-weight:700;font-size:16px;cursor:pointer;transition:all .3s cubic-bezier(0.4,0,0.2,1);box-shadow:var(--global-box-shadow-md);text-transform:uppercase;letter-spacing:1px}.reset-btn:hover{transform:translateY(-3px);box-shadow:var(--global-box-shadow-lg)}.preset-btn{background-color:var(--global-card-bg-color);color:var(--global-text-color);border:2px solid var(--global-border-color);padding:12px 20px;border-radius:8px;font-weight:600;font-size:14px;cursor:pointer;transition:all .3s cubic-bezier(0.4,0,0.2,1);box-shadow:var(--global-box-shadow-sm)}.preset-btn:hover{transform:translateY(-2px);box-shadow:var(--global-box-shadow-md);background:var(--global-gradient-primary);color:#fff;border-color:transparent}.wind-toggle-container{display:flex;align-items:center;background-color:var(--global-card-bg-color);padding:14px 24px;border-radius:8px;border:1px solid var(--global-border-color);cursor:pointer;transition:all .3s cubic-bezier(0.4,0,0.2,1)}.wind-toggle-container:hover{border-color:var(--global-accent-color);background-color:var(--global-card-hover-bg);transform:translateY(-1px)}.wind-checkbox{width:22px;height:22px;margin-right:12px;cursor:pointer}.wind-label{font-weight:600;color:var(--global-text-color);font-size:16px;cursor:pointer;margin:0}.visualization-grid{display:grid;grid-template-columns:1fr 1fr;gap:20px;margin-bottom:16px}.simulation-container{height:350px;background-color:var(--global-bg-color-secondary);border-radius:8px;position:relative;overflow:hidden;border:1px solid var(--global-border-color);box-shadow:var(--global-box-shadow-sm)}.plots-container{display:grid;grid-template-rows:1fr 1fr;gap:12px;height:350px}.error-plot-container,.control-plot-container{background-color:var(--global-card-bg-color);border:1px solid var(--global-border-color);border-radius:8px;box-shadow:var(--global-box-shadow-sm);position:relative}.plot-title{position:absolute;top:8px;left:12px;font-weight:700;font-size:14px;color:var(--global-heading-color);z-index:10;background-color:var(--global-bg-color-secondary);padding:4px 8px;border-radius:4px;border:1px solid var(--global-border-color)}.status-display{background-color:var(--global-bg-color-secondary);padding:16px;border-radius:8px;margin-top:16px;border:1px solid var(--global-border-color);box-shadow:var(--global-box-shadow-sm)}
.status-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(150px,1fr));gap:16px;text-align:center}.status-item{background-color:var(--global-card-bg-color);padding:12px;border-radius:6px;border:1px solid var(--global-border-color)}.status-label{font-weight:600;color:var(--global-text-color-light);font-size:12px;text-transform:uppercase;letter-spacing:.5px}.status-value{font-weight:700;color:var(--global-heading-color);font-size:18px;margin-top:4px}.preset-buttons{display:flex;gap:12px;flex-wrap:wrap;justify-content:center;margin-top:16px}.comparison-mode{background:rgba(var(--global-accent-color-rgb),0.1);border:2px solid var(--global-accent-color)}@media(max-width:768px){.visualization-grid{grid-template-columns:1fr}.control-grid{grid-template-columns:1fr}.simulation-container,.plots-container{height:300px}.status-grid{grid-template-columns:repeat(2,1fr)}}@keyframes pulse{0%{opacity:.6}50%{opacity:1}100%{opacity:.6}}.loading{animation:pulse 2s infinite}@keyframes glow{0%{box-shadow:0 0 5px rgba(var(--global-theme-color-rgb),0.4)}50%{box-shadow:0 0 20px rgba(var(--global-theme-color-rgb),0.7)}100%{box-shadow:0 0 5px rgba(var(--global-theme-color-rgb),0.4)}}.active-control{animation:glow 2s infinite}</style> <div class="pid-demo-container" id="pid-demo"> <div class="control-panel"> <div class="control-grid"> <div class="control-group" id="p-control"> <label class="control-label"> P (Proportional) <span class="control-value" id="p-value">1.0</span> </label> <div class="control-description">Current error response strength</div> <input type="range" class="pid-slider" id="p-slider" min="0" max="5" step="0.1" value="1.0" aria-label="Proportional gain control"/> </div> <div class="control-group" id="i-control"> <label class="control-label"> I (Integral) <span class="control-value" id="i-value">0.1</span> </label> <div class="control-description">Accumulated error correction</div> <input type="range" class="pid-slider" id="i-slider" min="0" max="2" step="0.05" value="0.1" aria-label="Integral gain control"/> </div> <div class="control-group" id="d-control"> <label class="control-label"> D (Derivative) <span class="control-value" id="d-value">0.3</span> </label> <div class="control-description">Error change rate damping</div> <input type="range" class="pid-slider" id="d-slider" min="0" max="2" step="0.05" value="0.3" aria-label="Derivative gain control"/> </div> </div> <div class="control-buttons"> <button class="reset-btn" id="reset-btn" aria-label="Reset simulation">🔄 Reset</button> <button class="preset-btn" id="oscillating-btn">Oscillating</button> <button class="preset-btn" id="overdamped-btn">Overdamped</button> <button class="preset-btn" id="critically-damped-btn">Critical</button> <label class="wind-toggle-container"> <input type="checkbox" class="wind-checkbox" id="wind-toggle" aria-label="Toggle wind disturbances"/> <span class="wind-label">🌪️ Disturbances</span> </label> </div> </div> <div class="visualization-grid"> <div class="simulation-container" id="simulation-container"> <canvas id="spacecraft-canvas" style="width: 100%; height: 100%;"></canvas> </div> <div class="plots-container"> <div class="error-plot-container" id="error-plot"> <div class="plot-title">Position Error Over Time</div> </div> <div class="control-plot-container" id="control-plot"> <div class="plot-title">Control Signal (Thrust)</div> </div> </div> </div> <div class="status-display"> <div class="status-grid"> <div class="status-item"> <div class="status-label">Position</div> <div class="status-value" id="position-value">-8.00</div> </div> <div class="status-item"> <div class="status-label">Velocity</div> <div class="status-value" id="velocity-value">0.00</div> </div> <div class="status-item"> <div class="status-label">Error</div> <div class="status-value" id="error-value">8.00</div> </div> <div class="status-item"> <div class="status-label">Thrust</div> <div class="status-value" id="thrust-value">0.00</div> </div> <div class="status-item"> <div class="status-label">Integral</div> <div class="status-value" id="integral-value">0.00</div> </div> <div class="status-item"> <div class="status-label">Derivative</div> <div class="status-value" id="derivative-value">0.00</div> </div> </div> </div> </div> <script src="https://cdn.jsdelivr.net/npm/d3@7.8.5/dist/d3.min.js"></script> <script>function initEnhanced2DSimulation(){function t(){const t=e.getBoundingClientRect();sim.canvas.width=t.width,sim.canvas.height=t.height}const e=document.getElementById("simulation-container");sim.canvas=document.getElementById("spacecraft-canvas"),sim.ctx=sim.canvas.getContext("2d"),t(),window.addEventListener("resize",t),animate2D()}function animate2D(){const t=sim.target-sim.position,e=sim.windEnabled?.3*(Math.random()-.5):0,i=sim.pid.update(t),o=Math.max(-2,Math.min(2,i));sim.velocity+=.016*(o+e),sim.velocity*=.98,sim.position+=.016*sim.velocity,sim.time+=.016,sim.errorHistory.push({time:sim.time,value:Math.abs(t)}),sim.controlHistory.push({time:sim.time,value:o}),sim.positionHistory.push({time:sim.time,value:sim.position}),sim.velocityHistory.push({time:sim.time,value:sim.velocity}),sim.errorHistory.length>sim.maxHistory&&(sim.errorHistory.shift(),sim.controlHistory.shift(),sim.positionHistory.shift(),sim.velocityHistory.shift()),render2D(),updateStatusDisplay(t,o),sim.animationId=requestAnimationFrame(animate2D)}function render2D(){const t=sim.canvas,e=sim.ctx,i=getComputedStyle(document.documentElement),o=i.getPropertyValue("--global-bg-color-secondary").trim(),n=i.getPropertyValue("--global-border-color").trim(),l=i.getPropertyValue("--global-text-color-light").trim(),r=i.getPropertyValue("--global-theme-color").trim(),s=i.getPropertyValue("--global-heading-color").trim();e.fillStyle=o,e.fillRect(0,0,t.width,t.height),e.strokeStyle=n,e.lineWidth=1;const a=40;for(let i=0;i<t.width;i+=a)e.beginPath(),e.moveTo(i,0),e.lineTo(i,t.height),e.stroke();for(let i=0;i<t.height;i+=a)e.beginPath(),e.moveTo(0,i),e.lineTo(t.width,i),e.stroke();const d=t.width/2,m=t.height/2,c=Math.min(t.width,t.height)/20;e.strokeStyle=l,e.lineWidth=2,e.beginPath(),e.moveTo(50,m),e.lineTo(t.width-50,m),e.stroke(),e.fillStyle=l,e.font="12px Inter, Arial, sans-serif",e.textAlign="center";for(let i=-10;i<=10;i+=2){const o=d+i*c;o>=50&&o<=t.width-50&&(e.strokeStyle=l,e.beginPath(),e.moveTo(o,m-5),e.lineTo(o,m+5),e.stroke(),e.fillText(i.toString(),o,m+20))}e.fillStyle="#ff6b6b",e.strokeStyle="#ff6b6b",e.lineWidth=4,e.beginPath(),e.moveTo(d,m-40),e.lineTo(d,m+40),e.stroke(),e.fillStyle="#ff6b6b",e.font="bold 14px Inter, Arial, sans-serif",e.textAlign="center",e.fillText("TARGET",d,m-50),e.fillText("(Setpoint = 0)",d,m+60);const p=d+sim.position*c;p>=30&&p<=t.width-30&&(e.fillStyle=r,e.beginPath(),e.arc(p,m,15,0,2*Math.PI),e.fill(),e.strokeStyle=r,e.lineWidth=3,e.beginPath(),e.moveTo(p,m-35),e.lineTo(p,m+35),e.stroke(),e.fillStyle=r,e.font="bold 14px Inter, Arial, sans-serif",e.textAlign="center",e.fillText("CURRENT",p,m-70),e.fillText(`Position: ${sim.position.toFixed(2)}`,p,m+80));const h=sim.target-sim.position;if(Math.abs(h)>.1){const t=Math.min(d,p),i=Math.max(d,p),o=i-t;e.fillStyle="rgba(255, 212, 59, 0.4)",e.fillRect(t,m-12,o,24),e.strokeStyle="#ffd43b",e.lineWidth=2,e.strokeRect(t,m-12,o,24),e.fillStyle=s,e.font="bold 12px Inter, Arial, sans-serif",e.textAlign="center",e.fillText(`Error: ${h.toFixed(2)}`,(t+i)/2,m-20)}if(Math.abs(sim.velocity)>.01){e.strokeStyle="#51cf66",e.fillStyle="#51cf66",e.lineWidth=4;const i=p+200*sim.velocity,o=Math.max(30,Math.min(t.width-30,i));if(e.beginPath(),e.moveTo(p,m-100),e.lineTo(o,m-100),e.stroke(),Math.abs(sim.velocity)>.05){const t=sim.velocity>0?1:-1;e.beginPath(),e.moveTo(o,m-100),e.lineTo(o-8*t,m-105),e.lineTo(o-8*t,m-95),e.fill()}e.font="bold 12px Inter, Arial, sans-serif",e.textAlign="center",e.fillText(`Velocity: ${sim.velocity.toFixed(3)}`,p,m-115)}const u=sim.controlHistory[sim.controlHistory.length-1]?.value||0;if(Math.abs(u)>.01){const t=60*Math.abs(u),i=m+120;e.fillStyle=u>0?r:"#ff6b6b",e.fillRect(p-15,i-(u>0?t:0),30,t),e.strokeStyle=s,e.lineWidth=2,e.strokeRect(p-15,i-(u>0?t:0),30,t),e.fillStyle=s,e.font="bold 12px Inter, Arial, sans-serif",e.textAlign="center",e.fillText(`Control: ${u.toFixed(3)}`,p,i+20),e.fillText(u>0?"(Forward)":"(Backward)",p,i+35)}Math.abs(sim.position)<.1&&Math.abs(sim.velocity)<.05&&(e.fillStyle="rgba(81, 207, 102, 0.3)",e.fillRect(0,0,t.width,t.height),e.fillStyle="#51cf66",e.font="bold 24px Inter, Arial, sans-serif",e.textAlign="center",e.fillText("\u2713 TARGET ACHIEVED!",t.width/2,40),e.fillText("Position and Velocity at Zero",t.width/2,70)),e.fillStyle=l,e.font="bold 11px Inter, Arial, sans-serif",e.textAlign="left",e.fillText("PID Position Control System",10,20),e.fillStyle=l,e.font="10px Inter, Arial, sans-serif",e.textAlign="left";const g=t.height-60;e.fillText("\u2022 Theme circle: Current position",10,g),e.fillText("\u2022 Red line: Target setpoint",10,g+12),e.fillText("\u2022 Yellow area: Position error",10,g+24),e.fillText("\u2022 Green arrow: Velocity",10,g+36),e.fillText("\u2022 Theme/Red bar: Control output",200,g+24)}function updateStatusDisplay(t,e){document.getElementById("position-value").textContent=sim.position.toFixed(2),document.getElementById("velocity-value").textContent=sim.velocity.toFixed(2),document.getElementById("error-value").textContent=t.toFixed(2),document.getElementById("thrust-value").textContent=e.toFixed(2),document.getElementById("integral-value").textContent=sim.pid.integral.toFixed(2),document.getElementById("derivative-value").textContent=((t-sim.pid.previousError)/sim.pid.dt).toFixed(2)}function updatePlots(){updateErrorPlot(),updateControlPlot()}function updateErrorPlot(){if(sim.errorHistory.length<2)return;const t=document.getElementById("error-plot");t.innerHTML='<div class="plot-title">Position Error Over Time</div>';const e={top:30,right:20,bottom:40,left:50},i=t.clientWidth-e.left-e.right,o=t.clientHeight-e.top-e.bottom;if(i<=0||o<=0)return;const n=d3.select(t).append("svg").attr("width",i+e.left+e.right).attr("height",o+e.top+e.bottom).append("g").attr("transform",`translate(${e.left},${e.top})`),l=d3.scaleLinear().domain(d3.extent(sim.errorHistory,t=>t.time)).range([0,i]),r=d3.scaleLinear().domain([0,d3.max(sim.errorHistory,t=>t.value)||1]).range([o,0]),s=d3.area().x(t=>l(t.time)).y0(o).y1(t=>r(t.value)).curve(d3.curveMonotoneX);n.append("path").datum(sim.errorHistory).attr("fill","rgba(220, 53, 69, 0.2)").attr("d",s);const a=d3.line().x(t=>l(t.time)).y(t=>r(t.value)).curve(d3.curveMonotoneX);n.append("path").datum(sim.errorHistory).attr("fill","none").attr("stroke","#dc3545").attr("stroke-width",2).attr("d",a),n.append("g").attr("transform",`translate(0,${o})`).call(d3.axisBottom(l).ticks(5)).selectAll("text").style("font-size","11px"),n.append("g").call(d3.axisLeft(r).ticks(4)).selectAll("text").style("font-size","11px")}function updateControlPlot(){if(sim.controlHistory.length<2)return;const t=document.getElementById("control-plot");t.innerHTML='<div class="plot-title">Control Signal (Thrust)</div>';const e={top:30,right:20,bottom:40,left:50},i=t.clientWidth-e.left-e.right,o=t.clientHeight-e.top-e.bottom;if(i<=0||o<=0)return;const n=d3.select(t).append("svg").attr("width",i+e.left+e.right).attr("height",o+e.top+e.bottom).append("g").attr("transform",`translate(${e.left},${e.top})`),l=d3.scaleLinear().domain(d3.extent(sim.controlHistory,t=>t.time)).range([0,i]),r=d3.extent(sim.controlHistory,t=>t.value),s=d3.scaleLinear().domain([Math.min(r[0],-.5),Math.max(r[1],.5)]).range([o,0]);n.append("line").attr("x1",0).attr("x2",i).attr("y1",s(0)).attr("y2",s(0)).attr("stroke","#666").attr("stroke-dasharray","3,3");const a=d3.area().x(t=>l(t.time)).y0(s(0)).y1(t=>s(t.value)).curve(d3.curveMonotoneX);n.append("path").datum(sim.controlHistory).attr("fill","rgba(0, 123, 255, 0.3)").attr("d",a);const d=d3.line().x(t=>l(t.time)).y(t=>s(t.value)).curve(d3.curveMonotoneX);n.append("path").datum(sim.controlHistory).attr("fill","none").attr("stroke","#007bff").attr("stroke-width",2).attr("d",d),n.append("g").attr("transform",`translate(0,${o})`).call(d3.axisBottom(l).ticks(5)).selectAll("text").style("font-size","11px"),n.append("g").call(d3.axisLeft(s).ticks(4)).selectAll("text").style("font-size","11px")}function updatePID(){sim.pid.setGains(parseFloat(pSlider.value),parseFloat(iSlider.value),parseFloat(dSlider.value))}function highlightActiveControl(t){document.querySelectorAll(".control-group").forEach(t=>{t.classList.remove("active-control")}),document.getElementById(t).classList.add("active-control"),setTimeout(()=>{document.getElementById(t).classList.remove("active-control")},2e3)}class PIDController{constructor(t=1,e=.1,i=.3){this.kp=t,this.ki=e,this.kd=i,this.integral=0,this.previousError=0,this.dt=.016,this.maxIntegral=10,this.pComponent=0,this.iComponent=0,this.dComponent=0}update(t){this.pComponent=this.kp*t,this.integral+=t*this.dt,this.integral=Math.max(-this.maxIntegral,Math.min(this.maxIntegral,this.integral)),this.iComponent=this.ki*this.integral;const e=(t-this.previousError)/this.dt;this.dComponent=this.kd*e;const i=this.pComponent+this.iComponent+this.dComponent;return this.previousError=t,i}reset(){this.integral=0,this.previousError=0,this.pComponent=0,this.iComponent=0,this.dComponent=0}setGains(t,e,i){this.kp=t,this.ki=e,this.kd=i}}const sim={position:-8,velocity:0,target:0,pid:new PIDController,time:0,errorHistory:[],controlHistory:[],positionHistory:[],velocityHistory:[],windEnabled:!1,maxHistory:400,canvas:null,ctx:null,animationId:null},presets={oscillating:{p:3,i:.1,d:.1},overdamped:{p:.5,i:.2,d:1.5},criticallyDamped:{p:1.5,i:.3,d:.8}};document.addEventListener("DOMContentLoaded",function(){initEnhanced2DSimulation(),setInterval(updatePlots,250)});const pSlider=document.getElementById("p-slider"),iSlider=document.getElementById("i-slider"),dSlider=document.getElementById("d-slider"),pValue=document.getElementById("p-value"),iValue=document.getElementById("i-value"),dValue=document.getElementById("d-value"),resetBtn=document.getElementById("reset-btn"),windToggle=document.getElementById("wind-toggle");pSlider.addEventListener("input",t=>{pValue.textContent=t.target.value,updatePID(),highlightActiveControl("p-control")}),iSlider.addEventListener("input",t=>{iValue.textContent=t.target.value,updatePID(),highlightActiveControl("i-control")}),dSlider.addEventListener("input",t=>{dValue.textContent=t.target.value,updatePID(),highlightActiveControl("d-control")}),resetBtn.addEventListener("click",()=>{sim.position=-8,sim.velocity=0,sim.time=0,sim.errorHistory=[],sim.controlHistory=[],sim.positionHistory=[],sim.velocityHistory=[],sim.pid.reset()}),windToggle.addEventListener("change",t=>{sim.windEnabled=t.target.checked}),document.getElementById("oscillating-btn").addEventListener("click",()=>{const t=presets.oscillating;pSlider.value=t.p,iSlider.value=t.i,dSlider.value=t.d,pValue.textContent=t.p,iValue.textContent=t.i,dValue.textContent=t.d,updatePID()}),document.getElementById("overdamped-btn").addEventListener("click",()=>{const t=presets.overdamped;pSlider.value=t.p,iSlider.value=t.i,dSlider.value=t.d,pValue.textContent=t.p,iValue.textContent=t.i,dValue.textContent=t.d,updatePID()}),document.getElementById("critically-damped-btn").addEventListener("click",()=>{const t=presets.criticallyDamped;pSlider.value=t.p,iSlider.value=t.i,dSlider.value=t.d,pValue.textContent=t.p,iValue.textContent=t.i,dValue.textContent=t.d,updatePID()});</script> <h2 id="deep-dive-understanding-each-parameter">Deep Dive: Understanding Each Parameter</h2> <h3 id="proportional-control-p-the-immediate-response">Proportional Control (P): The Immediate Response</h3> <p>The proportional term provides an output that is directly proportional to the current error:</p> \[u_p(t) = K_p \cdot e(t)\] <p><strong>Behavior Characteristics:</strong></p> <ul> <li><strong>Low P gain (&lt; 1.0)</strong>: Sluggish response, slow convergence to target</li> <li><strong>Moderate P gain (1.0-2.0)</strong>: Good balance of speed and stability</li> <li><strong>High P gain (&gt; 3.0)</strong>: Fast response but prone to oscillations and overshoot</li> </ul> <p>The proportional term is like a rubber band - the further you stretch it (larger error), the stronger it pulls back. However, pure proportional control has a fundamental limitation: <strong>steady-state error</strong>. If there’s any constant disturbance (like friction or gravity), the system will settle at a position where the P output exactly balances the disturbance, leaving a permanent error.</p> <h3 id="integral-control-i-the-memory-keeper">Integral Control (I): The Memory Keeper</h3> <p>The integral term accumulates error over time, providing a corrective action based on the history of errors:</p> \[u_i(t) = K_i \int_0^t e(\tau) d\tau\] <p><strong>Key Properties:</strong></p> <ul> <li><strong>Eliminates steady-state error</strong>: By continuously accumulating error, it ensures the system eventually reaches the target</li> <li><strong>Slow response</strong>: Takes time to build up sufficient corrective action</li> <li><strong>Integral windup</strong>: Can become excessively large, causing instability and overshoot</li> </ul> <p><strong>Integral Windup Prevention:</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if (integral &gt; maxIntegral) integral = maxIntegral;
if (integral &lt; -maxIntegral) integral = -maxIntegral;
</code></pre></div></div> <h3 id="derivative-control-d-the-predictor">Derivative Control (D): The Predictor</h3> <p>The derivative term responds to the rate of change of error, providing predictive control:</p> \[u_d(t) = K_d \frac{d}{dt}e(t)\] <p><strong>Benefits:</strong></p> <ul> <li><strong>Damping</strong>: Reduces oscillations and overshoot</li> <li><strong>Anticipatory action</strong>: Responds to trends in error change</li> <li><strong>Stability improvement</strong>: Helps stabilize systems that would otherwise be unstable</li> </ul> <p><strong>Challenges:</strong></p> <ul> <li><strong>Noise sensitivity</strong>: Amplifies high-frequency noise in the error signal</li> <li><strong>Derivative kick</strong>: Can cause sudden jumps in output when the setpoint changes</li> </ul> <h2 id="the-mathematics-of-stability">The Mathematics of Stability</h2> <p>The stability of a PID-controlled system can be analyzed using classical control theory. The characteristic equation of a second-order system with PID control is:</p> \[s^3 + \frac{K_d}{m}s^2 + \frac{K_p}{m}s + \frac{K_i}{m} = 0\] <p>For stability, all poles must be in the left half-plane. This constrains the relationship between P, I, and D gains.</p> <h3 id="ziegler-nichols-tuning-method">Ziegler-Nichols Tuning Method</h3> <p>One of the most famous tuning methods, developed in 1942:</p> <ol> <li><strong>Step 1</strong>: Set I=0, D=0, increase P until the system oscillates</li> <li><strong>Step 2</strong>: Record the critical gain K_c and oscillation period T_c</li> <li><strong>Step 3</strong>: Apply the tuning rules: <ul> <li>P-only: K_p = 0.5 × K_c</li> <li>PI: K_p = 0.45 × K_c, K_i = 1.2 × K_p / T_c</li> <li>PID: K_p = 0.6 × K_c, K_i = 2 × K_p / T_c, K_d = K_p × T_c / 8</li> </ul> </li> </ol> <h2 id="modern-pid-variants-and-enhancements">Modern PID Variants and Enhancements</h2> <h3 id="anti-windup-mechanisms">Anti-Windup Mechanisms</h3> <p><strong>Back-calculation method:</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if (output &gt; outputMax) {
    integral = integral - (output - outputMax) / Ki;
    output = outputMax;
}
</code></pre></div></div> <p><strong>Conditional integration:</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if (abs(error) &lt; errorThreshold &amp;&amp; abs(output) &lt; outputMax) {
    integral += error * dt;
}
</code></pre></div></div> <h3 id="derivative-on-measurement-dom">Derivative on Measurement (DoM)</h3> <p>Instead of differentiating the error (which causes derivative kick), differentiate the process variable:</p> \[u_d(t) = -K_d \frac{d}{dt}y(t)\] <p>This eliminates derivative kick when the setpoint changes.</p> <h3 id="setpoint-weighting">Setpoint Weighting</h3> <p>Allows different responses to setpoint changes vs. disturbances:</p> \[u(t) = K_p(b \cdot r(t) - y(t)) + K_i \int_0^t e(\tau) d\tau - K_d \frac{d}{dt}y(t)\] <p>Where b is the setpoint weighting factor (typically 0.5-1.0).</p> <h2 id="real-world-applications-and-case-studies">Real-World Applications and Case Studies</h2> <h3 id="case-study-1-quadrotor-drone-stabilization">Case Study 1: Quadrotor Drone Stabilization</h3> <p>Modern quadrotor drones use cascaded PID controllers:</p> <p><strong>Attitude Control Loop (Inner):</strong></p> <ul> <li><strong>Input</strong>: Desired vs. actual roll/pitch/yaw angles</li> <li><strong>Output</strong>: Motor thrust commands</li> <li><strong>Typical gains</strong>: Kp=4.0, Ki=0.1, Kd=0.8</li> <li><strong>Update rate</strong>: 1000 Hz</li> </ul> <p><strong>Position Control Loop (Outer):</strong></p> <ul> <li><strong>Input</strong>: Desired vs. actual position</li> <li><strong>Output</strong>: Attitude commands to inner loop</li> <li><strong>Typical gains</strong>: Kp=1.5, Ki=0.3, Kd=1.2</li> <li><strong>Update rate</strong>: 100 Hz</li> </ul> <h3 id="case-study-2-industrial-temperature-control">Case Study 2: Industrial Temperature Control</h3> <p>A pharmaceutical reactor requires ±0.1°C temperature control:</p> <p><strong>System characteristics:</strong></p> <ul> <li><strong>Time constant</strong>: 45 seconds (thermal mass)</li> <li><strong>Dead time</strong>: 8 seconds (sensor delay)</li> <li><strong>Disturbances</strong>: Ambient temperature, cooling water temperature</li> </ul> <p><strong>PID Configuration:</strong></p> <ul> <li><strong>Kp</strong>: 2.5 (moderate for stability)</li> <li><strong>Ki</strong>: 0.08 (slow integration to prevent overshoot)</li> <li><strong>Kd</strong>: 15.0 (high derivative to counteract thermal lag)</li> <li><strong>Sample time</strong>: 1 second</li> </ul> <h3 id="case-study-3-spacecraft-attitude-control">Case Study 3: Spacecraft Attitude Control</h3> <p>The International Space Station uses PID control for attitude maintenance:</p> <p><strong>Challenges:</strong></p> <ul> <li><strong>Microgravity environment</strong>: No gravitational restoring torque</li> <li><strong>Flexible structure</strong>: Solar panels and modules create structural resonances</li> <li><strong>Fuel conservation</strong>: Minimize thruster usage</li> </ul> <p><strong>Solution</strong>: Multi-mode PID with gain scheduling</p> <ul> <li><strong>Fine pointing mode</strong>: High precision for experiments</li> <li><strong>Coarse pointing mode</strong>: Fuel-efficient for normal operations</li> <li><strong>Maneuver mode</strong>: Fast response for orbit adjustments</li> </ul> <h2 id="advanced-topics">Advanced Topics</h2> <h3 id="gain-scheduling">Gain Scheduling</h3> <p>PID gains can be adjusted based on operating conditions:</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">updateGains</span><span class="p">(</span><span class="nx">operatingPoint</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if </span><span class="p">(</span><span class="nx">operatingPoint</span><span class="p">.</span><span class="nx">velocity</span> <span class="o">&lt;</span> <span class="mf">0.1</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Fine control near target</span>
        <span class="nx">pid</span><span class="p">.</span><span class="nf">setGains</span><span class="p">(</span><span class="mf">1.5</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// Aggressive control far from target</span>
        <span class="nx">pid</span><span class="p">.</span><span class="nf">setGains</span><span class="p">(</span><span class="mf">3.0</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="fuzzy-pid-control">Fuzzy PID Control</h3> <p>Combines fuzzy logic with PID control for non-linear systems:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>IF error is Large AND error_rate is Positive 
THEN Kp is High AND Ki is Low AND Kd is Medium
</code></pre></div></div> <h3 id="model-predictive-control-mpc">Model Predictive Control (MPC)</h3> <p>The next evolution beyond PID, MPC optimizes control actions over a prediction horizon:</p> \[\min_{u} \sum_{k=0}^{N-1} ||y(k+1) - r(k+1)||^2 + \lambda ||u(k)||^2\] <p>Subject to constraints on inputs and outputs.</p> <h2 id="implementation-best-practices">Implementation Best Practices</h2> <h3 id="1-sample-time-selection">1. Sample Time Selection</h3> <ul> <li><strong>Rule of thumb</strong>: Sample time should be 1/10 to 1/20 of the dominant time constant</li> <li><strong>Too fast</strong>: Wasted computation, noise amplification</li> <li><strong>Too slow</strong>: Poor performance, potential instability</li> </ul> <h3 id="2-integral-term-management">2. Integral Term Management</h3> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Reset integral term when switching modes</span>
<span class="k">if </span><span class="p">(</span><span class="nx">modeChanged</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">pid</span><span class="p">.</span><span class="nf">reset</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// Limit integral accumulation</span>
<span class="kd">const</span> <span class="nx">maxIntegral</span> <span class="o">=</span> <span class="nx">outputRange</span> <span class="o">/</span> <span class="nx">Ki</span><span class="p">;</span>
<span class="nx">integral</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">max</span><span class="p">(</span><span class="o">-</span><span class="nx">maxIntegral</span><span class="p">,</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">min</span><span class="p">(</span><span class="nx">maxIntegral</span><span class="p">,</span> <span class="nx">integral</span><span class="p">));</span>
</code></pre></div></div> <h3 id="3-derivative-term-filtering">3. Derivative Term Filtering</h3> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Low-pass filter for derivative term</span>
<span class="kd">const</span> <span class="nx">alpha</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">;</span> <span class="c1">// Filter coefficient</span>
<span class="nx">derivativeFiltered</span> <span class="o">=</span> <span class="nx">alpha</span> <span class="o">*</span> <span class="nx">derivative</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="nx">alpha</span><span class="p">)</span> <span class="o">*</span> <span class="nx">derivativeFiltered</span><span class="p">;</span>
</code></pre></div></div> <h3 id="4-output-saturation-handling">4. Output Saturation Handling</h3> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">output</span> <span class="o">=</span> <span class="nx">pTerm</span> <span class="o">+</span> <span class="nx">iTerm</span> <span class="o">+</span> <span class="nx">dTerm</span><span class="p">;</span>
<span class="k">if </span><span class="p">(</span><span class="nx">output</span> <span class="o">&gt;</span> <span class="nx">outputMax</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">output</span> <span class="o">=</span> <span class="nx">outputMax</span><span class="p">;</span>
    <span class="c1">// Back-calculate integral to prevent windup</span>
    <span class="nx">iTerm</span> <span class="o">=</span> <span class="nx">outputMax</span> <span class="o">-</span> <span class="nx">pTerm</span> <span class="o">-</span> <span class="nx">dTerm</span><span class="p">;</span>
    <span class="nx">integral</span> <span class="o">=</span> <span class="nx">iTerm</span> <span class="o">/</span> <span class="nx">Ki</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h2 id="troubleshooting-common-issues">Troubleshooting Common Issues</h2> <h3 id="problem-system-oscillates">Problem: System Oscillates</h3> <p><strong>Symptoms</strong>: Continuous oscillation around setpoint <strong>Causes</strong>:</p> <ul> <li>P gain too high</li> <li>I gain too high</li> <li>Insufficient D gain <strong>Solutions</strong>:</li> <li>Reduce P gain by 25%</li> <li>Reduce I gain by 50%</li> <li>Increase D gain by 25%</li> </ul> <h3 id="problem-slow-response">Problem: Slow Response</h3> <p><strong>Symptoms</strong>: Takes too long to reach setpoint <strong>Causes</strong>:</p> <ul> <li>P gain too low</li> <li>I gain too low <strong>Solutions</strong>:</li> <li>Increase P gain gradually</li> <li>Increase I gain moderately</li> </ul> <h3 id="problem-steady-state-error">Problem: Steady-State Error</h3> <p><strong>Symptoms</strong>: System settles away from setpoint <strong>Causes</strong>:</p> <ul> <li>No integral term (I=0)</li> <li>Integral saturation</li> <li>Output saturation <strong>Solutions</strong>:</li> <li>Add integral term</li> <li>Implement anti-windup</li> <li>Check actuator limits</li> </ul> <h3 id="problem-derivative-kick">Problem: Derivative Kick</h3> <p><strong>Symptoms</strong>: Large output spike when setpoint changes <strong>Causes</strong>:</p> <ul> <li>Derivative acting on error instead of measurement <strong>Solutions</strong>:</li> <li>Use derivative-on-measurement</li> <li>Add setpoint ramping</li> </ul> <h2 id="the-future-of-control">The Future of Control</h2> <p>While PID control remains the workhorse of industrial automation, modern control strategies are emerging:</p> <h3 id="machine-learning-enhanced-pid">Machine Learning Enhanced PID</h3> <p>Neural networks can learn optimal PID gains for different operating conditions:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Simplified concept
</span><span class="n">pid_gains</span> <span class="o">=</span> <span class="n">neural_network</span><span class="p">.</span><span class="nf">predict</span><span class="p">([</span>
    <span class="n">current_error</span><span class="p">,</span>
    <span class="n">system_state</span><span class="p">,</span>
    <span class="n">disturbance_estimate</span>
<span class="p">])</span>
</code></pre></div></div> <h3 id="adaptive-control">Adaptive Control</h3> <p>Controllers that automatically adjust to changing system dynamics:</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Recursive least squares parameter estimation</span>
<span class="kd">function</span> <span class="nf">updateSystemModel</span><span class="p">(</span><span class="nx">input</span><span class="p">,</span> <span class="nx">output</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Update internal model of system</span>
    <span class="c1">// Adjust PID gains based on new model</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="digital-twin-integration">Digital Twin Integration</h3> <p>Real-time system models that predict optimal control actions:</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">predictiveControl</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">futureStates</span> <span class="o">=</span> <span class="nx">digitalTwin</span><span class="p">.</span><span class="nf">simulate</span><span class="p">(</span><span class="nx">currentState</span><span class="p">,</span> <span class="nx">proposedActions</span><span class="p">);</span>
    <span class="k">return</span> <span class="nf">optimizeActions</span><span class="p">(</span><span class="nx">futureStates</span><span class="p">,</span> <span class="nx">objectives</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <h2 id="conclusion">Conclusion</h2> <p>PID control represents one of the most successful engineering solutions ever developed. Its mathematical elegance, practical effectiveness, and broad applicability have made it indispensable across countless industries. From the precision docking of spacecraft to the smooth operation of your car’s cruise control, PID controllers quietly work behind the scenes, providing the stable, predictable behavior we’ve come to expect from modern technology.</p> <p>The beauty of PID lies not just in its mathematical foundation, but in its intuitive nature - proportional action for immediate response, integral action for long-term accuracy, and derivative action for smooth, stable behavior. These three simple concepts, when properly tuned and combined, can control everything from the temperature in your home to the attitude of satellites in orbit.</p> <p>As we move toward an increasingly automated future, understanding PID control becomes ever more valuable. Whether you’re designing the next generation of autonomous vehicles, developing precision manufacturing equipment, or simply trying to understand how the technology around you works, PID control provides a fundamental framework for thinking about feedback, stability, and control.</p> <p>The interactive simulation above is just the beginning. Try experimenting with different parameter combinations, observe how each component contributes to the overall behavior, and you’ll gain an intuitive understanding of one of engineering’s most powerful tools.</p>]]></content><author><name></name></author><category term="blog"/><category term="control-systems"/><category term="pid"/><category term="simulation"/><category term="spacecraft"/><summary type="html"><![CDATA[Understanding PID control through an interactive spacecraft docking simulation. Tune P, I, and D parameters to master the art of feedback control.]]></summary></entry><entry><title type="html">Energy Drift Playground — Simple Pendulum</title><link href="https://saeed1262.github.io/blog/2024/energy-drift-playground/" rel="alternate" type="text/html" title="Energy Drift Playground — Simple Pendulum"/><published>2024-08-24T00:00:00+00:00</published><updated>2024-08-24T00:00:00+00:00</updated><id>https://saeed1262.github.io/blog/2024/energy-drift-playground</id><content type="html" xml:base="https://saeed1262.github.io/blog/2024/energy-drift-playground/"><![CDATA[<h2 id="the-foundation-of-computational-physics">The Foundation of Computational Physics</h2> <p>In the realm of computational physics, one fundamental challenge towers above all others: how do we preserve the essential properties of physical systems when translating continuous mathematics into discrete computations? This question lies at the heart of every physics simulation, from climate models predicting global warming to spacecraft navigation systems guiding interplanetary missions.</p> <p><strong>Energy drift</strong> represents perhaps the most critical manifestation of numerical error in conservative systems. When simulating a frictionless pendulum, total mechanical energy must remain constant for all time—this is not merely a numerical preference, but a fundamental law of physics. Yet many integration schemes systematically violate this conservation, leading to completely unphysical behavior that can invalidate years of computational work.</p> <p>What if we could visualize this phenomenon in real-time? What if we could <em>feel</em> how different mathematical approaches either preserve or destroy the fundamental structure of physical reality?</p> <h2 id="the-mathematical-foundation-of-conservative-systems">The Mathematical Foundation of Conservative Systems</h2> <h3 id="hamiltonian-mechanics-and-phase-space">Hamiltonian Mechanics and Phase Space</h3> <p>A pendulum with length \(L\) and mass \(m\) under gravity \(g\) is governed by the Hamiltonian:</p> \[H(q, p) = \frac{p^2}{2mL^2} + mgL(1 - \cos q)\] <p>where \(q = \theta\) is the angular position and \(p = mL^2\dot{\theta}\) is the canonical momentum.</p> <p>Hamilton’s equations provide the time evolution:</p> \[\frac{dq}{dt} = \frac{\partial H}{\partial p} = \frac{p}{mL^2}\] \[\frac{dp}{dt} = -\frac{\partial H}{\partial q} = -mgL\sin q\] <p>This formulation reveals the <strong>symplectic structure</strong> underlying all Hamiltonian systems—a geometric property that governs how phase space volumes evolve over time.</p> <h3 id="liouvilles-theorem-and-phase-space-conservation">Liouville’s Theorem and Phase Space Conservation</h3> <p>Liouville’s theorem states that Hamiltonian flow preserves phase space volume:</p> \[\frac{d}{dt}\int_{\Omega(t)} dq \, dp = 0\] <p>This fundamental result has profound implications for numerical integration: <strong>any integration scheme that preserves phase space volume will maintain bounded energy errors over arbitrarily long time scales</strong>.</p> <h3 id="the-symplectic-condition">The Symplectic Condition</h3> <p>A transformation \((q_n, p_n) \rightarrow (q_{n+1}, p_{n+1})\) is symplectic if it preserves the symplectic form:</p> \[dp_{n+1} \wedge dq_{n+1} = dp_n \wedge dq_n\] <p>Equivalently, if we write the transformation as \(\mathbf{z}_{n+1} = \mathbf{M}\mathbf{z}_n\) where \(\mathbf{z} = (q, p)^T\), then \(\mathbf{M}\) must satisfy:</p> \[\mathbf{M}^T \mathbf{J} \mathbf{M} = \mathbf{J}\] <p>where \(\mathbf{J} = \begin{pmatrix} 0 &amp; 1 \\ -1 &amp; 0 \end{pmatrix}\) is the symplectic matrix.</p> <h2 id="visualizing-phase-space-the-geometric-perspective">Visualizing Phase Space: The Geometric Perspective</h2> <p>Before exploring individual integration methods, we must understand how they behave in <strong>phase space</strong>—the natural coordinate system for Hamiltonian dynamics.</p> <h3 id="phase-space-trajectories-and-conservation">Phase Space Trajectories and Conservation</h3> <p>In phase space, each point represents a complete state $(\theta, \omega)$ of the pendulum. As time evolves, the system traces out a trajectory in this space. For the conservative pendulum, these trajectories have remarkable properties:</p> <p><strong>Energy Conservation as Geometric Constraint:</strong> Each trajectory lies on a curve of constant energy: \(H(\theta, \omega) = \frac{1}{2}\omega^2 + \frac{g}{L}(1 - \cos\theta) = E_0\)</p> <p><strong>Three Regimes of Motion:</strong></p> <ul> <li><strong>Small oscillations</strong> (\(E_0 &lt; 2g/L\)): Closed elliptical orbits around \((\theta, \omega) = (0, 0)\)</li> <li><strong>Large oscillations</strong> (\(E_0 &gt; 2g/L\)): Open trajectories representing continuous rotation</li> <li><strong>Separatrix</strong> (\(E_0 = 2g/L\)): The critical boundary between oscillation and rotation</li> </ul> <div id="phase-space-theory" style="max-width: 100%; margin: 30px 0;"> <div style="background-color: var(--global-card-bg-color); border-radius: 12px; padding: 25px; color: var(--global-text-color); border: 1px solid var(--global-border-color); box-shadow: var(--global-box-shadow-lg);"> <h4 style="margin: 0 0 20px 0; color: var(--global-theme-color);">Interactive Phase Space Explorer</h4> <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;"> <div> <h5 style="color: var(--global-heading-color);">Theoretical Phase Portrait</h5> <canvas id="theory-phase-canvas" width="350" height="350" style="background-color: var(--global-bg-color-secondary); border-radius: 8px; width: 100%; border: 1px solid var(--global-border-color);"></canvas> <div style="margin-top: 10px; font-size: 12px;"> <div style="color: var(--global-text-color);">Click on the phase space to set initial conditions!</div> <div style="color: #3b82f6;">Current Energy: <span id="theory-energy">2.45</span> J</div> </div> </div> <div> <h5 style="color: var(--global-heading-color);">Method Comparison</h5> <canvas id="comparison-phase-canvas" width="350" height="350" style="background-color: var(--global-bg-color-secondary); border-radius: 8px; width: 100%; border: 1px solid var(--global-border-color);"></canvas> <div style="margin-top: 10px;"> <label style="color: var(--global-text-color);">Integration Method: </label> <select id="phase-method-select" style="background-color: var(--global-card-bg-color); color: var(--global-text-color); border: 1px solid var(--global-border-color); padding: 5px; border-radius: 4px;"> <option value="symplectic">Symplectic Euler</option> <option value="euler">Explicit Euler</option> <option value="verlet">Velocity Verlet</option> <option value="rk4">RK4</option> <option value="all">All Methods</option> </select> </div> </div> </div> <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;"> <div> <h5 style="color: var(--global-heading-color);">Simulation Parameters</h5> <div style="margin-bottom: 10px;"> <label style="color: var(--global-text-color);">Time Step: <span id="phase-timestep">5</span> ms</label> <input type="range" id="phase-timestep-slider" min="1" max="20" value="5" style="width: 100%; accent-color: var(--global-theme-color);"/> </div> <div style="margin-bottom: 10px;"> <label style="color: var(--global-text-color);">Simulation Speed: <span id="phase-speed">1</span>x</label> <input type="range" id="phase-speed-slider" min="1" max="10" value="1" style="width: 100%; accent-color: var(--global-theme-color);"/> </div> </div> <div> <h5 style="color: var(--global-heading-color);">Current State</h5> <div style="font-size: 12px;"> <div style="color: var(--global-text-color);">Time: <span id="phase-time">0.00</span>s</div> <div style="color: var(--global-text-color);">θ: <span id="phase-theta">0.785</span> rad</div> <div style="color: var(--global-text-color);">ω: <span id="phase-omega">0.000</span> rad/s</div> <div style="color: #ef4444; margin-top: 5px;">Energy Error: <span id="phase-energy-error">0.00</span>%</div> </div> </div> </div> <div style="text-align: center;"> <button id="phase-play-pause" style="background: var(--global-gradient-primary); border: none; color: white; padding: 8px 16px; border-radius: 6px; margin-right: 10px; font-weight: 600; cursor: pointer;">Pause</button> <button id="phase-reset" style="background: #FF6B6B; border: none; color: white; padding: 8px 16px; border-radius: 6px; margin-right: 10px; font-weight: 600; cursor: pointer;">Reset</button> <button id="phase-clear" style="background: #6B7280; border: none; color: white; padding: 8px 16px; border-radius: 6px; font-weight: 600; cursor: pointer;">Clear Trails</button> </div> </div> </div> <h3 id="the-symplectic-advantage-geometric-structure-preservation">The Symplectic Advantage: Geometric Structure Preservation</h3> <p>The key insight is that <strong>symplectic methods preserve the geometric structure of phase space</strong>, while non-symplectic methods systematically distort it:</p> <p><strong>Explicit Euler:</strong> Non-symplectic transformation causes trajectories to spiral outward, violating energy conservation.</p> <p><strong>Symplectic Euler:</strong> Despite first-order accuracy, preserves the topological structure of phase space, keeping trajectories on correct energy surfaces.</p> <p><strong>Velocity Verlet:</strong> Combines symplectic structure preservation with second-order accuracy, producing nearly perfect phase space trajectories.</p> <p><strong>RK4:</strong> High local accuracy but lacks symplectic structure, leading to slow drift off energy surfaces.</p> <h2 id="the-critical-challenge-long-term-stability-vs-local-accuracy">The Critical Challenge: Long-Term Stability vs. Local Accuracy</h2> <p>The naive approach to numerical integration prioritizes <strong>local truncation error</strong>—how well each individual step approximates the true solution. However, for conservative systems, this focus can be catastrophically misguided.</p> <p>Consider two fundamental questions:</p> <ol> <li>Should we choose a method with fourth-order local accuracy that allows energy to drift systematically?</li> <li>Or should we prefer a first-order method that maintains perfect energy conservation structure?</li> </ol> <p>For short simulations, local accuracy dominates. For long-term evolution—climate modeling, orbital mechanics, molecular dynamics—geometric structure preservation becomes paramount.</p> <h2 id="interactive-laboratory-four-integration-paradigms">Interactive Laboratory: Four Integration Paradigms</h2> <p>The simple pendulum provides an ideal testbed because:</p> <ul> <li><strong>Conservative system</strong>: Energy conservation is mathematically guaranteed</li> <li><strong>Nonlinear dynamics</strong>: Small errors can compound exponentially</li> <li><strong>Well-understood physics</strong>: We know the ground truth behavior</li> <li><strong>Rich phase space</strong>: Exhibits libration, circulation, and separatrix dynamics</li> </ul> <h3 id="method-1-explicit-euler---the-unstable-baseline">Method 1: Explicit Euler - The Unstable Baseline</h3> <p>The <strong>Explicit Euler</strong> method represents the most straightforward approach to numerical integration:</p> <p><strong>Algorithm:</strong> \(\omega_{n+1} = \omega_n + h \cdot f(\theta_n, \omega_n)\) \(\theta_{n+1} = \theta_n + h \cdot \omega_n\)</p> <p>where \(f(\theta, \omega) = -\frac{g}{L}\sin(\theta)\) is the angular acceleration.</p> <p><strong>Mathematical Analysis:</strong></p> <ul> <li><strong>Order of accuracy</strong>: \(O(h)\)</li> <li><strong>Stability</strong>: Conditionally stable with severe restrictions on \(h\)</li> <li><strong>Energy behavior</strong>: Systematic energy growth due to the use of “stale” velocity information</li> <li><strong>Phase space</strong>: Non-symplectic transformation that violates Liouville’s theorem</li> </ul> <p><strong>The Fundamental Flaw:</strong> Explicit Euler uses the velocity at time \(t_n\) to update position to time \(t_{n+1}\), while using the acceleration at time \(t_n\) to update velocity to time \(t_{n+1}\). This temporal mismatch systematically overestimates kinetic energy, leading to the characteristic exponential energy growth.</p> <div id="euler-demo" style="max-width: 100%; margin: 30px 0; box-shadow: var(--global-box-shadow-lg);"> <div style="background-color: var(--global-card-bg-color); border-radius: 12px; padding: 30px; color: var(--global-text-color); border: 1px solid var(--global-border-color);"> <div style="display: flex; align-items: center; margin-bottom: 25px;"> <div style="width: 4px; height: 30px; background: linear-gradient(to bottom, #ef4444, #dc2626); border-radius: 2px; margin-right: 15px;"></div> <h4 style="margin: 0; color: #ef4444; font-size: 1.4em; font-weight: 600;">Explicit Euler Method</h4> <span style="margin-left: auto; background: rgba(239, 68, 68, 0.15); color: #ef4444; padding: 4px 12px; border-radius: 20px; font-size: 0.8em; font-weight: 500;">Energy Growth</span> </div> <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 25px; margin-bottom: 25px;"> <div style="background-color: var(--global-bg-color-secondary); border-radius: 12px; padding: 20px; border: 1px solid var(--global-border-color);"> <h5 style="margin: 0 0 15px 0; color: var(--global-heading-color); font-size: 1.1em;">Pendulum Animation</h5> <div style="position: relative; border-radius: 10px; overflow: hidden; box-shadow: var(--global-box-shadow-sm);"> <canvas id="euler-canvas" width="280" height="280" style="background-color: var(--global-bg-color-secondary); width: 100%; display: block;"></canvas> </div> </div> <div style="background-color: var(--global-bg-color-secondary); border-radius: 12px; padding: 20px; border: 1px solid var(--global-border-color);"> <h5 style="margin: 0 0 15px 0; color: var(--global-heading-color); font-size: 1.1em;">Energy Over Time</h5> <div style="position: relative; border-radius: 10px; overflow: hidden; box-shadow: var(--global-box-shadow-sm);"> <canvas id="euler-energy" width="280" height="280" style="background-color: var(--global-bg-color-secondary); width: 100%; display: block;"></canvas> </div> </div> </div> <div style="display: flex; align-items: center; justify-content: space-between; background-color: var(--global-bg-color-secondary); border-radius: 10px; padding: 15px; border: 1px solid var(--global-border-color);"> <div style="display: flex; align-items: center; gap: 15px;"> <label style="color: var(--global-text-color); font-weight: 500;">Time Step: <span id="euler-timestep" style="color: #ef4444; font-weight: 600;">10</span> ms</label> <input type="range" id="euler-slider" min="1" max="50" value="10" style="width: 200px; accent-color: #ef4444;"/> </div> <div style="display: flex; gap: 10px;"> <button id="euler-play-pause" style="background: linear-gradient(135deg, #10b981, #059669); border: none; color: white; padding: 8px 16px; border-radius: 8px; font-weight: 600; cursor: pointer; transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); box-shadow: var(--global-box-shadow-md);">Pause</button> <button id="euler-reset" style="background: linear-gradient(135deg, #ef4444, #dc2626); border: none; color: white; padding: 8px 20px; border-radius: 8px; font-weight: 600; cursor: pointer; transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); box-shadow: var(--global-box-shadow-md);">Reset</button> </div> </div> <div style="margin-top: 15px; text-align: center; font-size: 14px;"> Energy Error: <span id="euler-error" style="background: rgba(239, 68, 68, 0.2); color: #ef4444; padding: 4px 12px; border-radius: 20px; font-weight: 600;">0.00%</span> </div> </div> </div> <h3 id="method-2-symplectic-euler---the-geometric-insight">Method 2: Symplectic Euler - The Geometric Insight</h3> <p><strong>Symplectic Euler</strong> makes a subtle but revolutionary change: update momentum first, then use the updated momentum to advance position.</p> <p><strong>Algorithm:</strong> \(p_{n+1} = p_n + h \cdot F(q_n)\) \(q_{n+1} = q_n + h \cdot \frac{p_{n+1}}{m}\)</p> <p>For the pendulum: \(\omega_{n+1} = \omega_n + h \cdot \left(-\frac{g}{L}\sin(\theta_n)\right)\), then \(\theta_{n+1} = \theta_n + h \cdot \omega_{n+1}\)</p> <p><strong>Symplectic Structure Preservation:</strong> For the linearized harmonic oscillator, the transformation matrix for symplectic Euler is: \(\mathbf{M} = \begin{pmatrix} 1 - h^2 \omega_0^2 &amp; h \\ - h \omega_0^2 &amp; 1 \end{pmatrix}\)</p> <p>One can verify that \(\det(\mathbf{M}) = 1\), ensuring the method is symplectic (area-preserving in phase space).</p> <p><strong>Key Properties:</strong></p> <ul> <li><strong>Order of accuracy</strong>: Still \(O(h)\) locally</li> <li><strong>Global behavior</strong>: Energy oscillates with bounded amplitude</li> <li><strong>Reversibility</strong>: Time-reversible integration</li> <li><strong>Long-term stability</strong>: No secular drift in energy</li> </ul> <p><strong>The Geometric Miracle:</strong> Despite having the same local accuracy as Explicit Euler, Symplectic Euler captures the essential geometric structure of Hamiltonian flow. This leads to fundamentally different long-term behavior—energy remains bounded rather than growing exponentially.</p> <div id="symplectic-demo" style="max-width: 100%; margin: 30px 0; box-shadow: var(--global-box-shadow-lg);"> <div style="background-color: var(--global-card-bg-color); border-radius: 12px; padding: 30px; color: var(--global-text-color); border: 1px solid var(--global-border-color);"> <div style="display: flex; align-items: center; margin-bottom: 25px;"> <div style="width: 4px; height: 30px; background: linear-gradient(to bottom, #22c55e, #16a34a); border-radius: 2px; margin-right: 15px;"></div> <h4 style="margin: 0; color: #22c55e; font-size: 1.4em; font-weight: 600;">Symplectic Euler Method</h4> <span style="margin-left: auto; background: rgba(34, 197, 94, 0.15); color: #22c55e; padding: 4px 12px; border-radius: 20px; font-size: 0.8em; font-weight: 500;">Energy Conservation</span> </div> <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 25px; margin-bottom: 25px;"> <div style="background-color: var(--global-bg-color-secondary); border-radius: 12px; padding: 20px; border: 1px solid var(--global-border-color);"> <h5 style="margin: 0 0 15px 0; color: var(--global-heading-color); font-size: 1.1em;">Pendulum Animation</h5> <div style="position: relative; border-radius: 10px; overflow: hidden; box-shadow: var(--global-box-shadow-sm);"> <canvas id="symplectic-canvas" width="280" height="280" style="background-color: var(--global-bg-color-secondary); width: 100%; display: block;"></canvas> </div> </div> <div style="background-color: var(--global-bg-color-secondary); border-radius: 12px; padding: 20px; border: 1px solid var(--global-border-color);"> <h5 style="margin: 0 0 15px 0; color: var(--global-heading-color); font-size: 1.1em;">Energy Over Time</h5> <div style="position: relative; border-radius: 10px; overflow: hidden; box-shadow: var(--global-box-shadow-sm);"> <canvas id="symplectic-energy" width="280" height="280" style="background-color: var(--global-bg-color-secondary); width: 100%; display: block;"></canvas> </div> </div> </div> <div style="display: flex; align-items: center; justify-content: space-between; background-color: var(--global-bg-color-secondary); border-radius: 10px; padding: 15px; border: 1px solid var(--global-border-color);"> <div style="display: flex; align-items: center; gap: 15px;"> <label style="color: var(--global-text-color); font-weight: 500;">Time Step: <span id="symplectic-timestep" style="color: #22c55e; font-weight: 600;">10</span> ms</label> <input type="range" id="symplectic-slider" min="1" max="50" value="10" style="width: 200px; accent-color: #22c55e;"/> </div> <div style="display: flex; gap: 10px;"> <button id="symplectic-play-pause" style="background: linear-gradient(135deg, #10b981, #059669); border: none; color: white; padding: 8px 16px; border-radius: 8px; font-weight: 600; cursor: pointer; transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); box-shadow: var(--global-box-shadow-md);">Pause</button> <button id="symplectic-reset" style="background: linear-gradient(135deg, #22c55e, #16a34a); border: none; color: white; padding: 8px 20px; border-radius: 8px; font-weight: 600; cursor: pointer; transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); box-shadow: var(--global-box-shadow-md);">Reset</button> </div> </div> <div style="margin-top: 15px; text-align: center; font-size: 14px;"> Energy Error: <span id="symplectic-error" style="background: rgba(34, 197, 94, 0.2); color: #22c55e; padding: 4px 12px; border-radius: 20px; font-weight: 600;">0.00%</span> </div> </div> </div> <h3 id="method-3-velocity-verlet---the-optimal-balance">Method 3: Velocity Verlet - The Optimal Balance</h3> <p><strong>Velocity Verlet</strong> (also known as Leapfrog) combines symplectic structure with higher-order accuracy through a three-stage process:</p> <p><strong>Algorithm:</strong> \(v_{n+1/2} = v_n + \frac{h}{2} a(x_n)\) \(x_{n+1} = x_n + h \cdot v_{n+1/2}\) \(v_{n+1} = v_{n+1/2} + \frac{h}{2} a(x_{n+1})\)</p> <p>For the pendulum: \(\omega_{n+1/2} = \omega_n + \frac{h}{2} \left(-\frac{g}{L}\sin(\theta_n)\right)\) \(\theta_{n+1} = \theta_n + h \cdot \omega_{n+1/2}\) \(\omega_{n+1} = \omega_{n+1/2} + \frac{h}{2} \left(-\frac{g}{L}\sin(\theta_{n+1})\right)\)</p> <p><strong>Superior Properties:</strong></p> <ul> <li><strong>Order of accuracy</strong>: \(O(h^2)\) - second-order accurate</li> <li><strong>Symplectic</strong>: Preserves phase space structure exactly</li> <li><strong>Time-reversible</strong>: \(\mathbf{M}^{-1} = \mathbf{M}^T\)</li> <li><strong>Stability</strong>: Excellent long-term energy conservation</li> </ul> <p><strong>Computational Cost Analysis:</strong></p> <ul> <li><strong>Function evaluations</strong>: 2 per timestep (vs. 1 for Euler methods)</li> <li><strong>Memory overhead</strong>: Minimal (stores half-step velocity)</li> <li><strong>Efficiency</strong>: Optimal balance of accuracy and computational cost</li> </ul> <p><strong>Why Verlet Dominates Molecular Dynamics:</strong> The method’s symplectic nature combined with second-order accuracy makes it the gold standard for molecular dynamics simulations, where energy conservation over millions of timesteps is crucial.</p> <div id="verlet-demo" style="max-width: 100%; margin: 30px 0; box-shadow: var(--global-box-shadow-lg);"> <div style="background-color: var(--global-card-bg-color); border-radius: 12px; padding: 30px; color: var(--global-text-color); border: 1px solid var(--global-border-color);"> <div style="display: flex; align-items: center; margin-bottom: 25px;"> <div style="width: 4px; height: 30px; background: linear-gradient(to bottom, #3b82f6, #2563eb); border-radius: 2px; margin-right: 15px;"></div> <h4 style="margin: 0; color: #3b82f6; font-size: 1.4em; font-weight: 600;">Velocity Verlet Method</h4> <span style="margin-left: auto; background: rgba(59, 130, 246, 0.15); color: #3b82f6; padding: 4px 12px; border-radius: 20px; font-size: 0.8em; font-weight: 500;">Superior Accuracy</span> </div> <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 25px; margin-bottom: 25px;"> <div style="background-color: var(--global-bg-color-secondary); border-radius: 12px; padding: 20px; border: 1px solid var(--global-border-color);"> <h5 style="margin: 0 0 15px 0; color: var(--global-heading-color); font-size: 1.1em;">Pendulum Animation</h5> <div style="position: relative; border-radius: 10px; overflow: hidden; box-shadow: var(--global-box-shadow-sm);"> <canvas id="verlet-canvas" width="280" height="280" style="background-color: var(--global-bg-color-secondary); width: 100%; display: block;"></canvas> </div> </div> <div style="background-color: var(--global-bg-color-secondary); border-radius: 12px; padding: 20px; border: 1px solid var(--global-border-color);"> <h5 style="margin: 0 0 15px 0; color: var(--global-heading-color); font-size: 1.1em;">Energy Over Time</h5> <div style="position: relative; border-radius: 10px; overflow: hidden; box-shadow: var(--global-box-shadow-sm);"> <canvas id="verlet-energy" width="280" height="280" style="background-color: var(--global-bg-color-secondary); width: 100%; display: block;"></canvas> </div> </div> </div> <div style="display: flex; align-items: center; justify-content: space-between; background-color: var(--global-bg-color-secondary); border-radius: 10px; padding: 15px; border: 1px solid var(--global-border-color);"> <div style="display: flex; align-items: center; gap: 15px;"> <label style="color: var(--global-text-color); font-weight: 500;">Time Step: <span id="verlet-timestep" style="color: #3b82f6; font-weight: 600;">10</span> ms</label> <input type="range" id="verlet-slider" min="1" max="50" value="10" style="width: 200px; accent-color: #3b82f6;"/> </div> <div style="display: flex; gap: 10px;"> <button id="verlet-play-pause" style="background: linear-gradient(135deg, #10b981, #059669); border: none; color: white; padding: 8px 16px; border-radius: 8px; font-weight: 600; cursor: pointer; transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); box-shadow: var(--global-box-shadow-md);">Pause</button> <button id="verlet-reset" style="background: linear-gradient(135deg, #3b82f6, #2563eb); border: none; color: white; padding: 8px 20px; border-radius: 8px; font-weight: 600; cursor: pointer; transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); box-shadow: var(--global-box-shadow-md);">Reset</button> </div> </div> <div style="margin-top: 15px; text-align: center; font-size: 14px;"> Energy Error: <span id="verlet-error" style="background: rgba(59, 130, 246, 0.2); color: #3b82f6; padding: 4px 12px; border-radius: 20px; font-weight: 600;">0.00%</span> </div> </div> </div> <h3 id="method-4-runge-kutta-4th-order---the-accuracy-champion">Method 4: Runge-Kutta 4th Order - The Accuracy Champion</h3> <p><strong>RK4</strong> achieves exceptional local accuracy through four intermediate evaluations per timestep:</p> <p><strong>Algorithm:</strong> \(k_1 = f(t_n, y_n)\) \(k_2 = f(t_n + h/2, y_n + hk_1/2)\) \(k_3 = f(t_n + h/2, y_n + hk_2/2)\) \(k_4 = f(t_n + h, y_n + hk_3)\) \(y_{n+1} = y_n + \frac{h}{6}(k_1 + 2k_2 + 2k_3 + k_4)\)</p> <p><strong>Theoretical Foundation:</strong> RK4 achieves fourth-order accuracy by matching the first four terms of the Taylor series expansion. The method can be derived through the theory of trees (Butcher trees) which provide a systematic approach to constructing high-order Runge-Kutta methods.</p> <p><strong>The Symplectic Trade-off:</strong> While RK4 excels in local accuracy, it is <strong>not symplectic</strong>. For dissipative systems (with damping), this is often acceptable or even desirable. For conservative systems, the lack of geometric structure preservation can lead to subtle but systematic energy drift over long time scales.</p> <p><strong>Performance Characteristics:</strong></p> <ul> <li><strong>Order of accuracy</strong>: \(O(h^4)\) - fourth-order accurate</li> <li><strong>Function evaluations</strong>: 4 per timestep</li> <li><strong>Memory overhead</strong>: Minimal temporary storage</li> <li><strong>Computational cost</strong>: 4× that of simple methods per timestep</li> </ul> <div id="rk4-demo" style="max-width: 100%; margin: 30px 0; box-shadow: var(--global-box-shadow-lg);"> <div style="background-color: var(--global-card-bg-color); border-radius: 12px; padding: 30px; color: var(--global-text-color); border: 1px solid var(--global-border-color);"> <div style="display: flex; align-items: center; margin-bottom: 25px;"> <div style="width: 4px; height: 30px; background: linear-gradient(to bottom, #a855f7, #9333ea); border-radius: 2px; margin-right: 15px;"></div> <h4 style="margin: 0; color: #a855f7; font-size: 1.4em; font-weight: 600;">Runge-Kutta 4th Order</h4> <span style="margin-left: auto; background: rgba(168, 85, 247, 0.15); color: #a855f7; padding: 4px 12px; border-radius: 20px; font-size: 0.8em; font-weight: 500;">High Accuracy</span> </div> <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 25px; margin-bottom: 25px;"> <div style="background-color: var(--global-bg-color-secondary); border-radius: 12px; padding: 20px; border: 1px solid var(--global-border-color);"> <h5 style="margin: 0 0 15px 0; color: var(--global-heading-color); font-size: 1.1em;">Pendulum Animation</h5> <div style="position: relative; border-radius: 10px; overflow: hidden; box-shadow: var(--global-box-shadow-sm);"> <canvas id="rk4-canvas" width="280" height="280" style="background-color: var(--global-bg-color-secondary); width: 100%; display: block;"></canvas> </div> </div> <div style="background-color: var(--global-bg-color-secondary); border-radius: 12px; padding: 20px; border: 1px solid var(--global-border-color);"> <h5 style="margin: 0 0 15px 0; color: var(--global-heading-color); font-size: 1.1em;">Energy Over Time</h5> <div style="position: relative; border-radius: 10px; overflow: hidden; box-shadow: var(--global-box-shadow-sm);"> <canvas id="rk4-energy" width="280" height="280" style="background-color: var(--global-bg-color-secondary); width: 100%; display: block;"></canvas> </div> </div> </div> <div style="display: flex; align-items: center; justify-content: space-between; background-color: var(--global-bg-color-secondary); border-radius: 10px; padding: 15px; border: 1px solid var(--global-border-color);"> <div style="display: flex; align-items: center; gap: 15px;"> <label style="color: var(--global-text-color); font-weight: 500;">Time Step: <span id="rk4-timestep" style="color: #a855f7; font-weight: 600;">10</span> ms</label> <input type="range" id="rk4-slider" min="1" max="50" value="10" style="width: 200px; accent-color: #a855f7;"/> </div> <div style="display: flex; gap: 10px;"> <button id="rk4-play-pause" style="background: linear-gradient(135deg, #10b981, #059669); border: none; color: white; padding: 8px 16px; border-radius: 8px; font-weight: 600; cursor: pointer; transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); box-shadow: var(--global-box-shadow-md);">Pause</button> <button id="rk4-reset" style="background: linear-gradient(135deg, #a855f7, #9333ea); border: none; color: white; padding: 8px 20px; border-radius: 8px; font-weight: 600; cursor: pointer; transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); box-shadow: var(--global-box-shadow-md);">Reset</button> </div> </div> <div style="margin-top: 15px; text-align: center; font-size: 14px;"> Energy Error: <span id="rk4-error" style="background: rgba(168, 85, 247, 0.2); color: #a855f7; padding: 4px 12px; border-radius: 20px; font-weight: 600;">0.00%</span> </div> </div> </div> <h2 id="real-time-method-comparison-side-by-side-analysis">Real-Time Method Comparison: Side-by-Side Analysis</h2> <p>Experience all four integration methods simultaneously to see their fundamental differences in action.</p> <div id="realtime-comparison" style="max-width: 100%; margin: 30px 0;"> <div style="background-color: var(--global-card-bg-color); border-radius: 12px; padding: 25px; color: var(--global-text-color); border: 1px solid var(--global-border-color); box-shadow: var(--global-box-shadow-lg);"> <div style="display: flex; align-items: center; margin-bottom: 25px;"> <div style="width: 4px; height: 30px; background: linear-gradient(to bottom, var(--global-theme-color), var(--global-theme-color-dark)); border-radius: 2px; margin-right: 15px;"></div> <h4 style="margin: 0; color: var(--global-theme-color); font-size: 1.4em; font-weight: 600;">Real-Time Method Comparison</h4> <span style="margin-left: auto; background: rgba(59, 130, 246, 0.15); color: var(--global-theme-color); padding: 4px 12px; border-radius: 20px; font-size: 0.8em; font-weight: 500;">All Methods</span> </div> <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 20px;"> <div style="background-color: var(--global-bg-color-secondary); border-radius: 12px; padding: 15px; border: 1px solid var(--global-border-color);"> <h5 style="margin: 0 0 10px 0; color: #ef4444; font-size: 0.9em; text-align: center;">Explicit Euler</h5> <canvas id="realtime-euler-canvas" width="200" height="200" style="background-color: var(--global-bg-color-secondary); width: 100%; display: block; border-radius: 8px;"></canvas> </div> <div style="background-color: var(--global-bg-color-secondary); border-radius: 12px; padding: 15px; border: 1px solid var(--global-border-color);"> <h5 style="margin: 0 0 10px 0; color: #22c55e; font-size: 0.9em; text-align: center;">Symplectic Euler</h5> <canvas id="realtime-symplectic-canvas" width="200" height="200" style="background-color: var(--global-bg-color-secondary); width: 100%; display: block; border-radius: 8px;"></canvas> </div> <div style="background-color: var(--global-bg-color-secondary); border-radius: 12px; padding: 15px; border: 1px solid var(--global-border-color);"> <h5 style="margin: 0 0 10px 0; color: #3b82f6; font-size: 0.9em; text-align: center;">Velocity Verlet</h5> <canvas id="realtime-verlet-canvas" width="200" height="200" style="background-color: var(--global-bg-color-secondary); width: 100%; display: block; border-radius: 8px;"></canvas> </div> <div style="background-color: var(--global-bg-color-secondary); border-radius: 12px; padding: 15px; border: 1px solid var(--global-border-color);"> <h5 style="margin: 0 0 10px 0; color: #a855f7; font-size: 0.9em; text-align: center;">RK4</h5> <canvas id="realtime-rk4-canvas" width="200" height="200" style="background-color: var(--global-bg-color-secondary); width: 100%; display: block; border-radius: 8px;"></canvas> </div> </div> <div style="background-color: var(--global-bg-color-secondary); border-radius: 12px; padding: 20px; border: 1px solid var(--global-border-color); margin-bottom: 20px;"> <h5 style="margin: 0 0 15px 0; color: var(--global-heading-color); font-size: 1.1em;">Energy Evolution Comparison</h5> <canvas id="realtime-energy-chart" width="600" height="300" style="background-color: var(--global-bg-color-secondary); width: 100%; display: block; border-radius: 8px;"></canvas> </div> <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;"> <div> <h5 style="color: var(--global-heading-color); margin-bottom: 10px;">Simulation Parameters</h5> <div style="margin-bottom: 10px;"> <label style="color: var(--global-text-color);">Initial Angle: <span id="realtime-angle">45</span>°</label> <input type="range" id="realtime-angle-slider" min="10" max="170" value="45" style="width: 100%; accent-color: var(--global-theme-color);"/> </div> <div style="margin-bottom: 10px;"> <label style="color: var(--global-text-color);">Time Step: <span id="realtime-timestep">10</span> ms</label> <input type="range" id="realtime-timestep-slider" min="1" max="50" value="10" style="width: 100%; accent-color: var(--global-theme-color);"/> </div> </div> <div> <h5 style="color: var(--global-heading-color); margin-bottom: 10px;">Current Energy Errors</h5> <div style="font-size: 12px; line-height: 1.4;"> <div style="color: var(--global-text-color);">Time: <span id="realtime-time">0.00</span>s</div> <div style="color: #ef4444;">Explicit Euler: <span id="realtime-euler-error">0.00</span>%</div> <div style="color: #22c55e;">Symplectic Euler: <span id="realtime-symplectic-error">0.00</span>%</div> <div style="color: #3b82f6;">Velocity Verlet: <span id="realtime-verlet-error">0.00</span>%</div> <div style="color: #a855f7;">RK4: <span id="realtime-rk4-error">0.00</span>%</div> </div> </div> </div> <div style="text-align: center;"> <button id="realtime-play-pause" style="background: var(--global-gradient-primary); border: none; color: white; padding: 10px 20px; border-radius: 8px; margin-right: 10px; font-weight: 600; cursor: pointer; transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);">Pause</button> <button id="realtime-reset" style="background: #FF6B6B; border: none; color: white; padding: 10px 20px; border-radius: 8px; margin-right: 10px; font-weight: 600; cursor: pointer; transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);">Reset All</button> <button id="realtime-sync" style="background: #10B981; border: none; color: white; padding: 10px 20px; border-radius: 8px; font-weight: 600; cursor: pointer; transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);">Sync Methods</button> </div> <div style="margin-top: 15px; padding: 15px; background-color: rgba(59, 130, 246, 0.1); border-radius: 8px; font-size: 13px; color: var(--global-text-color);"> <strong>💡 Watch carefully:</strong> Notice how Explicit Euler (red) spirals outward while Symplectic methods (green/blue) maintain bounded motion. RK4 (purple) shows subtle drift over longer periods. </div> </div> </div> <h2 id="comparative-analysis-and-stability-theory">Comparative Analysis and Stability Theory</h2> <h3 id="computational-complexity-analysis">Computational Complexity Analysis</h3> <table> <thead> <tr> <th>Method</th> <th>Order</th> <th>Function Evaluations</th> <th>Memory</th> <th>Symplectic</th> <th>Energy Behavior</th> </tr> </thead> <tbody> <tr> <td>Explicit Euler</td> <td>\(O(h)\)</td> <td>1</td> <td>Minimal</td> <td>❌</td> <td>Exponential growth</td> </tr> <tr> <td>Symplectic Euler</td> <td>\(O(h)\)</td> <td>1</td> <td>Minimal</td> <td>✅</td> <td>Bounded oscillations</td> </tr> <tr> <td>Velocity Verlet</td> <td>\(O(h^2)\)</td> <td>2</td> <td>Low</td> <td>✅</td> <td>Excellent conservation</td> </tr> <tr> <td>RK4</td> <td>\(O(h^4)\)</td> <td>4</td> <td>Low</td> <td>❌</td> <td>Subtle long-term drift</td> </tr> </tbody> </table> <h3 id="the-fundamental-trade-off-accuracy-vs-structure">The Fundamental Trade-off: Accuracy vs. Structure</h3> <p>For conservative Hamiltonian systems, we face a fundamental choice:</p> <p><strong>Local Accuracy Priority</strong> (RK4, higher-order methods):</p> <ul> <li>Superior accuracy for individual timesteps</li> <li>Excellent for short-term, high-precision calculations</li> <li>May exhibit energy drift over extended simulations</li> <li>Ideal for dissipative systems where energy conservation is not required</li> </ul> <p><strong>Geometric Structure Priority</strong> (Symplectic methods):</p> <ul> <li>Preserve essential physical invariants</li> <li>Maintain bounded energy errors indefinitely</li> <li>Provide qualitatively correct long-term behavior</li> <li>Essential for conservative system simulation</li> </ul> <h3 id="stability-analysis-through-linear-theory">Stability Analysis Through Linear Theory</h3> <p>For the linearized pendulum (\(\sin\theta \approx \theta\)), the equation becomes:</p> \[\frac{d^2\theta}{dt^2} + \omega_0^2\theta = 0\] <p>where \(\omega_0 = \sqrt{g/L}\) is the natural frequency.</p> <p><strong>Explicit Euler Stability:</strong> The amplification matrix eigenvalues are: \(\lambda_{\pm} = 1 \pm i h \omega_0\)</p> <p>Their magnitudes are: \(|\lambda_{\pm}| = \sqrt{1 + (h\omega_0)^2} &gt; 1 \quad \text{for any } h&gt;0\)</p> <table> <tbody> <tr> <td>This explains the exponential energy growth. For $$</td> <td>\lambda</td> <td>&gt; 1$$, the solution grows exponentially.</td> </tr> </tbody> </table> <p><strong>Symplectic Euler Stability:</strong> The eigenvalues lie exactly on the unit circle: \(|\lambda| = 1\) for all \(h\). This guarantees bounded solutions for arbitrary timestep sizes.</p> <h2 id="interactive-comparison-complete-behavioral-analysis">Interactive Comparison: Complete Behavioral Analysis</h2> <div id="comparison-demo" style="max-width: 100%; margin: 20px 0;"> <div style="background-color: var(--global-card-bg-color); border-radius: 12px; padding: 20px; color: var(--global-text-color); border: 1px solid var(--global-border-color); box-shadow: var(--global-box-shadow-lg);"> <h4 style="margin: 0 0 20px 0; color: var(--global-theme-color);">Complete Comparison - All Integration Methods</h4> <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;"> <div> <h5 style="color: var(--global-heading-color);">Selected Pendulum Animation</h5> <canvas id="comparison-canvas" width="300" height="300" style="background-color: var(--global-bg-color-secondary); border-radius: 8px; width: 100%; border: 1px solid var(--global-border-color);"></canvas> <div style="margin-top: 10px;"> <label style="color: var(--global-text-color);">Display Method: </label> <select id="comparison-select" style="background-color: var(--global-card-bg-color); color: var(--global-text-color); border: 1px solid var(--global-border-color); padding: 5px; border-radius: 4px;"> <option value="symplectic">Symplectic Euler</option> <option value="euler">Explicit Euler</option> <option value="verlet">Velocity Verlet</option> <option value="rk4">RK4</option> </select> </div> </div> <div> <h5 style="color: var(--global-heading-color);">Energy Drift Comparison</h5> <canvas id="comparison-energy" width="300" height="300" style="background-color: var(--global-bg-color-secondary); border-radius: 8px; width: 100%; border: 1px solid var(--global-border-color);"></canvas> <div style="margin-top: 10px; display: flex; flex-wrap: wrap; gap: 10px; font-size: 11px;"> <div style="display: flex; align-items: center; gap: 4px;"> <div style="width: 12px; height: 12px; background: #ef4444; border-radius: 50%;"></div> <span style="color: var(--global-text-color);">Explicit Euler</span> </div> <div style="display: flex; align-items: center; gap: 4px;"> <div style="width: 12px; height: 12px; background: #22c55e; border-radius: 50%;"></div> <span style="color: var(--global-text-color);">Symplectic Euler</span> </div> <div style="display: flex; align-items: center; gap: 4px;"> <div style="width: 12px; height: 12px; background: #3b82f6; border-radius: 50%;"></div> <span style="color: var(--global-text-color);">Velocity Verlet</span> </div> <div style="display: flex; align-items: center; gap: 4px;"> <div style="width: 12px; height: 12px; background: #a855f7; border-radius: 50%;"></div> <span style="color: var(--global-text-color);">RK4</span> </div> </div> </div> </div> <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;"> <div> <h5 style="color: var(--global-heading-color);">Initial Conditions</h5> <div style="margin-bottom: 10px;"> <label style="color: var(--global-text-color);">Initial Angle: <span id="comparison-angle">45</span>°</label> <input type="range" id="comparison-angle-slider" min="10" max="170" value="45" style="width: 100%; accent-color: var(--global-theme-color);"/> </div> <div> <label style="color: var(--global-text-color);">Time Step: <span id="comparison-timestep">10</span> ms</label> <input type="range" id="comparison-timestep-slider" min="1" max="50" value="10" style="width: 100%; accent-color: var(--global-theme-color);"/> </div> </div> <div> <h5 style="color: var(--global-heading-color);">Current Energy Errors</h5> <div style="font-size: 12px;"> <div style="color: var(--global-text-color);">Time: <span id="comparison-time">0.00</span>s</div> <div style="color: #ef4444;">Explicit Euler: <span id="comparison-euler-error">0.00</span>%</div> <div style="color: #22c55e;">Symplectic Euler: <span id="comparison-symplectic-error">0.00</span>%</div> <div style="color: #3b82f6;">Velocity Verlet: <span id="comparison-verlet-error">0.00</span>%</div> <div style="color: #a855f7;">RK4: <span id="comparison-rk4-error">0.00</span>%</div> </div> </div> </div> <div style="text-align: center;"> <button id="comparison-play-pause" style="background: var(--global-gradient-primary); border: none; color: white; padding: 10px 20px; border-radius: 6px; margin-right: 10px; font-weight: 600; cursor: pointer; transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);">Pause</button> <button id="comparison-reset" style="background: #FF6B6B; border: none; color: white; padding: 10px 20px; border-radius: 6px; font-weight: 600; cursor: pointer; transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);">Reset All</button> </div> </div> </div> <h2 id="real-world-applications-and-case-studies">Real-World Applications and Case Studies</h2> <h3 id="case-study-1-climate-modeling---the-ecmwf-experience">Case Study 1: Climate Modeling - The ECMWF Experience</h3> <p>The European Centre for Medium-Range Weather Forecasts (ECMWF) faced a critical challenge: their atmospheric models were exhibiting systematic energy drift over long-term climate runs.</p> <p><strong>The Problem:</strong></p> <ul> <li><strong>Simulation duration</strong>: 100+ year climate projections</li> <li><strong>Energy drift</strong>: 0.1% per decade using standard methods</li> <li><strong>Consequence</strong>: Artificial warming trends corrupting climate predictions</li> </ul> <p><strong>The Solution:</strong> Implementation of energy-conserving finite difference schemes based on symplectic principles:</p> <div class="language-fortran highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">! Symplectic time stepping for atmospheric dynamics</span><span class="w">
</span><span class="k">do</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">nlevels</span><span class="w">
    </span><span class="c1">! Update momentum first (symplectic)</span><span class="w">
    </span><span class="n">u_new</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">u_old</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">dt</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">forcing_u</span><span class="p">(</span><span class="n">u_old</span><span class="p">,</span><span class="w"> </span><span class="n">v_old</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w">
    </span><span class="n">v_new</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v_old</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">dt</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">forcing_v</span><span class="p">(</span><span class="n">u_old</span><span class="p">,</span><span class="w"> </span><span class="n">v_old</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w">
    
    </span><span class="c1">! Update positions using new momentum</span><span class="w">
    </span><span class="n">x</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">dt</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">u_new</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="w">
    </span><span class="n">y</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">y</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">dt</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">v_new</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="w">
</span><span class="k">end</span><span class="w"> </span><span class="k">do</span><span class="w">
</span></code></pre></div></div> <p><strong>Results:</strong></p> <ul> <li>Energy drift reduced to &lt; 0.01% per century</li> <li>Improved long-term climate stability</li> <li>More reliable temperature trend predictions</li> </ul> <h3 id="case-study-2-molecular-dynamics---the-gromacs-success-story">Case Study 2: Molecular Dynamics - The GROMACS Success Story</h3> <p>GROMACS, one of the most widely used molecular dynamics packages, owes its success largely to the adoption of Velocity Verlet integration.</p> <p><strong>System Characteristics:</strong></p> <ul> <li><strong>Particle count</strong>: 10⁶ - 10⁹ atoms</li> <li><strong>Simulation time</strong>: nanoseconds to microseconds</li> <li><strong>Timestep</strong>: 1-2 femtoseconds</li> <li><strong>Total steps</strong>: 10⁹ - 10¹² integration steps</li> </ul> <p><strong>Why Symplectic Methods Are Essential:</strong></p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Velocity Verlet implementation in GROMACS</span>
<span class="kt">void</span> <span class="nf">update_positions_and_velocities</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">real</span> <span class="n">dt</span><span class="p">,</span>
                                   <span class="n">rvec</span> <span class="n">x</span><span class="p">[],</span> <span class="n">rvec</span> <span class="n">v</span><span class="p">[],</span> <span class="n">rvec</span> <span class="n">f</span><span class="p">[],</span> <span class="n">real</span> <span class="n">mass</span><span class="p">[])</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Half-step velocity update</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">d</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">d</span> <span class="o">&lt;</span> <span class="n">DIM</span><span class="p">;</span> <span class="n">d</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">d</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="n">dt</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">d</span><span class="p">]</span> <span class="o">/</span> <span class="n">mass</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="p">}</span>
        
        <span class="c1">// Full-step position update</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">d</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">d</span> <span class="o">&lt;</span> <span class="n">DIM</span><span class="p">;</span> <span class="n">d</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">d</span><span class="p">]</span> <span class="o">+=</span> <span class="n">dt</span> <span class="o">*</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">d</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="c1">// Compute new forces at updated positions</span>
    <span class="n">compute_forces</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>
    
    <span class="c1">// Complete velocity update</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">d</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">d</span> <span class="o">&lt;</span> <span class="n">DIM</span><span class="p">;</span> <span class="n">d</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">d</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="n">dt</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">d</span><span class="p">]</span> <span class="o">/</span> <span class="n">mass</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p><strong>Critical Performance Metrics:</strong></p> <ul> <li><strong>Energy conservation</strong>: &lt; 0.01% drift over microsecond simulations</li> <li><strong>Temperature stability</strong>: Canonical ensemble maintained without thermostats</li> <li><strong>Computational efficiency</strong>: Optimal balance of accuracy and speed</li> </ul> <h3 id="case-study-3-spacecraft-navigation---the-new-horizons-mission">Case Study 3: Spacecraft Navigation - The New Horizons Mission</h3> <p>NASA’s New Horizons mission to Pluto required extraordinary precision in trajectory calculation over a 9-year journey.</p> <p><strong>Navigation Challenges:</strong></p> <ul> <li><strong>Journey duration</strong>: 9 years (2.8 × 10⁸ seconds)</li> <li><strong>Precision requirement</strong>: &lt; 3000 km accuracy at Pluto encounter</li> <li><strong>Perturbations</strong>: Gravitational effects from multiple bodies, solar radiation pressure</li> </ul> <p><strong>Integration Strategy:</strong> NASA used a combination of symplectic methods for long-term stability with adaptive high-order methods for critical maneuvers:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">spacecraft_propagator</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">adaptive</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">adaptive</span> <span class="ow">or</span> <span class="n">critical_maneuver</span><span class="p">:</span>
        <span class="c1"># High-precision RK4 with adaptive timestep
</span>        <span class="k">return</span> <span class="nf">rk4_adaptive</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mf">1e-12</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Symplectic integration for cruise phase
</span>        <span class="k">return</span> <span class="nf">symplectic_euler</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>
</code></pre></div></div> <p><strong>Results:</strong></p> <ul> <li>Pluto encounter within 3000 km of predicted position</li> <li>Total trajectory error &lt; 0.01% after 9-year journey</li> <li>Successful flyby of Arrokoth (2014 MU69) in 2019</li> </ul> <h2 id="advanced-topics-in-numerical-integration">Advanced Topics in Numerical Integration</h2> <h3 id="higher-order-symplectic-methods">Higher-Order Symplectic Methods</h3> <p>While Symplectic Euler and Velocity Verlet are first and second-order accurate respectively, higher-order symplectic methods can be constructed using <strong>composition methods</strong>.</p> <p><strong>Forest-Ruth Algorithm (4th Order Symplectic):</strong> \(\mathbf{S}_4 = \mathbf{S}_h^{\theta_1} \circ \mathbf{S}_h^{\theta_2} \circ \mathbf{S}_h^{\theta_3} \circ \mathbf{S}_h^{\theta_2} \circ \mathbf{S}_h^{\theta_1}\)</p> <p>where \(\mathbf{S}_h\) is the basic symplectic map and:</p> <ul> <li> \[\theta_1 = \theta_3 = \frac{1}{2 - 2^{1/3}}\] </li> <li> \[\theta_2 = -\frac{2^{1/3}}{2 - 2^{1/3}}\] </li> </ul> <p><strong>Trade-offs:</strong></p> <ul> <li><strong>Pros</strong>: Fourth-order accuracy with exact energy conservation</li> <li><strong>Cons</strong>: 5× computational cost per timestep vs. Velocity Verlet</li> </ul> <h3 id="adaptive-time-stepping-strategies">Adaptive Time Stepping Strategies</h3> <p>For systems with multiple timescales, adaptive time stepping can dramatically improve efficiency:</p> <p><strong>Richardson Extrapolation:</strong></p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">adaptive_symplectic_step</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">h_initial</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">):</span>
    <span class="c1"># Take one step of size h
</span>    <span class="n">state_h</span> <span class="o">=</span> <span class="nf">symplectic_step</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">h_initial</span><span class="p">)</span>
    
    <span class="c1"># Take two steps of size h/2
</span>    <span class="n">state_temp</span> <span class="o">=</span> <span class="nf">symplectic_step</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">h_initial</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">state_h2</span> <span class="o">=</span> <span class="nf">symplectic_step</span><span class="p">(</span><span class="n">state_temp</span><span class="p">,</span> <span class="n">h_initial</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
    
    <span class="c1"># Estimate error
</span>    <span class="n">error</span> <span class="o">=</span> <span class="nf">norm</span><span class="p">(</span><span class="n">state_h</span> <span class="o">-</span> <span class="n">state_h2</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">error</span> <span class="o">&lt;</span> <span class="n">tolerance</span><span class="p">:</span>
        <span class="c1"># Accept step with Richardson extrapolation
</span>        <span class="nf">return </span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">state_h2</span> <span class="o">-</span> <span class="n">state_h</span><span class="p">)</span> <span class="o">/</span> <span class="mi">3</span><span class="p">,</span> <span class="n">h_initial</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Reduce timestep and retry
</span>        <span class="k">return</span> <span class="nf">adaptive_symplectic_step</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">h_initial</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>
</code></pre></div></div> <h3 id="multiple-time-scale-methods">Multiple Time Scale Methods</h3> <p>Systems like planetary motion (fast orbital motion + slow precession) benefit from multiple timestep methods:</p> <p><strong>Impulse-Velocity-Impulse (IVI) Decomposition:</strong></p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">multiple_timestep_integrator</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">dt_fast</span><span class="p">,</span> <span class="n">dt_slow</span><span class="p">,</span> <span class="n">n_substeps</span><span class="p">):</span>
    <span class="c1"># Slow force impulse (half step)
</span>    <span class="n">state</span> <span class="o">=</span> <span class="nf">apply_slow_forces</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">dt_slow</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
    
    <span class="c1"># Fast evolution with multiple substeps
</span>    <span class="n">dt_sub</span> <span class="o">=</span> <span class="n">dt_slow</span> <span class="o">/</span> <span class="n">n_substeps</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n_substeps</span><span class="p">):</span>
        <span class="n">state</span> <span class="o">=</span> <span class="nf">symplectic_step_fast_forces</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">dt_sub</span><span class="p">)</span>
    
    <span class="c1"># Slow force impulse (half step)
</span>    <span class="n">state</span> <span class="o">=</span> <span class="nf">apply_slow_forces</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">dt_slow</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">state</span>
</code></pre></div></div> <h2 id="implementation-best-practices">Implementation Best Practices</h2> <h3 id="1-timestep-selection-guidelines">1. Timestep Selection Guidelines</h3> <p><strong>Conservative Systems (Hamiltonian):</strong></p> <ul> <li><strong>Symplectic methods</strong>: \(h \leq \frac{T}{20}\) where \(T\) is the shortest characteristic period</li> <li><strong>RK4</strong>: \(h \leq \frac{T}{100}\) for comparable accuracy to symplectic methods</li> </ul> <p><strong>Dissipative Systems:</strong></p> <ul> <li><strong>RK4 preferred</strong>: Higher local accuracy compensates for energy dissipation</li> <li><strong>Adaptive methods</strong>: Essential for stiff systems with multiple timescales</li> </ul> <h3 id="2-energy-conservation-monitoring">2. Energy Conservation Monitoring</h3> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">EnergyMonitor</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">initial_energy</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">E0</span> <span class="o">=</span> <span class="n">initial_energy</span>
        <span class="n">self</span><span class="p">.</span><span class="n">tolerance</span> <span class="o">=</span> <span class="n">tolerance</span>
        <span class="n">self</span><span class="p">.</span><span class="n">max_error</span> <span class="o">=</span> <span class="mi">0</span>
        
    <span class="k">def</span> <span class="nf">check_energy</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">current_energy</span><span class="p">,</span> <span class="n">time</span><span class="p">):</span>
        <span class="n">relative_error</span> <span class="o">=</span> <span class="nf">abs</span><span class="p">(</span><span class="n">current_energy</span> <span class="o">-</span> <span class="n">self</span><span class="p">.</span><span class="n">E0</span><span class="p">)</span> <span class="o">/</span> <span class="nf">abs</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">E0</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">max_error</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">max_error</span><span class="p">,</span> <span class="n">relative_error</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">relative_error</span> <span class="o">&gt;</span> <span class="n">self</span><span class="p">.</span><span class="n">tolerance</span><span class="p">:</span>
            <span class="n">warnings</span><span class="p">.</span><span class="nf">warn</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Energy error </span><span class="si">{</span><span class="n">relative_error</span><span class="si">:</span><span class="p">.</span><span class="mi">2</span><span class="n">e</span><span class="si">}</span><span class="s"> exceeds tolerance at t=</span><span class="si">{</span><span class="n">time</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
            
        <span class="k">return</span> <span class="n">relative_error</span>
</code></pre></div></div> <h3 id="3-numerical-precision-considerations">3. Numerical Precision Considerations</h3> <p><strong>Double vs. Extended Precision:</strong></p> <ul> <li>Standard double precision (64-bit): ~15 decimal digits</li> <li>For long-term simulations: Consider extended precision (80-bit) or arbitrary precision arithmetic</li> <li>GPU implementations: Be aware of reduced precision in single-precision calculations</li> </ul> <h3 id="4-symplectic-integrator-verification">4. Symplectic Integrator Verification</h3> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">verify_symplectic_property</span><span class="p">(</span><span class="n">integrator</span><span class="p">,</span> <span class="n">state0</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">n_steps</span><span class="o">=</span><span class="mi">1000</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s">Verify that phase space volume is conserved</span><span class="sh">"""</span>
    <span class="c1"># Create small perturbation in phase space
</span>    <span class="n">epsilon</span> <span class="o">=</span> <span class="mf">1e-8</span>
    <span class="n">states</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">state0</span><span class="p">,</span>
        <span class="n">state0</span> <span class="o">+</span> <span class="p">[</span><span class="n">epsilon</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
        <span class="n">state0</span> <span class="o">+</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">epsilon</span><span class="p">],</span>
        <span class="n">state0</span> <span class="o">+</span> <span class="p">[</span><span class="n">epsilon</span><span class="p">,</span> <span class="n">epsilon</span><span class="p">]</span>
    <span class="p">]</span>
    
    <span class="c1"># Evolve all perturbed states
</span>    <span class="n">final_states</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="n">states</span><span class="p">:</span>
        <span class="n">current</span> <span class="o">=</span> <span class="n">state</span><span class="p">.</span><span class="nf">copy</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n_steps</span><span class="p">):</span>
            <span class="n">current</span> <span class="o">=</span> <span class="nf">integrator</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>
        <span class="n">final_states</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">current</span><span class="p">)</span>
    
    <span class="c1"># Compute initial and final phase space volumes
</span>    <span class="n">initial_volume</span> <span class="o">=</span> <span class="nf">compute_phase_space_volume</span><span class="p">(</span><span class="n">states</span><span class="p">)</span>
    <span class="n">final_volume</span> <span class="o">=</span> <span class="nf">compute_phase_space_volume</span><span class="p">(</span><span class="n">final_states</span><span class="p">)</span>
    
    <span class="n">volume_change</span> <span class="o">=</span> <span class="nf">abs</span><span class="p">(</span><span class="n">final_volume</span> <span class="o">-</span> <span class="n">initial_volume</span><span class="p">)</span> <span class="o">/</span> <span class="n">initial_volume</span>
    
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Phase space volume change: </span><span class="si">{</span><span class="n">volume_change</span><span class="si">:</span><span class="p">.</span><span class="mi">2</span><span class="n">e</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">volume_change</span> <span class="o">&lt;</span> <span class="mf">1e-10</span>  <span class="c1"># Should be essentially zero for symplectic methods
</span></code></pre></div></div> <h2 id="troubleshooting-common-issues">Troubleshooting Common Issues</h2> <h3 id="problem-energy-growth-in-symplectic-methods">Problem: Energy Growth in Symplectic Methods</h3> <p><strong>Symptoms:</strong> Energy increases systematically despite using symplectic integrator</p> <p><strong>Potential Causes:</strong></p> <ol> <li><strong>Implementation error</strong>: Check that momentum is updated before position</li> <li><strong>Floating-point precision</strong>: Accumulation of round-off errors over millions of steps</li> <li><strong>Timestep too large</strong>: Linear stability analysis assumes small timesteps</li> </ol> <p><strong>Solutions:</strong></p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Correct symplectic Euler implementation
</span><span class="k">def</span> <span class="nf">symplectic_euler_correct</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">omega</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">L</span><span class="p">):</span>
    <span class="c1"># CORRECT: Update omega first
</span>    <span class="n">omega_new</span> <span class="o">=</span> <span class="n">omega</span> <span class="o">-</span> <span class="p">(</span><span class="n">dt</span> <span class="o">*</span> <span class="n">g</span> <span class="o">/</span> <span class="n">L</span><span class="p">)</span> <span class="o">*</span> <span class="nf">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
    <span class="n">theta_new</span> <span class="o">=</span> <span class="n">theta</span> <span class="o">+</span> <span class="n">dt</span> <span class="o">*</span> <span class="n">omega_new</span>  <span class="c1"># Use NEW omega
</span>    <span class="k">return</span> <span class="n">theta_new</span><span class="p">,</span> <span class="n">omega_new</span>

<span class="c1"># INCORRECT implementation (produces energy growth)
</span><span class="k">def</span> <span class="nf">symplectic_euler_wrong</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">omega</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">L</span><span class="p">):</span>
    <span class="c1"># WRONG: Updates done simultaneously
</span>    <span class="n">omega_new</span> <span class="o">=</span> <span class="n">omega</span> <span class="o">-</span> <span class="p">(</span><span class="n">dt</span> <span class="o">*</span> <span class="n">g</span> <span class="o">/</span> <span class="n">L</span><span class="p">)</span> <span class="o">*</span> <span class="nf">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
    <span class="n">theta_new</span> <span class="o">=</span> <span class="n">theta</span> <span class="o">+</span> <span class="n">dt</span> <span class="o">*</span> <span class="n">omega</span>  <span class="c1"># Uses OLD omega
</span>    <span class="k">return</span> <span class="n">theta_new</span><span class="p">,</span> <span class="n">omega_new</span>
</code></pre></div></div> <h3 id="problem-stiff-system-instability">Problem: Stiff System Instability</h3> <p><strong>Symptoms:</strong> Simulation becomes unstable for small timesteps</p> <p><strong>Cause:</strong> Stiff differential equations require implicit methods</p> <p><strong>Solution:</strong> Use implicit-explicit (IMEX) methods:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">imex_euler</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">force_explicit</span><span class="p">,</span> <span class="n">force_implicit</span><span class="p">):</span>
    <span class="c1"># Explicit update for non-stiff terms
</span>    <span class="n">p_temp</span> <span class="o">=</span> <span class="n">p</span> <span class="o">+</span> <span class="n">dt</span> <span class="o">*</span> <span class="nf">force_explicit</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
    
    <span class="c1"># Implicit update for stiff terms (requires solver)
</span>    <span class="n">p_new</span> <span class="o">=</span> <span class="nf">solve_implicit</span><span class="p">(</span><span class="n">p_temp</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">force_implicit</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
    <span class="n">q_new</span> <span class="o">=</span> <span class="n">q</span> <span class="o">+</span> <span class="n">dt</span> <span class="o">*</span> <span class="n">p_new</span>
    
    <span class="k">return</span> <span class="n">q_new</span><span class="p">,</span> <span class="n">p_new</span>
</code></pre></div></div> <h3 id="problem-resonance-induced-instability">Problem: Resonance-Induced Instability</h3> <p><strong>Symptoms:</strong> Energy oscillates with growing amplitude over time</p> <p><strong>Cause:</strong> Timestep resonates with system’s natural frequency</p> <p><strong>Solution:</strong> Use irrational timestep ratios or variable timestep methods:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Golden ratio timestep to avoid resonances
</span><span class="n">dt_base</span> <span class="o">=</span> <span class="mf">0.01</span>
<span class="n">golden_ratio</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="nf">sqrt</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span> <span class="o">/</span> <span class="mi">2</span>
<span class="n">dt_adaptive</span> <span class="o">=</span> <span class="n">dt_base</span> <span class="o">/</span> <span class="n">golden_ratio</span>
</code></pre></div></div> <h2 id="future-directions-and-research-frontiers">Future Directions and Research Frontiers</h2> <h3 id="machine-learning-enhanced-integration">Machine Learning Enhanced Integration</h3> <p>Recent developments combine traditional numerical methods with machine learning:</p> <p><strong>Physics-Informed Neural Networks (PINNs):</strong></p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">torch</span>
<span class="kn">import</span> <span class="n">torch.nn</span> <span class="k">as</span> <span class="n">nn</span>

<span class="k">class</span> <span class="nc">HamiltonianNet</span><span class="p">(</span><span class="n">nn</span><span class="p">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="nf">super</span><span class="p">().</span><span class="nf">__init__</span><span class="p">()</span>
        <span class="n">self</span><span class="p">.</span><span class="n">net</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="nc">Sequential</span><span class="p">(</span>
            <span class="n">nn</span><span class="p">.</span><span class="nc">Linear</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">50</span><span class="p">),</span> <span class="n">nn</span><span class="p">.</span><span class="nc">Tanh</span><span class="p">(),</span>
            <span class="n">nn</span><span class="p">.</span><span class="nc">Linear</span><span class="p">(</span><span class="mi">50</span><span class="p">,</span> <span class="mi">50</span><span class="p">),</span> <span class="n">nn</span><span class="p">.</span><span class="nc">Tanh</span><span class="p">(),</span>
            <span class="n">nn</span><span class="p">.</span><span class="nc">Linear</span><span class="p">(</span><span class="mi">50</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="nf">net</span><span class="p">(</span><span class="n">torch</span><span class="p">.</span><span class="nf">cat</span><span class="p">([</span><span class="n">q</span><span class="p">,</span> <span class="n">p</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
    
    <span class="k">def</span> <span class="nf">symplectic_gradient</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">forward</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
        <span class="n">dH_dq</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="n">autograd</span><span class="p">.</span><span class="nf">grad</span><span class="p">(</span><span class="n">H</span><span class="p">.</span><span class="nf">sum</span><span class="p">(),</span> <span class="n">q</span><span class="p">,</span> <span class="n">create_graph</span><span class="o">=</span><span class="bp">True</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">dH_dp</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="n">autograd</span><span class="p">.</span><span class="nf">grad</span><span class="p">(</span><span class="n">H</span><span class="p">.</span><span class="nf">sum</span><span class="p">(),</span> <span class="n">p</span><span class="p">,</span> <span class="n">create_graph</span><span class="o">=</span><span class="bp">True</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">dH_dq</span><span class="p">,</span> <span class="n">dH_dp</span>  <span class="c1"># Hamilton's equations
</span></code></pre></div></div> <h3 id="quantum-classical-hybrid-systems">Quantum-Classical Hybrid Systems</h3> <p>Emerging applications require integration of quantum and classical dynamics:</p> <p><strong>Mean Field Theory Integration:</strong> For systems where quantum effects influence classical motion through expectation values.</p> <h3 id="geometric-deep-learning">Geometric Deep Learning</h3> <p>Using the geometric structure of phase space in neural network architectures:</p> <p><strong>Symplectic Neural Networks:</strong> Networks constrained to preserve symplectic structure exactly while learning complex dynamics.</p> <h2 id="conclusion-the-art-and-science-of-numerical-integration">Conclusion: The Art and Science of Numerical Integration</h2> <p>The exploration of energy drift in the simple pendulum reveals fundamental principles that extend far beyond this seemingly elementary system. We have witnessed how the choice of integration method can mean the difference between simulation success and catastrophic failure—between climate models that accurately predict future temperatures and those that exhibit spurious warming trends.</p> <h3 id="key-insights-from-our-journey">Key Insights from Our Journey</h3> <ol> <li> <p><strong>Geometric Structure Trumps Local Accuracy</strong>: Symplectic methods with first-order accuracy often outperform fourth-order methods that ignore geometric structure.</p> </li> <li> <p><strong>Conservation Laws Are Not Optional</strong>: For conservative systems, preserving invariants like energy, momentum, and phase space volume is essential for physical realism.</p> </li> <li> <p><strong>The Mathematics Has Real Consequences</strong>: The abstract concepts of symplectic geometry and Hamiltonian mechanics translate directly into practical simulation reliability.</p> </li> <li> <p><strong>Understanding Enables Optimization</strong>: Knowledge of stability theory, convergence analysis, and computational complexity allows informed selection of methods for specific applications.</p> </li> </ol> <h3 id="the-broader-impact">The Broader Impact</h3> <p>These principles extend throughout computational science:</p> <ul> <li><strong>Climate Science</strong>: Energy-conserving atmospheric models</li> <li><strong>Astronomy</strong>: Long-term planetary motion calculations</li> <li><strong>Materials Science</strong>: Molecular dynamics simulations</li> <li><strong>Engineering</strong>: Structural dynamics and vibration analysis</li> <li><strong>Biology</strong>: Protein folding and cellular dynamics</li> <li><strong>Finance</strong>: Long-term economic modeling</li> </ul> <h3 id="looking-forward">Looking Forward</h3> <p>As computational power continues to grow exponentially, the temptation exists to simply use smaller timesteps with traditional methods. However, this brute-force approach fails for systems requiring integration over geological timescales or astronomical distances. The future belongs to methods that respect the underlying mathematical structure of physical systems.</p> <p>The simple pendulum, in its elegant simplicity, embodies the rich mathematical structure that governs all of physics. By understanding how to preserve this structure numerically, we gain the power to simulate reality with unprecedented fidelity and extend our understanding of complex systems across all scales of nature.</p> <p><em>The mathematics of numerical integration isn’t merely computational technique—it’s the bridge between theoretical understanding and practical prediction, between the elegance of continuous mathematics and the reality of discrete computation.</em></p> <hr/> <h2 id="further-reading-and-references">Further Reading and References</h2> <h3 id="essential-textbooks">Essential Textbooks</h3> <ul> <li><strong>Hairer, E., Lubich, C., &amp; Wanner, G.</strong> (2006). <em>Geometric Numerical Integration: Structure-Preserving Algorithms for Ordinary Differential Equations</em>. Springer.</li> <li><strong>Leimkuhler, B., &amp; Reich, S.</strong> (2004). <em>Simulating Hamiltonian Dynamics</em>. Cambridge University Press.</li> </ul> <h3 id="research-papers">Research Papers</h3> <ul> <li><strong>Forest, E., &amp; Ruth, R. D.</strong> (1990). Fourth-order symplectic integration. <em>Physica D</em>, 43(1), 105-117.</li> <li><strong>Yoshida, H.</strong> (1990). Construction of higher order symplectic integrators. <em>Physics Letters A</em>, 150(5), 262-268.</li> </ul> <h3 id="computational-tools">Computational Tools</h3> <ul> <li><strong>GROMACS</strong>: <a href="http://www.gromacs.org">gromacs.org</a> - Molecular dynamics with Velocity Verlet</li> <li><strong>NAMD</strong>: <a href="https://www.ks.uiuc.edu/Research/namd/">namd.org</a> - Large-scale parallel MD simulations</li> <li><strong>yt-project</strong>: <a href="https://yt-project.org">yt-project.org</a> - Analysis tools for astrophysical simulations</li> </ul> <script>class SinglePendulumSim{constructor(t,e,s,i){this.canvas=document.getElementById(t),this.energyCanvas=document.getElementById(e),this.canvas&&this.energyCanvas?(this.ctx=this.canvas.getContext("2d"),this.energyCtx=this.energyCanvas.getContext("2d"),this.ctx&&this.energyCtx?(this.integrator=s,this.color=i,this.L=1,this.g=9.81,this.h=.01,this.theta=Math.PI/4,this.omega=0,this.time=0,this.running=!0,this.energyHistory=[],this.initialEnergy=this.energy(this.theta,this.omega),this.maxSamples=300,this.animate()):console.warn("Failed to get 2D context for canvases")):console.warn(`Canvas elements not found: ${t}, ${e}`)}togglePause(){return this.running=!this.running,this.running}acceleration(t){return-this.g/this.L*Math.sin(t)}energy(t,e){return this.g*this.L*(1-Math.cos(t))+this.L*this.L*.5*e*e}step(){if(this.running){switch(this.integrator){case"euler":const t=this.acceleration(this.theta);this.theta+=this.h*this.omega,this.omega+=this.h*t;break;case"symplectic":this.omega+=this.h*this.acceleration(this.theta),this.theta+=this.h*this.omega;break;case"verlet":const e=this.acceleration(this.theta),s=this.omega+.5*this.h*e;this.theta+=this.h*s;const i=this.acceleration(this.theta);this.omega=s+.5*this.h*i;break;case"rk4":const h=(t,e)=>[e,this.acceleration(t)],a=h(this.theta,this.omega),n=h(this.theta+.5*this.h*a[0],this.omega+.5*this.h*a[1]),r=h(this.theta+.5*this.h*n[0],this.omega+.5*this.h*n[1]),o=h(this.theta+this.h*r[0],this.omega+this.h*r[1]);this.theta+=this.h/6*(a[0]+2*n[0]+2*r[0]+o[0]),this.omega+=this.h/6*(a[1]+2*n[1]+2*r[1]+o[1])}if(this.time+=this.h,Math.floor(50*this.time)%2==0){const t=this.energy(this.theta,this.omega);this.energyHistory.push({t:this.time,E:t}),this.energyHistory.length>this.maxSamples&&this.energyHistory.shift()}}}draw(){const t=this.ctx,e=this.canvas,s=.35*Math.min(e.width,e.height),i=e.width/2,h=.2*e.height;t.clearRect(0,0,e.width,e.height);const a=i+s*Math.sin(this.theta),n=h+s*Math.cos(this.theta);t.strokeStyle=this.color,t.lineWidth=3,t.beginPath(),t.moveTo(i,h),t.lineTo(a,n),t.stroke(),t.fillStyle="#666",t.beginPath(),t.arc(i,h,5,0,2*Math.PI),t.fill(),t.fillStyle=this.color,t.beginPath(),t.arc(a,n,12,0,2*Math.PI),t.fill(),this.drawEnergyChart()}drawEnergyChart(){const t=this.energyCtx,e=this.energyCanvas;if(t.clearRect(0,0,e.width,e.height),this.energyHistory.length<2)return;const s=30,i=e.width-2*s,h=e.height-2*s;let a=this.energyHistory[0].t,n=this.energyHistory[this.energyHistory.length-1].t,r=Math.min(...this.energyHistory.map(t=>t.E)),o=Math.max(...this.energyHistory.map(t=>t.E));o===r&&(r-=.01,o+=.01);const l=Math.max(n-a,1),c=o-r;t.strokeStyle="#666",t.lineWidth=1,t.beginPath(),t.moveTo(s,e.height-s),t.lineTo(e.width-s,e.height-s),t.moveTo(s,s),t.lineTo(s,e.height-s),t.stroke(),t.strokeStyle=this.color,t.lineWidth=2,t.beginPath(),this.energyHistory.forEach((n,o)=>{const g=s+(n.t-a)/l*i,m=e.height-s-(n.E-r)/c*h;0===o?t.moveTo(g,m):t.lineTo(g,m)}),t.stroke();const g=e.height-s-(this.initialEnergy-r)/c*h;t.strokeStyle="#666",t.setLineDash([5,5]),t.beginPath(),t.moveTo(s,g),t.lineTo(e.width-s,g),t.stroke(),t.setLineDash([]),t.fillStyle="#aaa",t.font="10px Arial",t.textAlign="center",t.fillText("Time (s)",e.width/2,e.height-5),t.save(),t.translate(10,e.height/2),t.rotate(-Math.PI/2),t.fillText("Energy",0,0),t.restore()}reset(){this.theta=Math.PI/4,this.omega=0,this.time=0,this.energyHistory=[],this.initialEnergy=this.energy(this.theta,this.omega)}getEnergyError(){return(this.energy(this.theta,this.omega)-this.initialEnergy)/this.initialEnergy*100}animate(){try{this.ctx&&this.energyCtx&&(this.step(),this.draw())}catch(t){console.warn("Animation error:",t)}requestAnimationFrame(()=>this.animate())}}class ComparisonSim{constructor(){this.canvas=document.getElementById("comparison-canvas"),this.energyCanvas=document.getElementById("comparison-energy"),this.canvas&&this.energyCanvas?(this.ctx=this.canvas.getContext("2d"),this.energyCtx=this.energyCanvas.getContext("2d"),this.ctx&&this.energyCtx?(this.L=1,this.g=9.81,this.h=.01,this.theta0=Math.PI/4,this.selectedIntegrator="symplectic",this.running=!0,this.states={euler:{theta:this.theta0,omega:0},symplectic:{theta:this.theta0,omega:0},verlet:{theta:this.theta0,omega:0},rk4:{theta:this.theta0,omega:0}},this.energyHistory={euler:[],symplectic:[],verlet:[],rk4:[]},this.colors={euler:"#ef4444",symplectic:"#22c55e",verlet:"#3b82f6",rk4:"#a855f7"},this.time=0,this.initialEnergy=this.energy(this.theta0,0),this.maxSamples=400,this.setupControls(),this.animate()):console.warn("Failed to get 2D context for comparison canvases")):console.warn("Comparison canvas elements not found")}setupControls(){document.getElementById("comparison-play-pause").addEventListener("click",()=>{this.running=!this.running,document.getElementById("comparison-play-pause").textContent=this.running?"Pause":"Play"}),document.getElementById("comparison-reset").addEventListener("click",()=>{this.reset()}),document.getElementById("comparison-select").addEventListener("change",t=>{this.selectedIntegrator=t.target.value}),document.getElementById("comparison-angle-slider").addEventListener("input",t=>{this.theta0=parseFloat(t.target.value)*Math.PI/180,document.getElementById("comparison-angle").textContent=t.target.value,this.reset()}),document.getElementById("comparison-timestep-slider").addEventListener("input",t=>{this.h=parseFloat(t.target.value)/1e3,document.getElementById("comparison-timestep").textContent=t.target.value})}acceleration(t){return-this.g/this.L*Math.sin(t)}energy(t,e){return this.g*this.L*(1-Math.cos(t))+this.L*this.L*.5*e*e}step(){if(!this.running)return;const t=this.states.euler,e=this.acceleration(t.theta);this.states.euler={theta:t.theta+this.h*t.omega,omega:t.omega+this.h*e};const s=this.states.symplectic,i=s.omega+this.h*this.acceleration(s.theta);this.states.symplectic={theta:s.theta+this.h*i,omega:i};const h=this.states.verlet,a=this.acceleration(h.theta),n=h.omega+.5*this.h*a,r=h.theta+this.h*n,o=this.acceleration(r);this.states.verlet={theta:r,omega:n+.5*this.h*o};const l=this.states.rk4,c=(t,e)=>[e,this.acceleration(t)],g=c(l.theta,l.omega),m=c(l.theta+.5*this.h*g[0],l.omega+.5*this.h*g[1]),y=c(l.theta+.5*this.h*m[0],l.omega+.5*this.h*m[1]),d=c(l.theta+this.h*y[0],l.omega+this.h*y[1]);this.states.rk4={theta:l.theta+this.h/6*(g[0]+2*m[0]+2*y[0]+d[0]),omega:l.omega+this.h/6*(g[1]+2*m[1]+2*y[1]+d[1])},this.time+=this.h,Math.floor(50*this.time)%3==0&&Object.keys(this.states).forEach(t=>{const e=this.energy(this.states[t].theta,this.states[t].omega);this.energyHistory[t].push({t:this.time,E:e}),this.energyHistory[t].length>this.maxSamples&&this.energyHistory[t].shift()}),this.updateStatus()}updateStatus(){document.getElementById("comparison-time").textContent=this.time.toFixed(2),Object.keys(this.states).forEach(t=>{const e=(this.energy(this.states[t].theta,this.states[t].omega)-this.initialEnergy)/this.initialEnergy*100;document.getElementById(`comparison-${t}-error`).textContent=e.toFixed(2)})}draw(){this.drawPendulum(),this.drawEnergyChart()}drawPendulum(){const t=this.ctx,e=this.canvas,s=.35*Math.min(e.width,e.height),i=e.width/2,h=.2*e.height;t.clearRect(0,0,e.width,e.height);const a=this.states[this.selectedIntegrator],n=i+s*Math.sin(a.theta),r=h+s*Math.cos(a.theta);t.strokeStyle=this.colors[this.selectedIntegrator],t.lineWidth=3,t.beginPath(),t.moveTo(i,h),t.lineTo(n,r),t.stroke(),t.fillStyle="#666",t.beginPath(),t.arc(i,h,5,0,2*Math.PI),t.fill(),t.fillStyle=this.colors[this.selectedIntegrator],t.beginPath(),t.arc(n,r,15,0,2*Math.PI),t.fill(),t.fillStyle="white",t.font="14px Arial",t.textAlign="center";const o={euler:"Explicit Euler",symplectic:"Symplectic Euler",verlet:"Velocity Verlet",rk4:"RK4"};t.fillText(o[this.selectedIntegrator],i,e.height-20)}drawEnergyChart(){const t=this.energyCtx,e=this.energyCanvas;t.clearRect(0,0,e.width,e.height);const s=35,i=e.width-2*s,h=e.height-2*s;let a=1/0,n=-1/0,r=1/0,o=-1/0;if(Object.keys(this.energyHistory).forEach(t=>{const e=this.energyHistory[t];0!==e.length&&e.forEach(t=>{a=Math.min(a,t.t),n=Math.max(n,t.t),r=Math.min(r,t.E),o=Math.max(o,t.E)})}),!isFinite(a))return;const l=Math.max(n-a,1),c=Math.max(o-r,.001);t.strokeStyle="#666",t.lineWidth=1,t.beginPath(),t.moveTo(s,s),t.lineTo(s,e.height-s),t.lineTo(e.width-s,e.height-s),t.stroke(),Object.keys(this.energyHistory).forEach(n=>{const o=this.energyHistory[n];if(o.length<2)return;t.strokeStyle=this.colors[n],t.lineWidth=2,t.beginPath();let g=!0;o.forEach(n=>{const o=s+(n.t-a)/l*i,m=e.height-s-(n.E-r)/c*h;g?(t.moveTo(o,m),g=!1):t.lineTo(o,m)}),t.stroke()}),t.fillStyle="#aaa",t.font="10px Arial",t.textAlign="center",t.fillText("Time (s)",e.width/2,e.height-5),t.save(),t.translate(12,e.height/2),t.rotate(-Math.PI/2),t.fillText("Energy",0,0),t.restore()}reset(){this.time=0,this.initialEnergy=this.energy(this.theta0,0),Object.keys(this.states).forEach(t=>{this.states[t]={theta:this.theta0,omega:0},this.energyHistory[t]=[]})}animate(){try{this.ctx&&this.energyCtx&&(this.step(),this.draw())}catch(t){console.warn("Comparison animation error:",t)}requestAnimationFrame(()=>this.animate())}}class PhaseSpaceSim{constructor(){this.theoryCanvas=document.getElementById("theory-phase-canvas"),this.comparisonCanvas=document.getElementById("comparison-phase-canvas"),this.theoryCanvas&&this.comparisonCanvas?(this.theoryCtx=this.theoryCanvas.getContext("2d"),this.comparisonCtx=this.comparisonCanvas.getContext("2d"),this.theoryCtx&&this.comparisonCtx?(this.L=1,this.g=9.81,this.h=.005,this.speed=1,this.running=!0,this.theta=Math.PI/4,this.omega=0,this.time=0,this.selectedMethod="symplectic",this.states={euler:{theta:this.theta,omega:this.omega,trail:[]},symplectic:{theta:this.theta,omega:this.omega,trail:[]},verlet:{theta:this.theta,omega:this.omega,trail:[]},rk4:{theta:this.theta,omega:this.omega,trail:[]}},this.colors={euler:"#ef4444",symplectic:"#22c55e",verlet:"#3b82f6",rk4:"#a855f7"},this.maxTrailLength=500,this.initialEnergy=this.energy(this.theta,this.omega),this.setupControls(),this.setupCanvasInteraction(),this.animate()):console.warn("Failed to get 2D context for phase space canvases")):console.warn("Phase space canvas elements not found")}setupControls(){document.getElementById("phase-play-pause").addEventListener("click",()=>{this.running=!this.running,document.getElementById("phase-play-pause").textContent=this.running?"Pause":"Play"}),document.getElementById("phase-reset").addEventListener("click",()=>{this.reset()}),document.getElementById("phase-clear").addEventListener("click",()=>{this.clearTrails()}),document.getElementById("phase-method-select").addEventListener("change",t=>{this.selectedMethod=t.target.value}),document.getElementById("phase-timestep-slider").addEventListener("input",t=>{this.h=parseFloat(t.target.value)/1e3,document.getElementById("phase-timestep").textContent=t.target.value}),document.getElementById("phase-speed-slider").addEventListener("input",t=>{this.speed=parseFloat(t.target.value),document.getElementById("phase-speed").textContent=t.target.value})}setupCanvasInteraction(){this.theoryCanvas.addEventListener("click",t=>{const e=this.theoryCanvas.getBoundingClientRect(),s=t.clientX-e.left,i=t.clientY-e.top,h=Math.min(this.theoryCanvas.width,this.theoryCanvas.height),a=this.theoryCanvas.width/2,n=this.theoryCanvas.height/2,r=.35*h,o=(s-a)/r*Math.PI,l=-(i-n)/r*6;Math.abs(o)<=Math.PI&&Math.abs(l)<=6&&this.setInitialConditions(o,l)})}setInitialConditions(t,e){this.theta=t,this.omega=e,this.time=0,this.initialEnergy=this.energy(t,e),Object.keys(this.states).forEach(s=>{this.states[s]={theta:t,omega:e,trail:[]}}),document.getElementById("theory-energy").textContent=this.initialEnergy.toFixed(2)}reset(){this.setInitialConditions(Math.PI/4,0)}clearTrails(){Object.keys(this.states).forEach(t=>{this.states[t].trail=[]})}acceleration(t){return-this.g/this.L*Math.sin(t)}energy(t,e){return this.g*this.L*(1-Math.cos(t))+this.L*this.L*.5*e*e}step(){if(this.running){for(let t=0;t<this.speed;t++){const t=this.states.euler,e=this.acceleration(t.theta);this.states.euler={theta:t.theta+this.h*t.omega,omega:t.omega+this.h*e,trail:t.trail};const s=this.states.symplectic,i=s.omega+this.h*this.acceleration(s.theta);this.states.symplectic={theta:s.theta+this.h*i,omega:i,trail:s.trail};const h=this.states.verlet,a=this.acceleration(h.theta),n=h.omega+.5*this.h*a,r=h.theta+this.h*n,o=this.acceleration(r);this.states.verlet={theta:r,omega:n+.5*this.h*o,trail:h.trail};const l=this.states.rk4,c=(t,e)=>[e,this.acceleration(t)],g=c(l.theta,l.omega),m=c(l.theta+.5*this.h*g[0],l.omega+.5*this.h*g[1]),y=c(l.theta+.5*this.h*m[0],l.omega+.5*this.h*m[1]),d=c(l.theta+this.h*y[0],l.omega+this.h*y[1]);this.states.rk4={theta:l.theta+this.h/6*(g[0]+2*m[0]+2*y[0]+d[0]),omega:l.omega+this.h/6*(g[1]+2*m[1]+2*y[1]+d[1]),trail:l.trail},this.time+=this.h}Math.floor(200*this.time)%2==0&&Object.keys(this.states).forEach(t=>{const e=this.states[t];e.trail.push({theta:e.theta,omega:e.omega}),e.trail.length>this.maxTrailLength&&e.trail.shift()}),this.updateStatus()}}updateStatus(){document.getElementById("phase-time").textContent=this.time.toFixed(2);const t=this.states[this.selectedMethod]||this.states.symplectic;document.getElementById("phase-theta").textContent=t.theta.toFixed(3),document.getElementById("phase-omega").textContent=t.omega.toFixed(3);const e=(this.energy(t.theta,t.omega)-this.initialEnergy)/this.initialEnergy*100;document.getElementById("phase-energy-error").textContent=e.toFixed(2)}drawTheoryPhasePortrait(){const t=this.theoryCtx,e=this.theoryCanvas,s=Math.min(e.width,e.height),i=e.width/2,h=e.height/2,a=.35*s;t.clearRect(0,0,e.width,e.height);[.5,1,2,4,6,8].forEach((e,s)=>{t.strokeStyle=`rgba(100, 100, 100, ${.3+.1*s})`,t.lineWidth=1,t.beginPath();let n=!0;for(let s=-Math.PI;s<=Math.PI;s+=.02){const r=this.g*this.L*(1-Math.cos(s));if(e>r){const o=e-r,l=Math.sqrt(2*o)/this.L,c=i+s/Math.PI*a,g=h-l/6*a;n?(t.moveTo(c,g),n=!1):t.lineTo(c,g)}}t.stroke(),t.beginPath(),n=!0;for(let s=-Math.PI;s<=Math.PI;s+=.02){const r=this.g*this.L*(1-Math.cos(s));if(e>r){const o=e-r,l=-Math.sqrt(2*o)/this.L,c=i+s/Math.PI*a,g=h-l/6*a;n?(t.moveTo(c,g),n=!1):t.lineTo(c,g)}}t.stroke()}),t.strokeStyle="#666",t.lineWidth=2,t.beginPath(),t.moveTo(0,h),t.lineTo(e.width,h),t.moveTo(i,0),t.lineTo(i,e.height),t.stroke();const n=i+this.theta/Math.PI*a,r=h-this.omega/6*a;t.fillStyle="#3b82f6",t.beginPath(),t.arc(n,r,6,0,2*Math.PI),t.fill(),t.fillStyle="#aaa",t.font="12px Arial",t.textAlign="center",t.fillText("\u03b8 (rad)",e.width/2,e.height-10),t.save(),t.translate(10,e.height/2),t.rotate(-Math.PI/2),t.fillText("\u03c9 (rad/s)",0,0),t.restore()}drawComparisonPhaseSpace(){const t=this.comparisonCtx,e=this.comparisonCanvas,s=Math.min(e.width,e.height),i=e.width/2,h=e.height/2,a=.35*s;t.clearRect(0,0,e.width,e.height),t.strokeStyle="#666",t.lineWidth=2,t.beginPath(),t.moveTo(0,h),t.lineTo(e.width,h),t.moveTo(i,0),t.lineTo(i,e.height),t.stroke();const n=this.initialEnergy;t.strokeStyle="rgba(100, 100, 100, 0.3)",t.lineWidth=2,t.setLineDash([5,5]),t.beginPath();let r=!0;for(let e=-Math.PI;e<=Math.PI;e+=.02){const s=this.g*this.L*(1-Math.cos(e));if(n>s){const o=n-s,l=Math.sqrt(2*o)/this.L,c=i+e/Math.PI*a,g=h-l/6*a;r?(t.moveTo(c,g),r=!1):t.lineTo(c,g)}}for(let e=Math.PI;e>=-Math.PI;e-=.02){const s=this.g*this.L*(1-Math.cos(e));if(n>s){const r=n-s,o=-Math.sqrt(2*r)/this.L,l=i+e/Math.PI*a,c=h-o/6*a;t.lineTo(l,c)}}if(t.stroke(),t.setLineDash([]),"all"===this.selectedMethod)Object.keys(this.states).forEach(e=>{const s=this.states[e],n=this.colors[e];s.trail.length>1&&(t.strokeStyle=n+"80",t.lineWidth=1,t.beginPath(),s.trail.forEach((e,s)=>{const n=i+e.theta/Math.PI*a,r=h-e.omega/6*a;0===s?t.moveTo(n,r):t.lineTo(n,r)}),t.stroke());const r=i+s.theta/Math.PI*a,o=h-s.omega/6*a;t.fillStyle=n,t.beginPath(),t.arc(r,o,4,0,2*Math.PI),t.fill()});else{const e=this.states[this.selectedMethod],s=this.colors[this.selectedMethod];e.trail.length>1&&(t.strokeStyle=s,t.lineWidth=2,t.beginPath(),e.trail.forEach((e,s)=>{const n=i+e.theta/Math.PI*a,r=h-e.omega/6*a;0===s?t.moveTo(n,r):t.lineTo(n,r)}),t.stroke());const n=i+e.theta/Math.PI*a,r=h-e.omega/6*a;t.fillStyle=s,t.beginPath(),t.arc(n,r,6,0,2*Math.PI),t.fill()}t.fillStyle="#aaa",t.font="12px Arial",t.textAlign="center",t.fillText("\u03b8 (rad)",e.width/2,e.height-10),t.save(),t.translate(10,e.height/2),t.rotate(-Math.PI/2),t.fillText("\u03c9 (rad/s)",0,0),t.restore()}animate(){try{this.theoryCtx&&this.comparisonCtx&&(this.step(),this.drawTheoryPhasePortrait(),this.drawComparisonPhaseSpace())}catch(t){console.warn("Phase space animation error:",t)}requestAnimationFrame(()=>this.animate())}}document.addEventListener("DOMContentLoaded",()=>{try{let t,e,s,i;document.getElementById("euler-canvas")&&document.getElementById("euler-energy")&&(t=new SinglePendulumSim("euler-canvas","euler-energy","euler","#ef4444")),document.getElementById("symplectic-canvas")&&document.getElementById("symplectic-energy")&&(e=new SinglePendulumSim("symplectic-canvas","symplectic-energy","symplectic","#22c55e")),document.getElementById("verlet-canvas")&&document.getElementById("verlet-energy")&&(s=new SinglePendulumSim("verlet-canvas","verlet-energy","verlet","#3b82f6")),document.getElementById("rk4-canvas")&&document.getElementById("rk4-energy")&&(i=new SinglePendulumSim("rk4-canvas","rk4-energy","rk4","#a855f7"));const h=(t,e)=>{if(t)try{const s=document.getElementById(`${e}-slider`),i=document.getElementById(`${e}-timestep`);s&&i&&s.addEventListener("input",e=>{t.h=parseFloat(e.target.value)/1e3,i.textContent=e.target.value});const h=document.getElementById(`${e}-play-pause`);h&&h.addEventListener("click",()=>{const e=t.togglePause();h.textContent=e?"Pause":"Play"});const a=document.getElementById(`${e}-reset`);a&&a.addEventListener("click",()=>{t.reset()});const n=document.getElementById(`${e}-error`);n&&setInterval(()=>{try{const e=t.getEnergyError();n.textContent=e.toFixed(2)}catch(t){console.warn(`Error updating ${e} display:`,t)}},100)}catch(t){console.warn(`Error setting up controls for ${e}:`,t)}};if(h(t,"euler"),h(e,"symplectic"),h(s,"verlet"),h(i,"rk4"),document.getElementById("comparison-canvas")&&document.getElementById("comparison-energy")){new ComparisonSim}if(document.getElementById("theory-phase-canvas")&&document.getElementById("comparison-phase-canvas"))try{new PhaseSpaceSim}catch(t){console.warn("Error initializing phase space simulation:",t)}if(document.getElementById("realtime-euler-canvas"))try{new RealtimeComparisonSim}catch(t){console.warn("Error initializing real-time comparison simulation:",t)}}catch(t){console.error("Error initializing simulations:",t)}});class RealtimeComparisonSim{constructor(){this.canvases={euler:document.getElementById("realtime-euler-canvas"),symplectic:document.getElementById("realtime-symplectic-canvas"),verlet:document.getElementById("realtime-verlet-canvas"),rk4:document.getElementById("realtime-rk4-canvas")};const t=Object.keys(this.canvases).filter(t=>!this.canvases[t]);t.length>0?console.warn("Missing realtime comparison canvases:",t):(this.contexts={},Object.keys(this.canvases).forEach(t=>{this.canvases[t]&&(this.contexts[t]=this.canvases[t].getContext("2d"),this.contexts[t]||console.warn(`Failed to get 2D context for ${t} canvas`))}),this.energyCanvas=document.getElementById("realtime-energy-chart"),this.energyCtx=this.energyCanvas?.getContext("2d"),this.energyCanvas&&this.energyCtx||console.warn("Realtime energy chart canvas not found or context unavailable"),this.L=1,this.g=9.81,this.h=.01,this.theta0=Math.PI/4,this.running=!0,this.states={euler:{theta:this.theta0,omega:0},symplectic:{theta:this.theta0,omega:0},verlet:{theta:this.theta0,omega:0},rk4:{theta:this.theta0,omega:0}},this.energyHistory={euler:[],symplectic:[],verlet:[],rk4:[]},this.colors={euler:"#ef4444",symplectic:"#22c55e",verlet:"#3b82f6",rk4:"#a855f7"},this.time=0,this.initialEnergy=this.energy(this.theta0,0),this.maxSamples=300,this.setupControls(),this.animate())}setupControls(){document.getElementById("realtime-play-pause")?.addEventListener("click",()=>{this.running=!this.running,document.getElementById("realtime-play-pause").textContent=this.running?"Pause":"Play"}),document.getElementById("realtime-reset")?.addEventListener("click",()=>{this.reset()}),document.getElementById("realtime-sync")?.addEventListener("click",()=>{this.syncMethods()}),document.getElementById("realtime-angle-slider")?.addEventListener("input",t=>{this.theta0=parseFloat(t.target.value)*Math.PI/180,document.getElementById("realtime-angle").textContent=t.target.value,this.reset()}),document.getElementById("realtime-timestep-slider")?.addEventListener("input",t=>{this.h=parseFloat(t.target.value)/1e3,document.getElementById("realtime-timestep").textContent=t.target.value})}syncMethods(){Object.keys(this.states).forEach(t=>{this.states[t]={theta:this.theta0,omega:0},this.energyHistory[t]=[]}),this.time=0,this.initialEnergy=this.energy(this.theta0,0)}reset(){this.theta0=Math.PI/4,this.time=0,this.initialEnergy=this.energy(this.theta0,0),Object.keys(this.states).forEach(t=>{this.states[t]={theta:this.theta0,omega:0},this.energyHistory[t]=[]}),document.getElementById("realtime-angle").textContent="45",document.getElementById("realtime-angle-slider").value="45"}acceleration(t){return-this.g/this.L*Math.sin(t)}energy(t,e){return this.g*this.L*(1-Math.cos(t))+this.L*this.L*.5*e*e}step(){if(!this.running)return;const t=this.states.euler,e=this.acceleration(t.theta);this.states.euler={theta:t.theta+this.h*t.omega,omega:t.omega+this.h*e};const s=this.states.symplectic,i=s.omega+this.h*this.acceleration(s.theta);this.states.symplectic={theta:s.theta+this.h*i,omega:i};const h=this.states.verlet,a=this.acceleration(h.theta),n=h.omega+.5*this.h*a,r=h.theta+this.h*n,o=this.acceleration(r);this.states.verlet={theta:r,omega:n+.5*this.h*o};const l=this.states.rk4,c=(t,e)=>[e,this.acceleration(t)],g=c(l.theta,l.omega),m=c(l.theta+.5*this.h*g[0],l.omega+.5*this.h*g[1]),y=c(l.theta+.5*this.h*m[0],l.omega+.5*this.h*m[1]),d=c(l.theta+this.h*y[0],l.omega+this.h*y[1]);this.states.rk4={theta:l.theta+this.h/6*(g[0]+2*m[0]+2*y[0]+d[0]),omega:l.omega+this.h/6*(g[1]+2*m[1]+2*y[1]+d[1])},this.time+=this.h,Math.floor(50*this.time)%3==0&&Object.keys(this.states).forEach(t=>{const e=this.energy(this.states[t].theta,this.states[t].omega);this.energyHistory[t].push({t:this.time,E:e}),this.energyHistory[t].length>this.maxSamples&&this.energyHistory[t].shift()}),this.updateStatus()}updateStatus(){document.getElementById("realtime-time").textContent=this.time.toFixed(2),Object.keys(this.states).forEach(t=>{const e=(this.energy(this.states[t].theta,this.states[t].omega)-this.initialEnergy)/this.initialEnergy*100;document.getElementById(`realtime-${t}-error`).textContent=e.toFixed(2)})}drawPendulum(t){const e=this.contexts[t],s=this.canvases[t];if(!e||!s)return;const i=.3*Math.min(s.width,s.height),h=s.width/2,a=.25*s.height;e.clearRect(0,0,s.width,s.height);const n=this.states[t],r=h+i*Math.sin(n.theta),o=a+i*Math.cos(n.theta);e.strokeStyle=this.colors[t],e.lineWidth=3,e.beginPath(),e.moveTo(h,a),e.lineTo(r,o),e.stroke(),e.fillStyle="#666",e.beginPath(),e.arc(h,a,4,0,2*Math.PI),e.fill(),e.fillStyle=this.colors[t],e.beginPath(),e.arc(r,o,8,0,2*Math.PI),e.fill();const l=(this.energy(n.theta,n.omega)-this.initialEnergy)/this.initialEnergy*100;e.fillStyle=this.colors[t],e.font="11px Arial",e.textAlign="center",e.fillText(`${l.toFixed(1)}%`,h,s.height-10)}drawEnergyChart(){if(!this.energyCtx||!this.energyCanvas)return;const t=this.energyCtx,e=this.energyCanvas;t.clearRect(0,0,e.width,e.height);const s=40,i=e.width-2*s,h=e.height-2*s;let a=1/0,n=-1/0,r=1/0,o=-1/0;if(Object.keys(this.energyHistory).forEach(t=>{this.energyHistory[t].forEach(t=>{a=Math.min(a,t.t),n=Math.max(n,t.t),r=Math.min(r,t.E),o=Math.max(o,t.E)})}),!isFinite(a))return;const l=Math.max(n-a,1),c=Math.max(o-r,.001);t.strokeStyle="#666",t.lineWidth=1,t.beginPath(),t.moveTo(s,s),t.lineTo(s,e.height-s),t.lineTo(e.width-s,e.height-s),t.stroke();const g=e.height-s-(this.initialEnergy-r)/c*h;t.strokeStyle="#666",t.setLineDash([5,5]),t.beginPath(),t.moveTo(s,g),t.lineTo(e.width-s,g),t.stroke(),t.setLineDash([]),Object.keys(this.energyHistory).forEach(n=>{const o=this.energyHistory[n];if(o.length<2)return;t.strokeStyle=this.colors[n],t.lineWidth=2,t.beginPath();let g=!0;o.forEach(n=>{const o=s+(n.t-a)/l*i,m=e.height-s-(n.E-r)/c*h;g?(t.moveTo(o,m),g=!1):t.lineTo(o,m)}),t.stroke()}),t.fillStyle="#aaa",t.font="12px Arial",t.textAlign="center",t.fillText("Time (s)",e.width/2,e.height-5),t.save(),t.translate(15,e.height/2),t.rotate(-Math.PI/2),t.fillText("Energy",0,0),t.restore()}animate(){try{this.step(),Object.keys(this.canvases).forEach(t=>{this.canvases[t]&&this.contexts[t]&&this.drawPendulum(t)}),this.energyCtx&&this.drawEnergyChart()}catch(t){console.warn("Realtime comparison animation error:",t)}requestAnimationFrame(()=>this.animate())}}</script>]]></content><author><name></name></author><category term="blog"/><category term="energy-drift"/><category term="physics"/><category term="simulation"/><category term="numerical-methods"/><category term="energy-conservation"/><category term="symplectic-integrators"/><category term="computational-physics"/><summary type="html"><![CDATA[Interactive exploration of numerical integration schemes and energy conservation in physics simulations. Master symplectic methods, stability analysis, and the mathematical foundations of computational physics.]]></summary></entry></feed>