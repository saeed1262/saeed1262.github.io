<!DOCTYPE html> <html lang="en"> <head> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>Fast Collision in Games: Spatial Hashing vs. Naïve | Saeed Ghorbani</title> <meta name="author" content="Saeed Ghorbani"/> <meta name="description" content="An interactive broad‑phase collision demo showing why uniform grids (spatial hashing) beat O(n²) for many moving objects in real‑time games."/> <meta name="keywords" content="machine learning, computer vision, computer graphics, computer animation, human motion modeling, probabilistic models, deep learning, research scientist, Amazon Games, motion synthesis, pose estimation, gesture generation"/> <meta property="og:site_name" content="Saeed Ghorbani"/> <meta property="og:type" content="website"/> <meta property="og:title" content="Saeed Ghorbani | Fast Collision in Games: Spatial Hashing vs. Naïve"/> <meta property="og:url" content="https://saeed1262.github.io/blog/2025/spatial-hashing-collision/"/> <meta property="og:description" content="An interactive broad‑phase collision demo showing why uniform grids (spatial hashing) beat O(n²) for many moving objects in real‑time games."/> <meta property="og:image" content="/assets/img/saeed.jpg"/> <meta property="og:locale" content="en"/> <meta name="twitter:card" content="summary"/> <meta name="twitter:title" content="Fast Collision in Games: Spatial Hashing vs. Naïve"/> <meta name="twitter:description" content="An interactive broad‑phase collision demo showing why uniform grids (spatial hashing) beat O(n²) for many moving objects in real‑time games."/> <meta name="twitter:image" content="/assets/img/saeed.jpg"/> <meta name="twitter:site" content="@SaGhorbani"/> <meta name="twitter:creator" content="@SaGhorbani"/> <script type="application/ld+json">
      {
        "author":
        {
          "@type": "Person",
          "name": "Saeed  Ghorbani"
        },
        "url": "https://saeed1262.github.io/blog/2025/spatial-hashing-collision/",
        "@type": "WebSite",
        "description": "An interactive broad‑phase collision demo showing why uniform grids (spatial hashing) beat O(n²) for many moving objects in real‑time games.",
        "headline": "Fast Collision in Games: Spatial Hashing vs. Naïve",
        "sameAs": ["https://scholar.google.com/citations?user=JFRY_g8AAAAJ&hl", "https://github.com/saeed1262", "https://www.linkedin.com/in/saeed-ghorbani-ba4872136", "https://twitter.com/SaGhorbani"],
        "name": "Saeed  Ghorbani",
        "@context": "https://schema.org"
      }
    </script> <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin> <link rel="preconnect" href="https://fonts.googleapis.com" crossorigin> <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin> <link rel="dns-prefetch" href="//www.google-analytics.com"> <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"> <meta name="theme-color" content="#6c63ff"> <meta name="apple-mobile-web-app-capable" content="yes"> <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"> <meta name="msapplication-TileColor" content="#6c63ff"> <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"/> <link rel="preload" href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&family=Roboto+Slab:wght@100;300;400;500;700&display=swap" as="style" onload="this.onload=null;this.rel='stylesheet'"> <noscript><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&family=Roboto+Slab:wght@100;300;400;500;700&display=swap"></noscript> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="none" id="highlight_theme_light"/> <link rel="shortcut icon" href="/assets/img/fav.png"/> <link rel="preload" href="/assets/css/main.css" as="style" onload="this.onload=null;this.rel='stylesheet'"> <noscript><link rel="stylesheet" href="/assets/css/main.css"></noscript> <link rel="canonical" href="https://saeed1262.github.io/blog/2025/spatial-hashing-collision/"> <meta name="robots" content="index, follow, max-image-preview:large, max-snippet:-1, max-video-preview:-1"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/native.css" media="none" id="highlight_theme_dark"/> <script src="/assets/js/theme.js"></script> <script src="/assets/js/dark_mode.js"></script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="https://saeed1262.github.io/">Saeed Ghorbani</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">About</a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">Blog<span class="sr-only">(current)</span></a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">Publications</a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">Projects</a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">CV</a> </li> <li class="nav-item dropdown "> <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">Submenus</a> <div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdown"> <a class="dropdown-item" href="/publications/">publications</a> <div class="dropdown-divider"></div> <a class="dropdown-item" href="/projects/">projects</a> </div> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fas fa-moon"></i> <i class="fas fa-sun"></i> </button> </li> </ul> </div> </div> </nav> </header> <div class="container mt-5"> <div class="post"> <header class="post-header"> <h1 class="post-title">Fast Collision in Games: Spatial Hashing vs. Naïve</h1> <p class="post-meta">August 24, 2025</p> <p class="post-tags"> <a href="/blog/2025"> <i class="fas fa-calendar fa-sm"></i> 2025 </a>   ·   <a href="/blog/tag/game-dev"> <i class="fas fa-hashtag fa-sm"></i> game-dev</a>   <a href="/blog/tag/algorithms"> <i class="fas fa-hashtag fa-sm"></i> algorithms</a>   <a href="/blog/tag/collision-detection"> <i class="fas fa-hashtag fa-sm"></i> collision-detection</a>   <a href="/blog/tag/performance"> <i class="fas fa-hashtag fa-sm"></i> performance</a>   <a href="/blog/tag/interactive"> <i class="fas fa-hashtag fa-sm"></i> interactive</a>     ·   <a href="/blog/category/blog"> <i class="fas fa-tag fa-sm"></i> blog</a>   </p> </header> <article class="post-content"> <p>When hundreds of objects move every frame, naïvely checking all pairs is O(n²) and quickly tanks performance. Games use a broad‑phase to prune most pairs before precise (narrow‑phase) checks. A simple and effective broad‑phase is a uniform grid, also called spatial hashing.</p> <p>Below you can toggle between Naïve and Spatial Hashing, adjust object counts, and visualize grid cells and candidate pairs. Watch the collision‑checks counter as n scales.</p> <div id="hash-container"> <div id="hash-controls"> <div class="control-group"> <label>Algorithm</label> <div class="control-row"> <select id="algo"> <option value="hash">Spatial Hash</option> <option value="naive">Naïve O(n²)</option> </select> </div> </div> <div class="control-group"> <label>Objects: <span class="value" id="countLabel">300</span></label> <input id="count" type="range" min="50" max="1200" step="10" value="300"> </div> <div class="control-group"> <label>Cell Size: <span class="value" id="cellLabel">32</span> px</label> <input id="cell" type="range" min="12" max="80" step="4" value="32"> </div> <div class="control-group"> <label>Speed: <span class="value" id="speedLabel">1.0x</span></label> <input id="speed" type="range" min="0.25" max="2.0" step="0.25" value="1.0"> </div> <div class="control-group"> <label>Visuals</label> <div class="control-row"> <label class="checkbox"><input id="showGrid" type="checkbox" checked> Grid</label> <label class="checkbox"><input id="showCandidates" type="checkbox"> Candidates</label> <label class="checkbox"><input id="pause" type="checkbox"> Pause</label> </div> </div> </div> <div id="hash-viz-container"> <canvas id="hash-viz" width="1280" height="720" aria-label="Spatial hashing collision demo"></canvas> <div class="loading" id="loading">Preparing simulation…</div> <div class="no-canvas" id="noCanvas" hidden="">Your browser does not support Canvas.</div> </div> <div id="hash-hud"> <div class="hud-panel"> <h4>Performance</h4> <div class="hud-value"> <span class="label">Algorithm</span><span class="value" id="hudAlgo">Spatial Hash</span> </div> <div class="hud-value"> <span class="label">Objects</span><span class="value" id="hudCount">300</span> </div> <div class="hud-value"> <span class="label">Cell Size</span><span class="value" id="hudCell">32 px</span> </div> <div class="hud-value"> <span class="label">Broad‑phase Pairs</span><span class="value" id="hudPairs">0</span> </div> <div class="hud-value"> <span class="label">Collision Checks</span><span class="value" id="hudChecks">0</span> </div> <div class="hud-value"> <span class="label">FPS</span><span class="value" id="hudFps">0</span> </div> </div> <div class="hud-panel"> <h4>Notes</h4> <ul class="notes"> <li>Uniform grid partitions space; objects visit only nearby cells.</li> <li>Broad‑phase prunes pairs; narrow‑phase confirms actual overlaps.</li> <li>Best grid size ≈ 1–2× object diameter for circles/AABBs.</li> </ul> </div> </div> </div> <link rel="stylesheet" href="/assets/css/spatial-hash.css"> <script defer src="/assets/js/spatial-hash.js"></script> <h2 id="why-i-built-this">Why I Built This</h2> <p>In real‑time games, hundreds or thousands of moving objects need collision checks every frame. The straightforward way—compare everything with everything—blows up quadratically and crushes frame time. I wanted an interactive, visual way to show how a simple broad‑phase like a uniform grid (aka spatial hashing) turns this into near‑linear work for typical scenes. The demo mirrors how production engines prune pairs before doing precise tests.</p> <h2 id="what-you-can-do">What You Can Do</h2> <ul> <li>Toggle <code class="language-plaintext highlighter-rouge">Algorithm</code> between <code class="language-plaintext highlighter-rouge">Naïve O(n²)</code> and <code class="language-plaintext highlighter-rouge">Spatial Hash</code> and watch <code class="language-plaintext highlighter-rouge">Broad‑phase Pairs</code> and <code class="language-plaintext highlighter-rouge">Collision Checks</code> in the HUD.</li> <li>Drag <code class="language-plaintext highlighter-rouge">Objects</code> higher. Naïve explodes in work; hashing stays smooth until you really crowd the scene.</li> <li>Vary <code class="language-plaintext highlighter-rouge">Cell Size</code>. Try around the object diameter for best pruning; too small or too large hurts.</li> <li>Enable <code class="language-plaintext highlighter-rouge">Grid</code> to see the uniform cells; enable <code class="language-plaintext highlighter-rouge">Candidates</code> to visualize broad‑phase pair hypotheses.</li> <li>Nudge <code class="language-plaintext highlighter-rouge">Speed</code> up to stress the system; combine with small cells to see dedup rules still hold.</li> </ul> <h2 id="broadphase-vs-narrowphase">Broad‑Phase vs Narrow‑Phase</h2> <ul> <li>Broad‑phase: fast, conservative culling to propose potential overlaps (same or adjacent cells). Output is a set of candidate pairs.</li> <li>Narrow‑phase: precise, more expensive test (e.g., circle vs circle, AABB vs AABB, or SAT for polygons) to confirm real collisions.</li> <li>The broad‑phase should be cheap enough to run every frame and accurate enough that most true overlaps are proposed without flooding the narrow‑phase with false positives.</li> </ul> <h2 id="complexity-and-scaling">Complexity and Scaling</h2> <ul> <li>Naïve: O(n²) candidate pairs. Doubling n → ~4× more comparisons.</li> <li>Spatial hash: O(n + k), where k is the number of candidate pairs from local neighbors. With a good cell size and reasonably uniform distribution, k ≈ c·n with small c.</li> <li>Example intuition: At 1,000 objects, naïve emits ~500k pairs. With a grid tuned to object size, each object often sees only tens of neighbors, yielding tens of thousands of pairs instead of hundreds of thousands.</li> <li>Pathological worst case exists (everyone in one cell) but is rare with sane parameters and motion.</li> </ul> <h2 id="visual-intuition">Visual Intuition</h2> <p>Only neighbors in your 3×3 cell neighborhood can collide in 2D (27 cells in 3D). The grid shrinks the search from “the whole world” to “just around me.”</p> <div style="text-align:center; margin: 1rem 0;"> <svg viewbox="0 0 220 220" width="360" height="360" style="max-width: 100%; background: #0f1117; border: 1px solid #222; border-radius: 10px;"> <defs> <pattern id="grid" width="20" height="20" patternunits="userSpaceOnUse"> <path d="M 20 0 L 0 0 0 20" fill="none" stroke="#273447" stroke-width="1"></path> </pattern> </defs> <rect x="10" y="10" width="200" height="200" fill="url(#grid)" stroke="#334155"></rect> <rect x="90" y="90" width="20" height="20" fill="rgba(100,255,218,0.12)" stroke="#64ffda"></rect> <g fill="rgba(100,255,218,0.05)" stroke="#3b82f6"> <rect x="70" y="70" width="20" height="20"></rect> <rect x="90" y="70" width="20" height="20"></rect> <rect x="110" y="70" width="20" height="20"></rect> <rect x="70" y="90" width="20" height="20"></rect> <rect x="110" y="90" width="20" height="20"></rect> <rect x="70" y="110" width="20" height="20"></rect> <rect x="90" y="110" width="20" height="20"></rect> <rect x="110" y="110" width="20" height="20"></rect> </g> <circle cx="100" cy="100" r="5" fill="#e879f9"></circle> <circle cx="132" cy="98" r="5" fill="#60a5fa"></circle> <circle cx="88" cy="120" r="5" fill="#34d399"></circle> <circle cx="58" cy="76" r="5" fill="#f472b6"></circle> <text x="110" y="30" fill="#94a3b8" font-size="12" text-anchor="middle">Only test within these cells</text> </svg> <div style="color:#94a3b8; font-size: 0.95rem; margin-top: 0.25rem;">Broad‑phase limits candidates to the 3×3 neighborhood.</div> </div> <h3 id="why-spatial-hashing-works">Why Spatial Hashing Works</h3> <ul> <li>Broad‑phase reduces pair candidates from O(n²) toward O(n) on average by restricting checks to neighbors in the same or adjacent cells.</li> <li>The grid key can be computed with integer division; a small hash map keeps cell→object lists per frame.</li> <li>For robustness, only emit pairs with i &lt; j to avoid duplicates; optionally use a small seen‑set if objects span multiple cells.</li> </ul> <p>This pattern scales well and is a staple in physics, AI sensing, particle systems, and effects. In production, you may switch to a quadtree, BVH, or clustered grids for heterogeneous sizes, but a uniform hash is hard to beat for simplicity and speed.</p> <h2 id="how-the-demo-works">How the Demo Works</h2> <ul> <li>Integrate motion: update positions with simple Euler and wall bounces.</li> <li>Build grid: for each circle, insert its covered cells into a <code class="language-plaintext highlighter-rouge">Map</code> keyed by integer cell coords.</li> <li>Emit candidates: iterate each occupied cell and its neighbors; enforce <code class="language-plaintext highlighter-rouge">i &lt; j</code> to avoid duplicates.</li> <li>Narrow‑phase: circle‑circle distance test for each candidate pair; mark colliding objects.</li> <li>Visualize: draw the grid (optional), candidate lines (optional), and circles with collision tint.</li> <li>HUD: report algorithm, object count, cell size, candidate pair count, precise check count, and FPS.</li> </ul> <p>The implementation is in <code class="language-plaintext highlighter-rouge">assets/js/spatial-hash.js</code>. The grid uses string keys like <code class="language-plaintext highlighter-rouge">"gx,gy"</code> and a small set to deduplicate pairs across neighboring cells. Everything is rebuilt per frame to reflect motion—simple and cache‑friendly in JS.</p> <h2 id="experiments-to-try">Experiments To Try</h2> <ul> <li>Double <code class="language-plaintext highlighter-rouge">Objects</code> while in <code class="language-plaintext highlighter-rouge">Naïve</code> and watch checks explode; switch to <code class="language-plaintext highlighter-rouge">Spatial Hash</code> to see the difference.</li> <li>Sweep <code class="language-plaintext highlighter-rouge">Cell Size</code> from too small → optimal → too large and note how <code class="language-plaintext highlighter-rouge">Broad‑phase Pairs</code> changes.</li> <li>Turn on <code class="language-plaintext highlighter-rouge">Candidates</code>, then toggle algorithms to see how local the lines become with hashing.</li> <li>Max out <code class="language-plaintext highlighter-rouge">Speed</code> and observe missed cases when using too few substeps—then lower speed or slightly inflate AABBs in the broad‑phase.</li> </ul> <h3 id="naïve-vs-hashing-mental-model">Naïve vs. Hashing: Mental Model</h3> <ul> <li>Naïve O(n²): Every frame, compare each object with every other. Work ~ n(n-1)/2; doubling n ~4× comparisons.</li> <li>Spatial Hash O(n + k): Insert all objects into a grid (O(n)), then only test neighbors inside the same/adjacent cells. If objects are fairly evenly distributed and cell size matches object size, each object sees a constant number of neighbors on average, so k ~ c·n.</li> <li>Worst case still exists: If everything piles into one cell, you’re back to O(n²). Good parameters and mild randomness avoid this.</li> </ul> <h3 id="choosing-cell-size">Choosing Cell Size</h3> <ul> <li>Rule of thumb: cell size ≈ object diameter (for circles/spheres) or the larger dimension of the AABB.</li> <li>Too small: each object touches many cells; higher bookkeeping and deduplication work.</li> <li>Too large: too many unrelated objects share a cell; more false candidate pairs.</li> <li>2D vs 3D: neighbors are 9 cells in 2D (3×3 around you) and 27 in 3D (3×3×3).</li> </ul> <h3 id="core-pseudocode-2d-circlesaabbs">Core Pseudocode (2D circles/AABBs)</h3> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Integer cell coordinate from world position
cell(p, size) = (floor(p.x / size), floor(p.y / size))

// Build the grid (hash map from (cx,cy) -&gt; list of indices)
grid.clear()
for i in 0..n-1:
  aabb = bounds(i)               // center + radius or min/max
  (cx0, cy0) = cell(aabb.min, S)
  (cx1, cy1) = cell(aabb.max, S)
  for cy in cy0..cy1:
    for cx in cx0..cx1:
      grid[(cx,cy)].push(i)

// Emit pairs from each occupied cell
pairs.clear()
for each (cx,cy) in grid.keys():
  for ny in cy-1..cy+1:
    for nx in cx-1..cx+1:
      let A = grid[(cx,cy)]
      let B = grid[(nx,ny)]
      // order rule avoids duplicates: only if (nx,ny) &gt;= (cx,cy)
      if (ny &lt; cy) or (ny == cy and nx &lt; cx): continue
      for each i in A:
        for each j in B:
          if (A == B and j &lt;= i): continue  // keep i&lt;j
          if narrowPhaseOverlap(i, j):
            pairs.add((i,j))
</code></pre></div></div> <p>Notes:</p> <ul> <li>The “order rule” prevents the same pair from being emitted from multiple neighboring cells.</li> <li>If objects are small relative to S, each object spans 1–4 cells in 2D (1–8 in 3D).</li> <li>Use contiguous arrays and reuse buffers to avoid per‑frame allocation.</li> </ul> <h3 id="hashing-implementation-details">Hashing Implementation Details</h3> <ul> <li>Key packing: convert <code class="language-plaintext highlighter-rouge">(cx, cy)</code> to a single integer key, e.g., <code class="language-plaintext highlighter-rouge">(int64(cx) &lt;&lt; 32) ^ (cy &amp; 0xffffffff)</code> or use a proper hash of the pair.</li> <li>Data layout: prefer <code class="language-plaintext highlighter-rouge">struct of arrays</code> (SoA) for positions/radii to be cache‑friendly in the tight loops.</li> <li>Frame clearing: instead of freeing maps, keep capacity and reset lengths; pool cell lists for reuse.</li> <li>Stable ordering: keep object indices stable to improve cache locality across frames.</li> </ul> <h3 id="handling-high-speeds-ccd">Handling High Speeds (CCD)</h3> <ul> <li>Broad‑phase with static AABBs can miss fast objects that tunnel through each other between frames.</li> <li>Common fixes: <ul> <li>Inflate AABBs by velocity over the timestep (swept AABB) before broad‑phase.</li> <li>Integrate in substeps when speeds are high relative to object size.</li> <li>Use time‑of‑impact narrow‑phase for critical objects only.</li> </ul> </li> </ul> <h3 id="variable-sizes-and-density">Variable Sizes and Density</h3> <ul> <li>Mixed scales: large and tiny objects together degrade uniform grids. Options: <ul> <li>Multi‑level grids (different S per tier; insert by size class).</li> <li>Insert big objects into all cells overlapped; cap per‑cell occupancy.</li> <li>Hybrid broad‑phase: grid for smalls, sweep‑and‑prune or BVH for larges.</li> </ul> </li> <li>Crowding: if a cell exceeds a threshold, adapt (split cell, switch to secondary structure) or increase S slightly.</li> </ul> <h3 id="performance-tips">Performance Tips</h3> <ul> <li>Avoid hash map churn: precompute world‑to‑cell bounds and allocate a fixed window when the world is limited. For infinite worlds, use a custom open‑addressing hash.</li> <li>SIMD: distance checks for circles/AABBs vectorize well; batch candidate pairs.</li> <li>Parallelism: split space into strips or blocks; merge pairs afterward. Be careful with duplicates across boundaries.</li> <li>Metrics: track “broad‑phase pairs per object” and “narrow‑phase hits” to tune S.</li> </ul> <h3 id="how-it-compares">How It Compares</h3> <ul> <li>Sweep and Prune (SAP): great along one axis when motion is coherent; widely used in physics engines.</li> <li>Quad/Octrees: adapt to non‑uniform densities but cost more to update with many movers.</li> <li>BVH: excellent for static or semi‑static geometry; dynamic rebuilds are pricier.</li> <li>Uniform Grid/Hash: minimal code, fast updates, shines with many similar‑sized dynamic objects.</li> </ul> <h3 id="tiny-javascript-example">Tiny JavaScript Example</h3> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 64-bit style key using two 32-bit signed ints</span>
<span class="kd">const</span> <span class="nx">key</span> <span class="o">=</span> <span class="p">(</span><span class="nx">cx</span><span class="p">,</span> <span class="nx">cy</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="nc">BigInt</span><span class="p">(</span><span class="nx">cx</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="nx">n</span><span class="p">)</span> <span class="o">^</span> <span class="p">(</span><span class="nc">BigInt</span><span class="p">(</span><span class="nx">cy</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xffffffff</span><span class="nx">n</span><span class="p">);</span>

<span class="kd">function</span> <span class="nf">buildGrid</span><span class="p">(</span><span class="nx">objs</span><span class="p">,</span> <span class="nx">S</span><span class="p">,</span> <span class="nx">grid</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">grid</span><span class="p">.</span><span class="nf">clear</span><span class="p">();</span>
  <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">objs</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">o</span> <span class="o">=</span> <span class="nx">objs</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
    <span class="kd">const</span> <span class="nx">minx</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">((</span><span class="nx">o</span><span class="p">.</span><span class="nx">x</span> <span class="o">-</span> <span class="nx">o</span><span class="p">.</span><span class="nx">r</span><span class="p">)</span> <span class="o">/</span> <span class="nx">S</span><span class="p">);</span>
    <span class="kd">const</span> <span class="nx">maxx</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">((</span><span class="nx">o</span><span class="p">.</span><span class="nx">x</span> <span class="o">+</span> <span class="nx">o</span><span class="p">.</span><span class="nx">r</span><span class="p">)</span> <span class="o">/</span> <span class="nx">S</span><span class="p">);</span>
    <span class="kd">const</span> <span class="nx">miny</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">((</span><span class="nx">o</span><span class="p">.</span><span class="nx">y</span> <span class="o">-</span> <span class="nx">o</span><span class="p">.</span><span class="nx">r</span><span class="p">)</span> <span class="o">/</span> <span class="nx">S</span><span class="p">);</span>
    <span class="kd">const</span> <span class="nx">maxy</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">floor</span><span class="p">((</span><span class="nx">o</span><span class="p">.</span><span class="nx">y</span> <span class="o">+</span> <span class="nx">o</span><span class="p">.</span><span class="nx">r</span><span class="p">)</span> <span class="o">/</span> <span class="nx">S</span><span class="p">);</span>
    <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">cy</span> <span class="o">=</span> <span class="nx">miny</span><span class="p">;</span> <span class="nx">cy</span> <span class="o">&lt;=</span> <span class="nx">maxy</span><span class="p">;</span> <span class="nx">cy</span><span class="o">++</span><span class="p">)</span>
      <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">cx</span> <span class="o">=</span> <span class="nx">minx</span><span class="p">;</span> <span class="nx">cx</span> <span class="o">&lt;=</span> <span class="nx">maxx</span><span class="p">;</span> <span class="nx">cx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">k</span> <span class="o">=</span> <span class="nf">key</span><span class="p">(</span><span class="nx">cx</span><span class="p">,</span> <span class="nx">cy</span><span class="p">);</span>
        <span class="kd">let</span> <span class="nx">arr</span> <span class="o">=</span> <span class="nx">grid</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="nx">k</span><span class="p">);</span>
        <span class="k">if </span><span class="p">(</span><span class="o">!</span><span class="nx">arr</span><span class="p">)</span> <span class="nx">grid</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">k</span><span class="p">,</span> <span class="p">(</span><span class="nx">arr</span> <span class="o">=</span> <span class="p">[]));</span>
        <span class="nx">arr</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span>
      <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nf">emitPairs</span><span class="p">(</span><span class="nx">grid</span><span class="p">,</span> <span class="nx">objs</span><span class="p">,</span> <span class="nx">S</span><span class="p">,</span> <span class="nx">outPairs</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">outPairs</span><span class="p">.</span><span class="nx">length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">for </span><span class="p">(</span><span class="kd">const</span> <span class="p">[</span><span class="nx">k</span><span class="p">,</span> <span class="nx">A</span><span class="p">]</span> <span class="k">of</span> <span class="nx">grid</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">cy</span> <span class="o">=</span> <span class="nc">Number</span><span class="p">((</span><span class="nx">k</span> <span class="o">&amp;</span> <span class="mh">0xffffffff</span><span class="nx">n</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="nx">n</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="nx">n</span><span class="p">);</span> <span class="c1">// sign-extend</span>
    <span class="kd">const</span> <span class="nx">cx</span> <span class="o">=</span> <span class="nc">Number</span><span class="p">(</span><span class="nx">k</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="nx">n</span><span class="p">);</span>
    <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">ny</span> <span class="o">=</span> <span class="nx">cy</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">ny</span> <span class="o">&lt;=</span> <span class="nx">cy</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">ny</span><span class="o">++</span><span class="p">)</span>
      <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">nx</span> <span class="o">=</span> <span class="nx">cx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">nx</span> <span class="o">&lt;=</span> <span class="nx">cx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">nx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// order rule to avoid duplicates</span>
        <span class="k">if </span><span class="p">(</span><span class="nx">ny</span> <span class="o">&lt;</span> <span class="nx">cy</span> <span class="o">||</span> <span class="p">(</span><span class="nx">ny</span> <span class="o">===</span> <span class="nx">cy</span> <span class="o">&amp;&amp;</span> <span class="nx">nx</span> <span class="o">&lt;</span> <span class="nx">cx</span><span class="p">))</span> <span class="k">continue</span><span class="p">;</span>
        <span class="kd">const</span> <span class="nx">B</span> <span class="o">=</span> <span class="nx">grid</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="nf">key</span><span class="p">(</span><span class="nx">nx</span><span class="p">,</span> <span class="nx">ny</span><span class="p">));</span>
        <span class="k">if </span><span class="p">(</span><span class="o">!</span><span class="nx">B</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
        <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">ai</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">ai</span> <span class="o">&lt;</span> <span class="nx">A</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">ai</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">const</span> <span class="nx">i</span> <span class="o">=</span> <span class="nx">A</span><span class="p">[</span><span class="nx">ai</span><span class="p">];</span>
          <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">bj</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">bj</span> <span class="o">&lt;</span> <span class="nx">B</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">bj</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="kd">const</span> <span class="nx">j</span> <span class="o">=</span> <span class="nx">B</span><span class="p">[</span><span class="nx">bj</span><span class="p">];</span>
            <span class="k">if </span><span class="p">(</span><span class="nx">A</span> <span class="o">===</span> <span class="nx">B</span> <span class="o">&amp;&amp;</span> <span class="nx">j</span> <span class="o">&lt;=</span> <span class="nx">i</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
            <span class="c1">// circle narrow-phase</span>
            <span class="kd">const</span> <span class="nx">dx</span> <span class="o">=</span> <span class="nx">objs</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">x</span> <span class="o">-</span> <span class="nx">objs</span><span class="p">[</span><span class="nx">j</span><span class="p">].</span><span class="nx">x</span><span class="p">;</span>
            <span class="kd">const</span> <span class="nx">dy</span> <span class="o">=</span> <span class="nx">objs</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">y</span> <span class="o">-</span> <span class="nx">objs</span><span class="p">[</span><span class="nx">j</span><span class="p">].</span><span class="nx">y</span><span class="p">;</span>
            <span class="kd">const</span> <span class="nx">rr</span> <span class="o">=</span> <span class="nx">objs</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">r</span> <span class="o">+</span> <span class="nx">objs</span><span class="p">[</span><span class="nx">j</span><span class="p">].</span><span class="nx">r</span><span class="p">;</span>
            <span class="k">if </span><span class="p">(</span><span class="nx">dx</span><span class="o">*</span><span class="nx">dx</span> <span class="o">+</span> <span class="nx">dy</span><span class="o">*</span><span class="nx">dy</span> <span class="o">&lt;=</span> <span class="nx">rr</span><span class="o">*</span><span class="nx">rr</span><span class="p">)</span> <span class="nx">outPairs</span><span class="p">.</span><span class="nf">push</span><span class="p">([</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span><span class="p">]);</span>
          <span class="p">}</span>
        <span class="p">}</span>
      <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="when-not-to-use-it">When Not To Use It</h3> <ul> <li>Extremely non‑uniform sizes or densities dominate runtime: prefer BVH or hybrid.</li> <li>Highly coherent 1D motion (e.g., stacks, axis‑aligned sweeps): SAP can be faster.</li> <li>Very small n (&lt;50): the constant factors of hashing may outweigh benefits; naïve is fine.</li> </ul> <h3 id="takeaways">Takeaways</h3> <ul> <li>Pick a cell size that matches your object scale, watch per‑cell occupancy, and use a clear dedup rule.</li> <li>Measure candidate pairs and FPS as you tune; grids can deliver near‑linear scaling for typical game scenes.</li> </ul> </article> </div> </div> <footer class="fixed-bottom"> <div class="container mt-0"> © Copyright 2025 Saeed Ghorbani. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="noopener noreferrer">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" target="_blank" rel="noopener noreferrer">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="noopener noreferrer">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="noopener noreferrer">Unsplash</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script async src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.11.2/dist/umd/popper.min.js" integrity="sha256-l/1pMF/+J4TThfgARS6KwWrk/egwuVvhRzfLAMQ6Ds4=" crossorigin="anonymous"></script> <script async src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.min.js" integrity="sha256-SyTu6CwrfOhaznYZPoolVw2rxoY7lKYKQvqbtqN93HI=" crossorigin="anonymous"></script> <script async src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="/assets/js/common.js"></script> <script defer src="/assets/js/custom_effects.js"></script> <script type="text/javascript">window.MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]],processEscapes:!0,processEnvironments:!0,tags:"ams"},options:{ignoreHtmlClass:"tex2jax_ignore",processHtmlClass:"tex2jax_process"}};</script> <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> </body> </html>