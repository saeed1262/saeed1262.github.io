<!DOCTYPE html> <html lang="en"> <head> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>BVH Collision Detection & Correction | Saeed Ghorbani</title> <meta name="author" content="Saeed Ghorbani"/> <meta name="description" content="A practical deep‑dive into the Bounding Volume Hierarchy (BVH) system powering fast overlap detection and robust correction."/> <meta name="keywords" content="machine learning, computer vision, computer graphics, computer animation, human motion modeling, probabilistic models, deep learning, research scientist, Amazon Games, motion synthesis, pose estimation, gesture generation"/> <meta property="og:site_name" content="Saeed Ghorbani"/> <meta property="og:type" content="website"/> <meta property="og:title" content="Saeed Ghorbani | BVH Collision Detection & Correction"/> <meta property="og:url" content="https://saeed1262.github.io/blog/2025/layout-designer-bvh-collision/"/> <meta property="og:description" content="A practical deep‑dive into the Bounding Volume Hierarchy (BVH) system powering fast overlap detection and robust correction."/> <meta property="og:image" content="/assets/img/saeed.jpg"/> <meta property="og:locale" content="en"/> <meta name="twitter:card" content="summary"/> <meta name="twitter:title" content="BVH Collision Detection & Correction"/> <meta name="twitter:description" content="A practical deep‑dive into the Bounding Volume Hierarchy (BVH) system powering fast overlap detection and robust correction."/> <meta name="twitter:image" content="/assets/img/saeed.jpg"/> <meta name="twitter:site" content="@SaGhorbani"/> <meta name="twitter:creator" content="@SaGhorbani"/> <script type="application/ld+json">
      {
        "author":
        {
          "@type": "Person",
          "name": "Saeed  Ghorbani"
        },
        "url": "https://saeed1262.github.io/blog/2025/layout-designer-bvh-collision/",
        "@type": "WebSite",
        "description": "A practical deep‑dive into the Bounding Volume Hierarchy (BVH) system powering fast overlap detection and robust correction.",
        "headline": "BVH Collision Detection & Correction",
        "sameAs": ["https://scholar.google.com/citations?user=JFRY_g8AAAAJ&hl", "https://github.com/saeed1262", "https://www.linkedin.com/in/saeed-ghorbani-ba4872136", "https://twitter.com/SaGhorbani"],
        "name": "Saeed  Ghorbani",
        "@context": "https://schema.org"
      }
    </script> <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin> <link rel="preconnect" href="https://fonts.googleapis.com" crossorigin> <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin> <link rel="dns-prefetch" href="//www.google-analytics.com"> <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"> <meta name="theme-color" content="#6c63ff"> <meta name="apple-mobile-web-app-capable" content="yes"> <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"> <meta name="msapplication-TileColor" content="#6c63ff"> <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"/> <link rel="preload" href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&family=Roboto+Slab:wght@100;300;400;500;700&display=swap" as="style" onload="this.onload=null;this.rel='stylesheet'"> <noscript><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&family=Roboto+Slab:wght@100;300;400;500;700&display=swap"></noscript> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="none" id="highlight_theme_light"/> <link rel="shortcut icon" href="/assets/img/fav.png"/> <link rel="preload" href="/assets/css/main.css" as="style" onload="this.onload=null;this.rel='stylesheet'"> <noscript><link rel="stylesheet" href="/assets/css/main.css"></noscript> <link rel="canonical" href="https://saeed1262.github.io/blog/2025/layout-designer-bvh-collision/"> <meta name="robots" content="index, follow, max-image-preview:large, max-snippet:-1, max-video-preview:-1"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/native.css" media="none" id="highlight_theme_dark"/> <script src="/assets/js/theme.js"></script> <script src="/assets/js/dark_mode.js"></script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="https://saeed1262.github.io/">Saeed Ghorbani</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">About</a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">Blog<span class="sr-only">(current)</span></a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">Publications</a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">Projects</a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">CV</a> </li> <li class="nav-item dropdown "> <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">Submenus</a> <div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdown"> <a class="dropdown-item" href="/publications/">publications</a> <div class="dropdown-divider"></div> <a class="dropdown-item" href="/projects/">projects</a> </div> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fas fa-moon"></i> <i class="fas fa-sun"></i> </button> </li> </ul> </div> </div> </nav> </header> <div class="container mt-5"> <div class="post"> <header class="post-header"> <h1 class="post-title">BVH Collision Detection &amp; Correction</h1> <p class="post-meta">September 5, 2025</p> <p class="post-tags"> <a href="/blog/2025"> <i class="fas fa-calendar fa-sm"></i> 2025 </a>   ·   <a href="/blog/tag/layout"> <i class="fas fa-hashtag fa-sm"></i> layout</a>   <a href="/blog/tag/algorithms"> <i class="fas fa-hashtag fa-sm"></i> algorithms</a>   <a href="/blog/tag/collision-detection"> <i class="fas fa-hashtag fa-sm"></i> collision-detection</a>   <a href="/blog/tag/BVH"> <i class="fas fa-hashtag fa-sm"></i> BVH</a>   <a href="/blog/tag/performance"> <i class="fas fa-hashtag fa-sm"></i> performance</a>     ·   <a href="/blog/category/blog"> <i class="fas fa-tag fa-sm"></i> blog</a>   </p> </header> <article class="post-content"> <p>Modern layout tools nee d to keep hundreds of items responsive without letting them overlap. In one of my projects, collision detection and correction are handled by a dynamic Bounding Volume Hierarchy (BVH) built over axis‑aligned bounding boxes (AABBs). This post explains how the BVH is constructed, updated, queried for overlaps, and how overlaps are corrected reliably and fast.</p> <h2 id="why-bvh-and-not-a-grid">Why BVH (and not a grid)?</h2> <ul> <li>Uniform grids shine with similarly sized objects. Layouts often have mixed sizes and clustered elements, where grids either over‑bucket or under‑bucket.</li> <li>BVH adapts to spatial distribution: nearby items share tight parent AABBs; far items barely interact during traversal.</li> <li>Dynamic refitting makes per‑frame updates cheap: when an item moves, only O(log n) parent AABBs update.</li> </ul> <h2 id="objects-and-bounds">Objects and Bounds</h2> <ul> <li>Item shape: treated as rectangles aligned to the canvas axes (AABBs). Rotations, if present visually, use their axis‑aligned bounding box for broad‑phase.</li> <li>Node: either a leaf (stores one item index) or an internal node with two children and an AABB enclosing them.</li> </ul> <div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Pseudocode/TypeScript‑ish for clarity</span>
<span class="kd">type</span> <span class="nx">AABB</span> <span class="o">=</span> <span class="p">{</span> <span class="na">minX</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span> <span class="nl">minY</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span> <span class="nl">maxX</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span> <span class="nl">maxY</span><span class="p">:</span> <span class="kr">number</span> <span class="p">};</span>

<span class="kd">type</span> <span class="nx">Node</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">aabb</span><span class="p">:</span> <span class="nx">AABB</span><span class="p">;</span>
  <span class="nl">left</span><span class="p">?:</span> <span class="kr">number</span><span class="p">;</span>  <span class="c1">// index into nodes array</span>
  <span class="nl">right</span><span class="p">?:</span> <span class="kr">number</span><span class="p">;</span> <span class="c1">// index into nodes array</span>
  <span class="nl">parent</span><span class="p">?:</span> <span class="kr">number</span><span class="p">;</span>
  <span class="nl">item</span><span class="p">?:</span> <span class="kr">number</span><span class="p">;</span>  <span class="c1">// leaf: index into items array</span>
  <span class="nl">height</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span> <span class="c1">// leaf = 0, internal = 1 + max(children)</span>
<span class="p">};</span>
</code></pre></div></div> <h2 id="building-the-bvh">Building the BVH</h2> <p>For static scenes, a top‑down build using a surface‑area heuristic (SAH) is ideal. LD V2 prioritizes dynamic interaction, so it uses a fast incremental insertion with periodic rebuilds:</p> <ul> <li>Initial build: sort items along the longer world axis, recursively split by median; compute AABBs bottom‑up.</li> <li>Incremental insert: new item picks a leaf that minimizes the growth in parent surface area; split leaf into a new internal node with two children.</li> <li>Refit: when an item moves, update its leaf AABB, then recompute ancestors’ AABBs up to the root.</li> <li>Rebalance: occasionally rotate local subtrees (AVL‑like) or trigger a full rebuild if the tree gets too tall (e.g., <code class="language-plaintext highlighter-rouge">height &gt; 2 * log2(n) + c</code>).</li> </ul> <div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">merge</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="nx">AABB</span><span class="p">,</span> <span class="nx">b</span><span class="p">:</span> <span class="nx">AABB</span><span class="p">):</span> <span class="nx">AABB</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">{</span>
    <span class="na">minX</span><span class="p">:</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">min</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">minX</span><span class="p">,</span> <span class="nx">b</span><span class="p">.</span><span class="nx">minX</span><span class="p">),</span> <span class="na">minY</span><span class="p">:</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">min</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">minY</span><span class="p">,</span> <span class="nx">b</span><span class="p">.</span><span class="nx">minY</span><span class="p">),</span>
    <span class="na">maxX</span><span class="p">:</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">max</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">maxX</span><span class="p">,</span> <span class="nx">b</span><span class="p">.</span><span class="nx">maxX</span><span class="p">),</span> <span class="na">maxY</span><span class="p">:</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">max</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">maxY</span><span class="p">,</span> <span class="nx">b</span><span class="p">.</span><span class="nx">maxY</span><span class="p">)</span>
  <span class="p">};</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nf">perimeter</span><span class="p">(</span><span class="nx">b</span><span class="p">:</span> <span class="nx">AABB</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">((</span><span class="nx">b</span><span class="p">.</span><span class="nx">maxX</span> <span class="o">-</span> <span class="nx">b</span><span class="p">.</span><span class="nx">minX</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">maxY</span> <span class="o">-</span> <span class="nx">b</span><span class="p">.</span><span class="nx">minY</span><span class="p">));</span> <span class="p">}</span>

<span class="c1">// Greedy insertion: choose the subtree that minimally increases perimeter</span>
<span class="kd">function</span> <span class="nf">chooseInsertion</span><span class="p">(</span><span class="nx">node</span><span class="p">:</span> <span class="kr">number</span><span class="p">,</span> <span class="nx">box</span><span class="p">:</span> <span class="nx">AABB</span><span class="p">):</span> <span class="kr">number</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">n</span> <span class="o">=</span> <span class="nx">node</span><span class="p">;</span>
  <span class="k">while </span><span class="p">(</span><span class="o">!</span><span class="nx">nodes</span><span class="p">[</span><span class="nx">n</span><span class="p">].</span><span class="nx">item</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">L</span> <span class="o">=</span> <span class="nx">nodes</span><span class="p">[</span><span class="nx">nodes</span><span class="p">[</span><span class="nx">n</span><span class="p">].</span><span class="nx">left</span><span class="o">!</span><span class="p">],</span> <span class="nx">R</span> <span class="o">=</span> <span class="nx">nodes</span><span class="p">[</span><span class="nx">nodes</span><span class="p">[</span><span class="nx">n</span><span class="p">].</span><span class="nx">right</span><span class="o">!</span><span class="p">];</span>
    <span class="kd">const</span> <span class="nx">costL</span> <span class="o">=</span> <span class="nf">perimeter</span><span class="p">(</span><span class="nf">merge</span><span class="p">(</span><span class="nx">L</span><span class="p">.</span><span class="nx">aabb</span><span class="p">,</span> <span class="nx">box</span><span class="p">))</span> <span class="o">-</span> <span class="nf">perimeter</span><span class="p">(</span><span class="nx">L</span><span class="p">.</span><span class="nx">aabb</span><span class="p">);</span>
    <span class="kd">const</span> <span class="nx">costR</span> <span class="o">=</span> <span class="nf">perimeter</span><span class="p">(</span><span class="nf">merge</span><span class="p">(</span><span class="nx">R</span><span class="p">.</span><span class="nx">aabb</span><span class="p">,</span> <span class="nx">box</span><span class="p">))</span> <span class="o">-</span> <span class="nf">perimeter</span><span class="p">(</span><span class="nx">R</span><span class="p">.</span><span class="nx">aabb</span><span class="p">);</span>
    <span class="nx">n</span> <span class="o">=</span> <span class="nx">costL</span> <span class="o">&lt;=</span> <span class="nx">costR</span> <span class="p">?</span> <span class="nx">nodes</span><span class="p">[</span><span class="nx">n</span><span class="p">].</span><span class="nx">left</span><span class="o">!</span> <span class="p">:</span> <span class="nx">nodes</span><span class="p">[</span><span class="nx">n</span><span class="p">].</span><span class="nx">right</span><span class="o">!</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">n</span><span class="p">;</span> <span class="c1">// leaf index</span>
<span class="p">}</span>
</code></pre></div></div> <h2 id="broadphase-overlap-query">Broad‑Phase Overlap Query</h2> <p>Traversal uses a stack (or small array) and prunes subtrees whose AABBs don’t intersect the query box. Two common queries:</p> <p>1) All pairs (global): enumerate every overlapping pair once. 2) Single item: find overlaps against one moving item to resolve on the fly.</p> <div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">aabbOverlap</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="nx">AABB</span><span class="p">,</span> <span class="nx">b</span><span class="p">:</span> <span class="nx">AABB</span><span class="p">):</span> <span class="nx">boolean</span> <span class="p">{</span>
  <span class="k">return</span> <span class="o">!</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">maxX</span> <span class="o">&lt;=</span> <span class="nx">b</span><span class="p">.</span><span class="nx">minX</span> <span class="o">||</span> <span class="nx">b</span><span class="p">.</span><span class="nx">maxX</span> <span class="o">&lt;=</span> <span class="nx">a</span><span class="p">.</span><span class="nx">minX</span> <span class="o">||</span>
           <span class="nx">a</span><span class="p">.</span><span class="nx">maxY</span> <span class="o">&lt;=</span> <span class="nx">b</span><span class="p">.</span><span class="nx">minY</span> <span class="o">||</span> <span class="nx">b</span><span class="p">.</span><span class="nx">maxY</span> <span class="o">&lt;=</span> <span class="nx">a</span><span class="p">.</span><span class="nx">minY</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// 1) Global pairs via self‑overlap traversal</span>
<span class="kd">function</span> <span class="nf">collectPairs</span><span class="p">(</span><span class="nx">root</span><span class="p">:</span> <span class="kr">number</span><span class="p">):</span> <span class="p">[</span><span class="kr">number</span><span class="p">,</span> <span class="kr">number</span><span class="p">][]</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">out</span><span class="p">:</span> <span class="p">[</span><span class="kr">number</span><span class="p">,</span> <span class="kr">number</span><span class="p">][]</span> <span class="o">=</span> <span class="p">[];</span>
  <span class="kd">const</span> <span class="nx">stack</span><span class="p">:</span> <span class="p">[</span><span class="kr">number</span><span class="p">,</span> <span class="kr">number</span><span class="p">][]</span> <span class="o">=</span> <span class="p">[[</span><span class="nx">root</span><span class="p">,</span> <span class="nx">root</span><span class="p">]];</span>
  <span class="k">while </span><span class="p">(</span><span class="nx">stack</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="p">[</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span><span class="p">]</span> <span class="o">=</span> <span class="nx">stack</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span><span class="o">!</span><span class="p">;</span>
    <span class="k">if </span><span class="p">(</span><span class="nx">i</span> <span class="o">===</span> <span class="nx">j</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">const</span> <span class="nx">n</span> <span class="o">=</span> <span class="nx">nodes</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
      <span class="k">if </span><span class="p">(</span><span class="o">!</span><span class="nx">n</span><span class="p">.</span><span class="nx">item</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">stack</span><span class="p">.</span><span class="nf">push</span><span class="p">([</span><span class="nx">n</span><span class="p">.</span><span class="nx">left</span><span class="o">!</span><span class="p">,</span> <span class="nx">n</span><span class="p">.</span><span class="nx">left</span><span class="o">!</span><span class="p">]);</span>
        <span class="nx">stack</span><span class="p">.</span><span class="nf">push</span><span class="p">([</span><span class="nx">n</span><span class="p">.</span><span class="nx">right</span><span class="o">!</span><span class="p">,</span> <span class="nx">n</span><span class="p">.</span><span class="nx">right</span><span class="o">!</span><span class="p">]);</span>
        <span class="nx">stack</span><span class="p">.</span><span class="nf">push</span><span class="p">([</span><span class="nx">n</span><span class="p">.</span><span class="nx">left</span><span class="o">!</span><span class="p">,</span> <span class="nx">n</span><span class="p">.</span><span class="nx">right</span><span class="o">!</span><span class="p">]);</span>
      <span class="p">}</span>
      <span class="k">continue</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kd">const</span> <span class="nx">A</span> <span class="o">=</span> <span class="nx">nodes</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">B</span> <span class="o">=</span> <span class="nx">nodes</span><span class="p">[</span><span class="nx">j</span><span class="p">];</span>
    <span class="k">if </span><span class="p">(</span><span class="o">!</span><span class="nf">aabbOverlap</span><span class="p">(</span><span class="nx">A</span><span class="p">.</span><span class="nx">aabb</span><span class="p">,</span> <span class="nx">B</span><span class="p">.</span><span class="nx">aabb</span><span class="p">))</span> <span class="k">continue</span><span class="p">;</span>
    <span class="k">if </span><span class="p">(</span><span class="nx">A</span><span class="p">.</span><span class="nx">item</span> <span class="o">&amp;&amp;</span> <span class="nx">B</span><span class="p">.</span><span class="nx">item</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// two leaves</span>
      <span class="nx">out</span><span class="p">.</span><span class="nf">push</span><span class="p">([</span><span class="nx">A</span><span class="p">.</span><span class="nx">item</span><span class="p">,</span> <span class="nx">B</span><span class="p">.</span><span class="nx">item</span><span class="p">]);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if </span><span class="p">(</span><span class="nx">A</span><span class="p">.</span><span class="nx">item</span> <span class="o">||</span> <span class="p">(</span><span class="o">!</span><span class="nx">B</span><span class="p">.</span><span class="nx">item</span> <span class="o">&amp;&amp;</span> <span class="nx">A</span><span class="p">.</span><span class="nx">aabbArea</span> <span class="o">&lt;=</span> <span class="nx">B</span><span class="p">.</span><span class="nx">aabbArea</span><span class="p">))</span> <span class="p">{</span>
      <span class="c1">// descend the non‑leaf or the larger box</span>
      <span class="nx">stack</span><span class="p">.</span><span class="nf">push</span><span class="p">([</span><span class="nx">A</span><span class="p">.</span><span class="nx">item</span> <span class="p">?</span> <span class="nx">i</span> <span class="p">:</span> <span class="nx">A</span><span class="p">.</span><span class="nx">left</span><span class="o">!</span><span class="p">,</span> <span class="nx">j</span><span class="p">]);</span>
      <span class="nx">stack</span><span class="p">.</span><span class="nf">push</span><span class="p">([</span><span class="nx">A</span><span class="p">.</span><span class="nx">item</span> <span class="p">?</span> <span class="nx">i</span> <span class="p">:</span> <span class="nx">A</span><span class="p">.</span><span class="nx">right</span><span class="o">!</span><span class="p">,</span> <span class="nx">j</span><span class="p">]);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="nx">stack</span><span class="p">.</span><span class="nf">push</span><span class="p">([</span><span class="nx">i</span><span class="p">,</span> <span class="nx">B</span><span class="p">.</span><span class="nx">left</span><span class="o">!</span><span class="p">]);</span>
      <span class="nx">stack</span><span class="p">.</span><span class="nf">push</span><span class="p">([</span><span class="nx">i</span><span class="p">,</span> <span class="nx">B</span><span class="p">.</span><span class="nx">right</span><span class="o">!</span><span class="p">]);</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">out</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 2) Single item query</span>
<span class="kd">function</span> <span class="nf">queryOverlaps</span><span class="p">(</span><span class="nx">root</span><span class="p">:</span> <span class="kr">number</span><span class="p">,</span> <span class="nx">box</span><span class="p">:</span> <span class="nx">AABB</span><span class="p">,</span> <span class="nx">hits</span><span class="p">:</span> <span class="kr">number</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[]):</span> <span class="kr">number</span><span class="p">[]</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">stack</span> <span class="o">=</span> <span class="p">[</span><span class="nx">root</span><span class="p">];</span>
  <span class="k">while </span><span class="p">(</span><span class="nx">stack</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">n</span> <span class="o">=</span> <span class="nx">nodes</span><span class="p">[</span><span class="nx">stack</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span><span class="o">!</span><span class="p">];</span>
    <span class="k">if </span><span class="p">(</span><span class="o">!</span><span class="nf">aabbOverlap</span><span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">aabb</span><span class="p">,</span> <span class="nx">box</span><span class="p">))</span> <span class="k">continue</span><span class="p">;</span>
    <span class="k">if </span><span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">item</span><span class="p">)</span> <span class="nx">hits</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">item</span><span class="p">);</span> <span class="k">else</span> <span class="p">{</span> <span class="nx">stack</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">left</span><span class="o">!</span><span class="p">,</span> <span class="nx">n</span><span class="p">.</span><span class="nx">right</span><span class="o">!</span><span class="p">);</span> <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">hits</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>In practice this runs near O(n log n) for well‑shaped trees, with very small constants thanks to cache‑friendly AABBs and branch pruning.</p> <h2 id="narrowphase-and-minimal-translation-vector-mtv">Narrow‑Phase and Minimal Translation Vector (MTV)</h2> <p>Once a candidate pair is produced, we confirm overlap with an AABB‑AABB test and compute the minimal translation vector to separate them. For axis‑aligned rectangles:</p> <div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">MTV</span> <span class="o">=</span> <span class="p">{</span> <span class="na">dx</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span> <span class="nl">dy</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span> <span class="nl">depth</span><span class="p">:</span> <span class="kr">number</span> <span class="p">};</span>

<span class="kd">function</span> <span class="nf">aabbMTV</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="nx">AABB</span><span class="p">,</span> <span class="nx">b</span><span class="p">:</span> <span class="nx">AABB</span><span class="p">):</span> <span class="nx">MTV</span> <span class="o">|</span> <span class="kc">null</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">overlapX</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">min</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">maxX</span> <span class="o">-</span> <span class="nx">b</span><span class="p">.</span><span class="nx">minX</span><span class="p">,</span> <span class="nx">b</span><span class="p">.</span><span class="nx">maxX</span> <span class="o">-</span> <span class="nx">a</span><span class="p">.</span><span class="nx">minX</span><span class="p">);</span>
  <span class="kd">const</span> <span class="nx">overlapY</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">min</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">maxY</span> <span class="o">-</span> <span class="nx">b</span><span class="p">.</span><span class="nx">minY</span><span class="p">,</span> <span class="nx">b</span><span class="p">.</span><span class="nx">maxY</span> <span class="o">-</span> <span class="nx">a</span><span class="p">.</span><span class="nx">minY</span><span class="p">);</span>
  <span class="k">if </span><span class="p">(</span><span class="nx">overlapX</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">overlapY</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
  <span class="c1">// move along the smaller penetration</span>
  <span class="k">if </span><span class="p">(</span><span class="nx">overlapX</span> <span class="o">&lt;</span> <span class="nx">overlapY</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">dir</span> <span class="o">=</span> <span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">minX</span> <span class="o">+</span> <span class="nx">a</span><span class="p">.</span><span class="nx">maxX</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">&lt;</span> <span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">minX</span> <span class="o">+</span> <span class="nx">b</span><span class="p">.</span><span class="nx">maxX</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="p">?</span> <span class="o">-</span><span class="mi">1</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">return</span> <span class="p">{</span> <span class="na">dx</span><span class="p">:</span> <span class="nx">dir</span> <span class="o">*</span> <span class="nx">overlapX</span><span class="p">,</span> <span class="na">dy</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="na">depth</span><span class="p">:</span> <span class="nx">overlapX</span> <span class="p">};</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">dir</span> <span class="o">=</span> <span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">minY</span> <span class="o">+</span> <span class="nx">a</span><span class="p">.</span><span class="nx">maxY</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">&lt;</span> <span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">minY</span> <span class="o">+</span> <span class="nx">b</span><span class="p">.</span><span class="nx">maxY</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="p">?</span> <span class="o">-</span><span class="mi">1</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">return</span> <span class="p">{</span> <span class="na">dx</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="na">dy</span><span class="p">:</span> <span class="nx">dir</span> <span class="o">*</span> <span class="nx">overlapY</span><span class="p">,</span> <span class="na">depth</span><span class="p">:</span> <span class="nx">overlapY</span> <span class="p">};</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <h2 id="correction-stable-separation-without-jitter">Correction: Stable Separation Without Jitter</h2> <p>LD V2 resolves overlaps immediately after detection using a symmetric, bias‑aware push:</p> <ul> <li>Compute MTV between <code class="language-plaintext highlighter-rouge">A</code> and <code class="language-plaintext highlighter-rouge">B</code>.</li> <li>Split correction based on “priority” (e.g., locked/anchored items get 0, draggable gets 1) or mass (both 0.5 by default).</li> <li>Apply positional slop and a softness factor to avoid oscillation.</li> <li>Refit BVH along the paths of the moved leaves.</li> </ul> <div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">resolvePair</span><span class="p">(</span><span class="nx">aIdx</span><span class="p">:</span> <span class="kr">number</span><span class="p">,</span> <span class="nx">bIdx</span><span class="p">:</span> <span class="kr">number</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">a</span> <span class="o">=</span> <span class="nx">items</span><span class="p">[</span><span class="nx">aIdx</span><span class="p">],</span> <span class="nx">b</span> <span class="o">=</span> <span class="nx">items</span><span class="p">[</span><span class="nx">bIdx</span><span class="p">];</span>
  <span class="kd">const</span> <span class="nx">mtv</span> <span class="o">=</span> <span class="nf">aabbMTV</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">aabb</span><span class="p">,</span> <span class="nx">b</span><span class="p">.</span><span class="nx">aabb</span><span class="p">);</span> <span class="k">if </span><span class="p">(</span><span class="o">!</span><span class="nx">mtv</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>

  <span class="c1">// Bias: anchored items don’t move; otherwise split 50/50</span>
  <span class="kd">const</span> <span class="nx">wa</span> <span class="o">=</span> <span class="nx">a</span><span class="p">.</span><span class="nx">anchored</span> <span class="p">?</span> <span class="mi">0</span> <span class="p">:</span> <span class="mf">0.5</span><span class="p">;</span>
  <span class="kd">const</span> <span class="nx">wb</span> <span class="o">=</span> <span class="nx">b</span><span class="p">.</span><span class="nx">anchored</span> <span class="p">?</span> <span class="mi">0</span> <span class="p">:</span> <span class="mf">0.5</span><span class="p">;</span>

  <span class="c1">// Positional slop to reduce jitter on grazing contacts</span>
  <span class="kd">const</span> <span class="nx">SLOP</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">;</span> <span class="c1">// pixels</span>
  <span class="kd">const</span> <span class="nx">DEPTH</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nx">mtv</span><span class="p">.</span><span class="nx">depth</span> <span class="o">-</span> <span class="nx">SLOP</span><span class="p">);</span>
  <span class="kd">const</span> <span class="nx">SOFTNESS</span> <span class="o">=</span> <span class="mf">0.9</span><span class="p">;</span> <span class="c1">// 1.0 = full separation, &lt;1 damps</span>

  <span class="kd">const</span> <span class="nx">dx</span> <span class="o">=</span> <span class="nx">SOFTNESS</span> <span class="o">*</span> <span class="p">(</span><span class="nx">mtv</span><span class="p">.</span><span class="nx">dx</span> <span class="o">===</span> <span class="mi">0</span> <span class="p">?</span> <span class="mi">0</span> <span class="p">:</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">sign</span><span class="p">(</span><span class="nx">mtv</span><span class="p">.</span><span class="nx">dx</span><span class="p">)</span> <span class="o">*</span> <span class="nx">DEPTH</span><span class="p">);</span>
  <span class="kd">const</span> <span class="nx">dy</span> <span class="o">=</span> <span class="nx">SOFTNESS</span> <span class="o">*</span> <span class="p">(</span><span class="nx">mtv</span><span class="p">.</span><span class="nx">dy</span> <span class="o">===</span> <span class="mi">0</span> <span class="p">?</span> <span class="mi">0</span> <span class="p">:</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">sign</span><span class="p">(</span><span class="nx">mtv</span><span class="p">.</span><span class="nx">dy</span><span class="p">)</span> <span class="o">*</span> <span class="nx">DEPTH</span><span class="p">);</span>

  <span class="nx">a</span><span class="p">.</span><span class="nf">translate</span><span class="p">(</span><span class="o">-</span><span class="nx">wa</span> <span class="o">*</span> <span class="nx">dx</span><span class="p">,</span> <span class="o">-</span><span class="nx">wa</span> <span class="o">*</span> <span class="nx">dy</span><span class="p">);</span>
  <span class="nx">b</span><span class="p">.</span><span class="nf">translate</span><span class="p">(</span> <span class="nx">wb</span> <span class="o">*</span> <span class="nx">dx</span><span class="p">,</span>  <span class="nx">wb</span> <span class="o">*</span> <span class="nx">dy</span><span class="p">);</span>

  <span class="c1">// Update their leaf AABBs and refit paths to root</span>
  <span class="nf">refitLeaf</span><span class="p">(</span><span class="nx">aIdx</span><span class="p">);</span>
  <span class="nf">refitLeaf</span><span class="p">(</span><span class="nx">bIdx</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>To avoid chain reactions, the solver iterates over current overlaps a small, bounded number of times (e.g., 2–4 iterations), which is usually sufficient for layouts. Detect‑correct‑refit repeats per iteration.</p> <h2 id="update-loop">Update Loop</h2> <p>Two common modes are used depending on interaction type:</p> <ul> <li>Dragging live: on each pointer move, query BVH against the dragged item’s AABB, resolve overlaps immediately, refit, repeat until no overlaps or max iterations reached.</li> <li>Batch settle: after bulk edits (e.g., paste 50 items), collect global pairs, then iterate resolve passes.</li> </ul> <div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">settle</span><span class="p">(</span><span class="nx">maxIters</span> <span class="o">=</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">it</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">it</span> <span class="o">&lt;</span> <span class="nx">maxIters</span><span class="p">;</span> <span class="nx">it</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">pairs</span> <span class="o">=</span> <span class="nf">collectPairs</span><span class="p">(</span><span class="nx">root</span><span class="p">);</span>
    <span class="k">if </span><span class="p">(</span><span class="nx">pairs</span><span class="p">.</span><span class="nx">length</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
    <span class="k">for </span><span class="p">(</span><span class="kd">const</span> <span class="p">[</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">]</span> <span class="k">of</span> <span class="nx">pairs</span><span class="p">)</span> <span class="nf">resolvePair</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <h2 id="dynamic-considerations">Dynamic Considerations</h2> <ul> <li>Fast motion: inflate the moving item’s query box by its frame delta (swept AABB) to avoid tunneling through small gaps.</li> <li>Large size differences: BVH handles this better than a uniform grid, but keep an eye on tree height; trigger local rotations or rebuilds when needed.</li> <li>Precision: use integer math for positions where possible; keep AABB computations consistent to avoid 1‑pixel “thrash.”</li> <li>Ordering: for deterministic results, sort candidate pairs (e.g., by minX, then minY) before resolving.</li> </ul> <h2 id="complexity--performance">Complexity &amp; Performance</h2> <ul> <li>Query: typical O(log n + k) where k is number of true overlaps; worst‑case can degenerate but is rare in practice with occasional rebalancing.</li> <li>Update: leaf refit is O(log n); incremental inserts and removals are similar.</li> <li>Correction: per‑pair O(1) math; bounded passes keep total under control in interactive scenarios.</li> </ul> <h2 id="pitfalls-and-fixes">Pitfalls and Fixes</h2> <ul> <li>Jitter on grazing contacts: add positional slop and soften the correction.</li> <li>Oscillation between neighbors: bias movement by “anchored” or “priority” flags; damp corrections slightly.</li> <li>Deep or skewed trees: rotate local subtrees, or rebuild on a height/imbalance threshold.</li> <li>Over‑correction near walls: clamp movement against fixed bounds before applying MTV.</li> </ul> <h2 id="minimal-example-all-together">Minimal Example (All Together)</h2> <div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Move an item, then keep it overlap‑free</span>
<span class="kd">function</span> <span class="nf">moveItem</span><span class="p">(</span><span class="nx">idx</span><span class="p">:</span> <span class="kr">number</span><span class="p">,</span> <span class="nx">dx</span><span class="p">:</span> <span class="kr">number</span><span class="p">,</span> <span class="nx">dy</span><span class="p">:</span> <span class="kr">number</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">item</span> <span class="o">=</span> <span class="nx">items</span><span class="p">[</span><span class="nx">idx</span><span class="p">];</span>
  <span class="nx">item</span><span class="p">.</span><span class="nf">translate</span><span class="p">(</span><span class="nx">dx</span><span class="p">,</span> <span class="nx">dy</span><span class="p">);</span>
  <span class="nf">refitLeaf</span><span class="p">(</span><span class="nx">idx</span><span class="p">);</span>

  <span class="c1">// Query neighbors against inflated box (swept AABB)</span>
  <span class="kd">const</span> <span class="nx">q</span> <span class="o">=</span> <span class="nf">inflate</span><span class="p">(</span><span class="nx">item</span><span class="p">.</span><span class="nx">aabb</span><span class="p">,</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">abs</span><span class="p">(</span><span class="nx">dx</span><span class="p">),</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">abs</span><span class="p">(</span><span class="nx">dy</span><span class="p">));</span>
  <span class="kd">const</span> <span class="nx">neighbors</span> <span class="o">=</span> <span class="nf">queryOverlaps</span><span class="p">(</span><span class="nx">root</span><span class="p">,</span> <span class="nx">q</span><span class="p">);</span>

  <span class="c1">// Resolve locally a few times</span>
  <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">it</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">it</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="nx">it</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="kr">any</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
    <span class="k">for </span><span class="p">(</span><span class="kd">const</span> <span class="nx">j</span> <span class="k">of</span> <span class="nx">neighbors</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if </span><span class="p">(</span><span class="nx">j</span> <span class="o">===</span> <span class="nx">idx</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
      <span class="kd">const</span> <span class="nx">before</span> <span class="o">=</span> <span class="nx">items</span><span class="p">[</span><span class="nx">idx</span><span class="p">].</span><span class="nx">aabb</span><span class="p">;</span>
      <span class="nf">resolvePair</span><span class="p">(</span><span class="nx">idx</span><span class="p">,</span> <span class="nx">j</span><span class="p">);</span>
      <span class="kr">any</span> <span class="o">=</span> <span class="kr">any</span> <span class="o">||</span> <span class="nf">aabbOverlap</span><span class="p">(</span><span class="nx">before</span><span class="p">,</span> <span class="nx">items</span><span class="p">[</span><span class="nx">j</span><span class="p">].</span><span class="nx">aabb</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if </span><span class="p">(</span><span class="o">!</span><span class="kr">any</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <h2 id="takeaways">Takeaways</h2> <ul> <li>BVH provides robust, distribution‑aware broad‑phase for heterogeneous layouts.</li> <li>Local refits keep updates cheap; occasional rebalancing maintains query speed.</li> <li>MTV‑based correction with slop/softness yields stable, overlap‑free arrangements without visible jitter.</li> </ul> <h2 id="interactive-bvh-demo">Interactive BVH Demo</h2> <p>Below is an interactive canvas showing the BVH broad‑phase along with collision detection and correction between draggable rectangles. Toggle BVH boxes, candidate pairs, and pause; drag rectangles to see local queries and on‑the‑fly resolution.</p> <div id="bvh-container"> <div id="bvh-controls"> <div class="control-group"> <label>Objects: <span class="value" id="bvhCountLabel">60</span></label> <input id="bvhCount" type="range" min="10" max="200" step="5" value="60"> </div> <div class="control-group"> <label>Animation Speed: <span class="value" id="bvhSpeedLabel">1.0x</span></label> <input id="bvhSpeed" type="range" min="0.1" max="3.0" step="0.1" value="1.0"> </div> <div class="control-group"> <label>Visuals</label> <div class="control-row"> <label class="checkbox"><input id="bvhShowTree" type="checkbox" checked> BVH Tree</label> <label class="checkbox"><input id="bvhShowPairs" type="checkbox"> Collision Pairs</label> </div> <div class="control-row"> <label class="checkbox"><input id="bvhShowTrails" type="checkbox" checked> Velocity Trails</label> <label class="checkbox"><input id="bvhShowQuery" type="checkbox"> Query Boxes</label> </div> <div class="control-row"> <label class="checkbox"><input id="bvhPause" type="checkbox"> Pause Animation</label> </div> </div> <div class="control-group"> <label>Actions</label> <div class="control-row"> <button id="bvhReset">Reset Scene</button> <button id="bvhShuffle">Shuffle + Settle</button> </div> </div> </div> <div id="bvh-viz-container"> <canvas id="bvh-viz" width="1280" height="720" aria-label="Enhanced BVH collision detection demo"></canvas> <div class="loading" id="bvhLoading">Preparing Enhanced BVH…</div> <div class="no-canvas" id="bvhNoCanvas" hidden="">Your browser does not support Canvas.</div> </div> <div id="bvh-hud"> <div class="hud-panel"> <h4>BVH Statistics</h4> <div class="hud-value"> <span class="label">Nodes</span><span class="value" id="bvhHudNodes">0</span> </div> <div class="hud-value"> <span class="label">Tree Height</span><span class="value" id="bvhHudHeight">0</span> </div> <div class="hud-value"> <span class="label">Collision Pairs</span><span class="value" id="bvhHudPairs">0</span> </div> <div class="hud-value"> <span class="label">Queries/Frame</span><span class="value" id="bvhHudQueries">0</span> </div> <div class="hud-value"> <span class="label">FPS</span><span class="value" id="bvhHudFps">0</span> </div> </div> <div class="hud-panel"> <h4>Interactive Features</h4> <ul class="notes"> <li> <strong>Drag objects</strong> — Real-time collision resolution with MTV</li> <li> <strong>3 object types</strong> — Normal (colorful), heavy (thick border), light (thin border)</li> <li> <strong>Visual effects</strong> — Collision sparks, velocity trails, query highlighting</li> <li> <strong>Dynamic BVH</strong> — Tree updates locally as objects move</li> <li> <strong>Performance</strong> — Efficient O(log n) queries with pruning</li> </ul> </div> </div> </div> <link rel="stylesheet" href="/assets/css/bvh-layout.css?v=1"> <script defer src="/assets/js/bvh-layout.js?v=1"></script> </article> </div> </div> <footer class="fixed-bottom"> <div class="container mt-0"> © Copyright 2025 Saeed Ghorbani. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="noopener noreferrer">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" target="_blank" rel="noopener noreferrer">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="noopener noreferrer">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="noopener noreferrer">Unsplash</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script async src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.11.2/dist/umd/popper.min.js" integrity="sha256-l/1pMF/+J4TThfgARS6KwWrk/egwuVvhRzfLAMQ6Ds4=" crossorigin="anonymous"></script> <script async src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.min.js" integrity="sha256-SyTu6CwrfOhaznYZPoolVw2rxoY7lKYKQvqbtqN93HI=" crossorigin="anonymous"></script> <script async src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="/assets/js/common.js"></script> <script defer src="/assets/js/custom_effects.js"></script> <script type="text/javascript">window.MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]],processEscapes:!0,processEnvironments:!0,tags:"ams"},options:{ignoreHtmlClass:"tex2jax_ignore",processHtmlClass:"tex2jax_process"}};</script> <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> </body> </html>