<!DOCTYPE html> <html lang="en"> <head> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>Interactive Inverse Kinematics: CCD, FABRIK, and Jacobian Transpose | Saeed Ghorbani</title> <meta name="author" content="Saeed Ghorbani"/> <meta name="description" content="Play with three classic IK solvers on a 2D arm: CCD, FABRIK, and Jacobian‑transpose. Drag the target, tweak links, and watch convergence."/> <meta name="keywords" content="machine learning, computer vision, computer graphics, computer animation, human motion modeling, probabilistic models, deep learning, research scientist, Amazon Games, motion synthesis, pose estimation, gesture generation"/> <meta property="og:site_name" content="Saeed Ghorbani"/> <meta property="og:type" content="website"/> <meta property="og:title" content="Saeed Ghorbani | Interactive Inverse Kinematics: CCD, FABRIK, and Jacobian Transpose"/> <meta property="og:url" content="https://saeed1262.github.io/blog/2025/inverse-kinematics-models/"/> <meta property="og:description" content="Play with three classic IK solvers on a 2D arm: CCD, FABRIK, and Jacobian‑transpose. Drag the target, tweak links, and watch convergence."/> <meta property="og:image" content="/assets/img/saeed.jpg"/> <meta property="og:locale" content="en"/> <meta name="twitter:card" content="summary"/> <meta name="twitter:title" content="Interactive Inverse Kinematics: CCD, FABRIK, and Jacobian Transpose"/> <meta name="twitter:description" content="Play with three classic IK solvers on a 2D arm: CCD, FABRIK, and Jacobian‑transpose. Drag the target, tweak links, and watch convergence."/> <meta name="twitter:image" content="/assets/img/saeed.jpg"/> <meta name="twitter:site" content="@SaGhorbani"/> <meta name="twitter:creator" content="@SaGhorbani"/> <script type="application/ld+json">
      {
        "author":
        {
          "@type": "Person",
          "name": "Saeed  Ghorbani"
        },
        "url": "https://saeed1262.github.io/blog/2025/inverse-kinematics-models/",
        "@type": "WebSite",
        "description": "Play with three classic IK solvers on a 2D arm: CCD, FABRIK, and Jacobian‑transpose. Drag the target, tweak links, and watch convergence.",
        "headline": "Interactive Inverse Kinematics: CCD, FABRIK, and Jacobian Transpose",
        "sameAs": ["https://scholar.google.com/citations?user=JFRY_g8AAAAJ&hl", "https://github.com/saeed1262", "https://www.linkedin.com/in/saeed-ghorbani-ba4872136", "https://twitter.com/SaGhorbani"],
        "name": "Saeed  Ghorbani",
        "@context": "https://schema.org"
      }
    </script> <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin> <link rel="preconnect" href="https://fonts.googleapis.com" crossorigin> <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin> <link rel="dns-prefetch" href="//www.google-analytics.com"> <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"> <meta name="theme-color" content="#6c63ff"> <meta name="apple-mobile-web-app-capable" content="yes"> <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"> <meta name="msapplication-TileColor" content="#6c63ff"> <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"/> <link rel="preload" href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&family=Roboto+Slab:wght@100;300;400;500;700&display=swap" as="style" onload="this.onload=null;this.rel='stylesheet'"> <noscript><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&family=Roboto+Slab:wght@100;300;400;500;700&display=swap"></noscript> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="none" id="highlight_theme_light"/> <link rel="shortcut icon" href="/assets/img/fav.png"/> <link rel="preload" href="/assets/css/main.css" as="style" onload="this.onload=null;this.rel='stylesheet'"> <noscript><link rel="stylesheet" href="/assets/css/main.css"></noscript> <link rel="canonical" href="https://saeed1262.github.io/blog/2025/inverse-kinematics-models/"> <meta name="robots" content="index, follow, max-image-preview:large, max-snippet:-1, max-video-preview:-1"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/native.css" media="none" id="highlight_theme_dark"/> <script src="/assets/js/theme.js"></script> <script src="/assets/js/dark_mode.js"></script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="https://saeed1262.github.io/">Saeed Ghorbani</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">About</a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">Blog<span class="sr-only">(current)</span></a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">Publications</a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">Projects</a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">CV</a> </li> <li class="nav-item dropdown "> <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">Submenus</a> <div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdown"> <a class="dropdown-item" href="/publications/">publications</a> <div class="dropdown-divider"></div> <a class="dropdown-item" href="/projects/">projects</a> </div> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fas fa-moon"></i> <i class="fas fa-sun"></i> </button> </li> </ul> </div> </div> </nav> </header> <div class="container mt-5"> <div class="post"> <header class="post-header"> <h1 class="post-title">Interactive Inverse Kinematics: CCD, FABRIK, and Jacobian Transpose</h1> <p class="post-meta">August 17, 2025</p> <p class="post-tags"> <a href="/blog/2025"> <i class="fas fa-calendar fa-sm"></i> 2025 </a>   ·   <a href="/blog/tag/robotics"> <i class="fas fa-hashtag fa-sm"></i> robotics</a>   <a href="/blog/tag/animation"> <i class="fas fa-hashtag fa-sm"></i> animation</a>   <a href="/blog/tag/kinematics"> <i class="fas fa-hashtag fa-sm"></i> kinematics</a>   <a href="/blog/tag/algorithms"> <i class="fas fa-hashtag fa-sm"></i> algorithms</a>   <a href="/blog/tag/interactive"> <i class="fas fa-hashtag fa-sm"></i> interactive</a>     ·   <a href="/blog/category/blog"> <i class="fas fa-tag fa-sm"></i> blog</a>   </p> </header> <article class="post-content"> <p>Inverse kinematics (IK) asks: given a desired end‑effector position, what joint angles produce it? Below you can compare three widely used IK solvers side‑by‑side on a planar arm. Drag the target, switch algorithms, and tune parameters to feel their behavior.</p> <div id="ik-container"> <div id="ik-controls"> <div class="control-panel"> <h5>Algorithm Selection</h5> <div class="control-group"> <div class="control-row"> <select id="ikAlgo"> <option value="ccd">CCD (Cyclic Coordinate Descent)</option> <option value="fabrik">FABRIK (Forward/Backward)</option> <option value="jt">Jacobian Transpose</option> <option value="dls">DLS (Damped Least Squares)</option> </select> </div> </div> </div> <div class="control-panel"> <h5>Basic Parameters</h5> <div class="control-group"> <label>Links: <span class="value" id="linksLabel">4</span></label> <input id="links" type="range" min="2" max="12" step="1" value="4"> </div> <div class="control-group"> <label>Link Length: <span class="value" id="lenLabel">90</span> px</label> <input id="len" type="range" min="30" max="140" step="5" value="90"> </div> <div class="control-group"> <label>Iterations/Frame: <span class="value" id="itersLabel">8</span></label> <input id="iters" type="range" min="1" max="64" step="1" value="8"> </div> </div> <div class="control-panel"> <h5>Algorithm Settings</h5> <div class="control-group" id="jt-only"> <label>JT Step (γ): <span class="value" id="gammaLabel">0.3</span></label> <input id="gamma" type="range" min="0.02" max="1.0" step="0.02" value="0.3"> </div> <div class="control-group" id="dls-only"> <label>DLS λ: <span class="value" id="lambdaLabel">2.0</span></label> <input id="lambda" type="range" min="0.0" max="10.0" step="0.1" value="2.0"> </div> <div class="control-group"> <label>Damping: <span class="value" id="dampLabel">0.6</span></label> <input id="damp" type="range" min="0.05" max="1.0" step="0.05" value="0.6"> </div> </div> <div class="control-panel"> <h5>Joint Limits</h5> <div class="control-group"> <div class="control-row"> <label class="checkbox"><input id="limitsEnabled" type="checkbox"> Enable</label> <label>±<span class="value" id="limitDegLabel">160</span>°</label> </div> <input id="limitDeg" type="range" min="10" max="180" step="5" value="160"> <div class="control-row"> <label class="checkbox"><input id="showLimits" type="checkbox"> Show Limit Arcs</label> </div> </div> </div> <div class="control-panel"> <h5>Rest Pose</h5> <div class="control-group"> <label>Rest Pose Bias: <span class="value" id="restLabel">0.00</span></label> <input id="restBias" type="range" min="0.00" max="0.50" step="0.01" value="0.00"> <div class="control-row"> <button class="button" id="setRest">Set Rest = Current</button> <button class="button" id="resetRest">Reset Rest</button> </div> </div> </div> <div class="control-panel"> <h5>Moving Target</h5> <div class="control-group"> <div class="control-row"> <button class="button" id="moveNone">Stop</button> <button class="button" id="moveCircle">Circle</button> <button class="button" id="moveEight">Figure‑8</button> </div> <label>Speed: <span class="value" id="speed2Label">1.0</span>x</label> <input id="targetSpeed" type="range" min="0.2" max="3.0" step="0.1" value="1.0"> </div> </div> <div class="control-panel"> <h5>Visualization &amp; Utilities</h5> <div class="control-group"> <div class="control-row"> <label class="checkbox"><input id="pauseIK" type="checkbox"> Pause</label> <label class="checkbox"><input id="showGhost" type="checkbox" checked> Show Reach Circle</label> </div> <div class="control-row"> <label class="checkbox"><input id="showTrace" type="checkbox"> Trace End‑Effector</label> <label class="checkbox"><input id="showMetrics" type="checkbox" checked> Show Metrics</label> </div> <div class="control-row"> <button class="button" id="toggleHelp">Help</button> </div> </div> </div> </div> <div id="ik-viz-container" aria-label="Inverse kinematics playground"> <canvas id="ik-canvas" width="1400" height="900"></canvas> <div class="loading" id="ik-loading">Loading IK demo…</div> </div> <div id="ik-hud"> <div class="hud-panel"> <h4>Status</h4> <div class="hud-value"> <span class="label">Algorithm</span><span class="value" id="hudAlgo">CCD</span> </div> <div class="hud-value"> <span class="label">End‑Effector Error</span><span class="value" id="hudErr">0.0 px</span> </div> <div class="hud-value"> <span class="label">Iterations</span><span class="value" id="hudIters">0</span> </div> <div class="hud-value"> <span class="label">FPS</span><span class="value" id="hudFps">0</span> </div> </div> <div class="hud-panel"> <h4>Tips</h4> <ul class="notes"> <li>Drag anywhere to move the target; hold Shift to move the base.</li> <li>CCD: simple and robust; converges gradually joint‑by‑joint.</li> <li>FABRIK: geometric, fast convergence in many cases.</li> <li>Jacobian‑Transpose: gradient‑like; tune γ for stability.</li> </ul> </div> </div> </div> <style>.container{max-width:1200px;margin:0 auto}.post{max-width:1200px;margin:0 auto}.post-content{max-width:1200px;margin:0 auto}</style> <link rel="stylesheet" href="/assets/css/ik-playground.css?v=4"> <script defer src="/assets/js/ik-playground.js?v=4"></script> <div id="ik-help" hidden=""> <div class="ik-help-content"> <h3>IK Playground Help</h3> <p>Drag to move the target; hold Shift to drag the base. Use the controls to change solver, link count/length, iterations, damping, joint limits, and add a rest‑pose bias.</p> <p>Moving targets let you compare tracking behavior.</p> <ul> <li>Shortcuts: 1=CCD, 2=FABRIK, 3=JT, 4=DLS, p=pause, t=trace, g=reach, k=metrics, ?=help, c=circle, l=figure‑8, s=stop</li> </ul> <button class="button" id="closeHelp">Close</button> </div> <div class="ik-help-backdrop"></div> </div> <h2 id="why-i-built-this">Why I Built This</h2> <p>IK sits at a beautiful intersection of robotics, character animation, and human–computer interaction. I wanted a hands‑on way to feel how classic solvers behave under constraints, limits, and moving targets—so you can build intuition, not just read formulas. This playground lets you drag a target and immediately see solver trade‑offs in stability, speed, and path smoothness.</p> <h2 id="where-ik-shows-up">Where IK Shows Up</h2> <p>If you’ve ever dragged a character’s hand onto a doorknob in an animation tool, or watched a robot smoothly align a gripper with a bolt, you’ve seen IK at work. Games lean on it to plant feet on uneven ground; VR headsets use it to guess a whole body from a few tracked points; mocap artists use it to tame jitter and fill gaps. The point isn’t just “reaching a position” — it’s doing so while staying within joint limits, preferring comfortable poses, and moving in a way that looks intentional.</p> <h2 id="how-the-demo-works">How The Demo Works</h2> <p>Drag the orange crosshair and the arm tries to follow. Under the hood, forward kinematics turns the current joint angles into points in space; then, several times per frame, the chosen solver nudges those angles to shrink the gap to the target. After each nudge, we respect joint limits if you’ve enabled them, and we can gently bias the motion back toward a rest pose so things don’t collapse into awkward shapes. You can switch algorithms on the fly to feel how each one “thinks,” and turn on metrics to watch the error curve settle as the arm converges.</p> <h2 id="complexity--scaling">Complexity &amp; Scaling</h2> <p>Not all IK steps cost the same. CCD in this simple form touches one joint at a time and re‑does forward kinematics after each tweak, which makes a full sweep scale roughly like n² for n links. FABRIK runs two clean passes along the chain and lands at O(n) per iteration. Jacobian‑based methods also build O(n) updates in this 2D setup; the transpose variant takes a smart step in the gradient’s direction, while Damped Least Squares solves a tiny 2×2 system to stay stable near straightened‑out poses. In practice, you can raise Iterations/Frame until the error curve gets calm, then balance snappiness vs. smoothness with JT’s γ or DLS’s λ plus the global damping.</p> <h2 id="visual-intuition">Visual Intuition</h2> <p>The end‑effector wants to reach the target. CCD swings one joint at a time so the segment points more toward the target. FABRIK slides points along lines to keep segment lengths while pulling the end to the goal. Jacobian methods compute how small angle changes move the end point, then nudge all joints together.</p> <h2 id="three-ways-to-solve-it">Three Ways To Solve It</h2> <p>There isn’t one “right” way to do IK — there are families of approaches with different personalities. CCD feels like a careful hand guiding each joint in turn. FABRIK acts like a strand of beads that slides into shape. Jacobian methods think locally: “if I turn joints this much, the end will move that way.” Real rigs mix these ideas with limits, damping, and sometimes orientation goals; the core intuition carries through.</p> <h2 id="play-with-it">Play With It</h2> <p>Start simple: drag the target a short distance and watch how each solver approaches it. CCD will send a ripple down the chain, joint by joint, like a snake finding its way. FABRIK tends to straighten segments into clean lines and snaps into place in just a few passes. Jacobian‑Transpose moves everything together in smooth, coordinated nudges — turn the step down if it starts to overshoot.</p> <p>Make it harder. Hold Shift and move the green base to change what’s reachable, then try pulling the target beyond the reach circle to see how each solver hugs the boundary. Turn on joint limits and show limit arcs; you’ll notice how CCD inches along the constraints, FABRIK rebalances lengths gracefully, and Jacobian methods slow down near singular poses unless you give them a bit more damping or λ.</p> <p>Finally, give the system a rhythm. Put the target on a circle or figure‑8, enable trace, and compare how closely each solver tracks the path. You’ll feel the trade‑off: faster steps react quickly but can ring; heavier damping and DLS stay composed but lag a touch.</p> <h2 id="appendix-shareable-presets">Appendix: Shareable Presets</h2> <p>The demo reads settings from the URL, so you can share a preset. Example:</p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>?algo=dls&amp;n=6&amp;L=80&amp;it=16&amp;la=3&amp;d=0.7&amp;rg=1&amp;tr=1&amp;mv=eight&amp;sp=1.2
</code></pre></div></div> <p>Parameters:</p> <ul> <li> <table> <tbody> <tr> <td> <code class="language-plaintext highlighter-rouge">algo</code>: ccd</td> <td>fabrik</td> <td>jt</td> <td>dls</td> </tr> </tbody> </table> </li> <li> <code class="language-plaintext highlighter-rouge">n</code>: number of links</li> <li> <code class="language-plaintext highlighter-rouge">L</code>: link length (px)</li> <li> <code class="language-plaintext highlighter-rouge">it</code>: iterations per frame</li> <li> <code class="language-plaintext highlighter-rouge">g</code>: JT step gamma (γ)</li> <li> <code class="language-plaintext highlighter-rouge">la</code>: DLS lambda (λ)</li> <li> <code class="language-plaintext highlighter-rouge">d</code>: damping [0..1]</li> <li> <code class="language-plaintext highlighter-rouge">px</code>: pause (0 or 1)</li> <li> <code class="language-plaintext highlighter-rouge">rg</code>: show reach circle (0 or 1)</li> <li> <code class="language-plaintext highlighter-rouge">tr</code>: show trace (0 or 1)</li> <li> <code class="language-plaintext highlighter-rouge">lm</code>: enable joint limits (0 or 1)</li> <li> <code class="language-plaintext highlighter-rouge">ld</code>: joint limit degrees (±)</li> <li> <code class="language-plaintext highlighter-rouge">sl</code>: show limit arcs (0 or 1)</li> <li> <code class="language-plaintext highlighter-rouge">rb</code>: rest pose bias [0..0.5]</li> <li> <table> <tbody> <tr> <td> <code class="language-plaintext highlighter-rouge">mv</code>: target motion mode: none</td> <td>circle</td> <td>eight</td> </tr> </tbody> </table> </li> <li> <code class="language-plaintext highlighter-rouge">sp</code>: target speed multiplier</li> <li> <code class="language-plaintext highlighter-rouge">mx,my</code>: base position (px)</li> <li> <code class="language-plaintext highlighter-rouge">tx,ty</code>: target position (px)</li> </ul> <h2 id="what-it-feels-like">What It Feels Like</h2> <p>CCD progresses joint‑by‑joint from the end — you can literally watch the “wave” of corrections travel back to the base. FABRIK often finds a clean, nearly straight path in just a few sweeps. Jacobian‑Transpose updates everything at once; it’s wonderfully smooth when the step is tamed, and a little exuberant if you let γ run wild. Outside the reach circle, all methods settle on the boundary in the closest direction they can manage.</p> <h3 id="problem-setup-2d-planar-chain">Problem Setup (2D Planar Chain)</h3> <p>We’re solving for joint angles <code class="language-plaintext highlighter-rouge">θ = [θ1..θn]</code> so the end‑effector position <code class="language-plaintext highlighter-rouge">p(θ)</code> matches a target <code class="language-plaintext highlighter-rouge">t</code>. Each link has length <code class="language-plaintext highlighter-rouge">L</code> and we keep the base fixed, so forward kinematics is just a sum of rotations and offsets along the chain. All the solvers below chase the same objective — reduce the position error <code class="language-plaintext highlighter-rouge">e = t − p(θ)</code> — but they update <code class="language-plaintext highlighter-rouge">θ</code> in different ways.</p> <h3 id="ccd-cyclic-coordinate-descent">CCD (Cyclic Coordinate Descent)</h3> <p>CCD is the “one joint at a time” approach. Starting from the tip and walking back to the base, each joint turns just enough to make the end‑effector point more directly at the target. It’s dead simple and very forgiving — great when you just need something that works — but on long chains you’ll see a characteristic wiggle and a bit more time to settle.</p> <p>Geometrically, for joint i with position p_i, end‑effector e, and target t, define</p> \[\mathbf{u} = e - p_i,\quad \mathbf{v} = t - p_i.\] <p>The signed rotation that best aligns u to v in 2D is</p> \[\Delta\theta_i = \operatorname{atan2}(\,u_x v_y - u_y v_x,\; u_x v_x + u_y v_y\,)\] <p>and we apply a damped update</p> \[\theta_i \leftarrow \theta_i + \eta\,\Delta\theta_i, \quad 0&lt;\eta\le 1.\] <p>After changing θ_i we recompute forward kinematics so the next joint acts on the new end‑effector position. CCD naturally handles unreachable targets: the chain aligns toward t and settles at the boundary of the reach circle.</p> <p>Pseudo‑steps per sweep:</p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for i = n-1 down to 0:
  a1 = angle(j_i → end_effector)
  a2 = angle(j_i → target)
  θ_i += wrap_to_pi(a2 - a1) * damping
  forward_kinematics()
</code></pre></div></div> <h3 id="fabrik-forward-and-backward-reaching-ik">FABRIK (Forward And Backward Reaching IK)</h3> <p>FABRIK works directly in position space with two elegant passes. First it fixes the end at the target and drags joints backward along straight lines while keeping segment lengths. Then it pins the base and pushes forward the same way. The result is fast, stable convergence without building Jacobians — you get clean motion with very little fuss.</p> <table> <tbody> <tr> <td>Let joints be positions p_0, …, p_n with segment lengths L_i =</td> <td> </td> <td>p_{i+1}-p_i</td> <td> </td> <td>(kept constant).</td> </tr> </tbody> </table> <ul> <li>If the target t is unreachable, set every segment to point toward t:</li> </ul> \[p_{i+1} \leftarrow p_i + L_i\,\frac{t-p_i}{\lVert t-p_i\rVert}.\] <ul> <li>Otherwise, do two passes per iteration: <ul> <li> <p>Backward (anchor end at t): set p_n ← t, then for i = n−1…0</p> \[p_i \leftarrow p_{i+1} + L_{i}\,\frac{p_i - p_{i+1}}{\lVert p_i - p_{i+1}\rVert}.\] </li> <li> <p>Forward (anchor base at p_0^0): set p_0 ← p_0^0, then for i = 0…n−1</p> \[p_{i+1} \leftarrow p_{i} + L_{i}\,\frac{p_{i+1} - p_{i}}{\lVert p_{i+1} - p_{i}\rVert}.\] </li> </ul> </li> </ul> <p>Angles θ are then recovered from adjacent positions. Constraints like joint limits fit by clamping angles after each iteration.</p> <p>Pseudo‑steps per iteration:</p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// If unreachable: point segments toward target and stop.
end = target
for i = n-1..0:  j_i = j_{i+1} + L * normalize(j_i - j_{i+1})
base stays fixed
for i = 0..n-1:  j_{i+1} = j_i + L * normalize(j_{i+1} - j_i)
</code></pre></div></div> <h3 id="jacobian-transpose-jt">Jacobian Transpose (JT)</h3> <p>Jacobian‑Transpose thinks like a gradient step: if small changes in angles move the end by <code class="language-plaintext highlighter-rouge">Δp ≈ J Δθ</code>, then turning in the direction of <code class="language-plaintext highlighter-rouge">J^T (t − p)</code> should make the error shrink. Here it takes an adaptive step and clamps it by <code class="language-plaintext highlighter-rouge">γ</code> for stability. The payoff is coordinated, smooth updates and an easy path to richer goals (like mixing position and orientation) — as long as you keep the step size in check near singular poses.</p> <p>We minimize position error r = t − p(θ). Linearizing</p> \[\Delta\mathbf{p} \approx J(\theta)\,\Delta\boldsymbol{\theta}.\] <table> <tbody> <tr> <td>Gradient descent on E = 1/2</td> <td> </td> <td>r</td> <td> </td> <td>^2 gives</td> </tr> </tbody> </table> \[\Delta\boldsymbol{\theta} = -\alpha\,\nabla_{\theta}E = \alpha\,J^T r.\] <p>Choosing the step by projecting the desired motion r onto the predicted motion v = J J^T r yields</p> \[\alpha = \frac{r^\top v}{v^\top v + \varepsilon} = \frac{r^\top J J^T r}{\lVert J J^T r\rVert^2 + \varepsilon},\] <p>then clamp 0 ≤ α ≤ γ for stability (as done in the demo). In 2D, the Jacobian column for joint i is a perpendicular to the joint→end vector; see the dedicated section below.</p> <p>Update rule used here:</p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>u = J^T r          // per-joint update direction
v = J u            // predicted end-effector motion
α = clamp( (r·v) / (v·v + ε), 0, γ )
θ ← θ + α u * damping
</code></pre></div></div> <h3 id="jacobian-for-a-planar-chain-2d">Jacobian for a Planar Chain (2D)</h3> <ul> <li>For joint i at position <code class="language-plaintext highlighter-rouge">p_i = (x_i, y_i)</code> and the end‑effector at <code class="language-plaintext highlighter-rouge">e = (x_e, y_e)</code>, the Jacobian column with respect to <code class="language-plaintext highlighter-rouge">θ_i</code> is <code class="language-plaintext highlighter-rouge">[−(y_e − y_i), (x_e − x_i)]</code>.</li> <li>This geometric form (a perpendicular to the joint→end vector) is what the demo uses for both JT and DLS updates.</li> </ul> <h3 id="damped-least-squares-dls">Damped Least Squares (DLS)</h3> <p>DLS is the calm one. It takes a regularized least‑squares step <code class="language-plaintext highlighter-rouge">Δθ = J^T (J J^T + λ^2 I)^{-1} r</code>, which naturally tempers directions that would otherwise explode near singularities. Turn λ up for composure, down for responsiveness, and you’ll get graceful behavior even when the target or base won’t sit still.</p> <p>Formally, solve the Tikhonov‑regularized problem</p> \[\min_{\Delta\theta}\;\lVert J\,\Delta\theta - r\rVert^2 + \lambda^2\,\lVert \Delta\theta\rVert^2,\] <p>whose normal equations give</p> \[\Delta\theta = (J^T J + \lambda^2 I)^{-1} J^T r.\] <p>Using the matrix identity (Woodbury), this equals the dual form we implement efficiently in 2D task‑space:</p> \[\Delta\theta = J^T\,(J J^T + \lambda^2 I)^{-1} r.\] <p>As λ → 0 you recover least‑squares (fast but sensitive); as λ grows you get smaller, more conservative steps. Combine with a global damping factor to smooth motion frame‑to‑frame.</p> <p>Pseudo‑step (2D task):</p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>A = J J^T + λ^2 I    // 2×2 in this demo
y = A^{-1} r
Δθ = J^T y
θ ← θ + Δθ * damping
</code></pre></div></div> <p>Tuning: raise <code class="language-plaintext highlighter-rouge">λ</code> for stability (less aggressive updates), lower it for responsiveness. Combine with global <code class="language-plaintext highlighter-rouge">Damping</code> for smooth paths.</p> <h2 id="when-things-get-tricky">When Things Get Tricky</h2> <p>Outside the reach circle, all methods will align toward the target and rest on the boundary — that’s expected. Near straight‑line (singular) poses, gradient‑based updates can wobble unless you rein them in; that’s why the JT step is clamped by <code class="language-plaintext highlighter-rouge">γ</code>, and why DLS’s λ exists at all. If you see ringing, ease γ up or add damping; if things feel sluggish, give the solver a few more iterations per frame. Joint limits add realism but also resistance — clamp after each update and let the solvers negotiate their way along the arcs rather than fighting them.</p> <h2 id="which-solver-when">Which Solver When</h2> <p>Use CCD when you want a tiny, dependable hammer and don’t mind a little wiggle on long chains. Reach for FABRIK when you care about fast, stable convergence and clean paths — it’s a favorite for character rigs. Choose Jacobian methods when you want to combine objectives (position now, orientation later) and tune behavior; DLS, in particular, shines when you need robustness over raw snap.</p> <h2 id="beyond-this-demo">Beyond This Demo</h2> <p>There’s plenty more to explore: per‑joint limits and soft preferences, stronger regularization, end‑effector orientation, even obstacle avoidance by projecting joints away between passes. The math scales naturally to 3D, and the same ideas power everything from robotic arms to full‑body avatars.</p> <h3 id="references-and-further-reading">References and Further Reading</h3> <ul> <li>Aristidou &amp; Lasenby, “FABRIK: A fast, iterative solver for the Inverse Kinematics problem” (2011)</li> <li>Buss, “Introduction to Inverse Kinematics with Jacobian Methods” (2004)</li> <li>Tolani, Goswami, &amp; Badler, “Real-Time Inverse Kinematics Techniques for Anthropomorphic Limbs” (2000)</li> <li>Wampler, “Manipulator Inverse Kinematic Solutions Based on Vector Formulations and Damped Least‑Squares Methods” (1986)</li> <li>Nakamura &amp; Hanafusa, “Inverse kinematics solutions with singularity avoidance for robot manipulator control” (1986)</li> <li>Maciejewski &amp; Klein, “Obstacle avoidance for kinematically redundant manipulators in dynamically varying environments” (1985)</li> </ul> </article> </div> </div> <footer class="fixed-bottom"> <div class="container mt-0"> © Copyright 2025 Saeed Ghorbani. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="noopener noreferrer">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" target="_blank" rel="noopener noreferrer">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="noopener noreferrer">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="noopener noreferrer">Unsplash</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script async src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.11.2/dist/umd/popper.min.js" integrity="sha256-l/1pMF/+J4TThfgARS6KwWrk/egwuVvhRzfLAMQ6Ds4=" crossorigin="anonymous"></script> <script async src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.min.js" integrity="sha256-SyTu6CwrfOhaznYZPoolVw2rxoY7lKYKQvqbtqN93HI=" crossorigin="anonymous"></script> <script async src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="/assets/js/common.js"></script> <script defer src="/assets/js/custom_effects.js"></script> <script type="text/javascript">window.MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]],processEscapes:!0,processEnvironments:!0,tags:"ams"},options:{ignoreHtmlClass:"tex2jax_ignore",processHtmlClass:"tex2jax_process"}};</script> <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> </body> </html>