<!DOCTYPE html> <html lang="en"> <head> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>Quaternions, SO(3), and Gimbal Lock — An Interactive Intuition | Saeed Ghorbani</title> <meta name="author" content="Saeed Ghorbani"/> <meta name="description" content="Why Euler angles hit singularities, how quaternions live on S³, and why SLERP makes interpolation behave. Zero-build, in-browser demo."/> <meta name="keywords" content="machine learning, computer vision, computer graphics, computer animation, human motion modeling, probabilistic models, deep learning, research scientist, Amazon Games, motion synthesis, pose estimation, gesture generation"/> <meta property="og:site_name" content="Saeed Ghorbani"/> <meta property="og:type" content="website"/> <meta property="og:title" content="Saeed Ghorbani | Quaternions, SO(3), and Gimbal Lock — An Interactive Intuition"/> <meta property="og:url" content="https://saeed1262.github.io/blog/2024/quaternion/"/> <meta property="og:description" content="Why Euler angles hit singularities, how quaternions live on S³, and why SLERP makes interpolation behave. Zero-build, in-browser demo."/> <meta property="og:image" content="/assets/img/saeed.jpg"/> <meta property="og:locale" content="en"/> <meta name="twitter:card" content="summary"/> <meta name="twitter:title" content="Quaternions, SO(3), and Gimbal Lock — An Interactive Intuition"/> <meta name="twitter:description" content="Why Euler angles hit singularities, how quaternions live on S³, and why SLERP makes interpolation behave. Zero-build, in-browser demo."/> <meta name="twitter:image" content="/assets/img/saeed.jpg"/> <meta name="twitter:site" content="@SaGhorbani"/> <meta name="twitter:creator" content="@SaGhorbani"/> <script type="application/ld+json">
      {
        "author":
        {
          "@type": "Person",
          "name": "Saeed  Ghorbani"
        },
        "url": "https://saeed1262.github.io/blog/2024/quaternion/",
        "@type": "WebSite",
        "description": "Why Euler angles hit singularities, how quaternions live on S³, and why SLERP makes interpolation behave. Zero-build, in-browser demo.",
        "headline": "Quaternions, SO(3), and Gimbal Lock — An Interactive Intuition",
        "sameAs": ["https://scholar.google.com/citations?user=JFRY_g8AAAAJ&hl", "https://github.com/saeed1262", "https://www.linkedin.com/in/saeed-ghorbani-ba4872136", "https://twitter.com/SaGhorbani"],
        "name": "Saeed  Ghorbani",
        "@context": "https://schema.org"
      }
    </script> <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin> <link rel="preconnect" href="https://fonts.googleapis.com" crossorigin> <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin> <link rel="dns-prefetch" href="//www.google-analytics.com"> <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"> <meta name="theme-color" content="#6c63ff"> <meta name="apple-mobile-web-app-capable" content="yes"> <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"> <meta name="msapplication-TileColor" content="#6c63ff"> <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"/> <link rel="preload" href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&family=Roboto+Slab:wght@100;300;400;500;700&display=swap" as="style" onload="this.onload=null;this.rel='stylesheet'"> <noscript><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&family=Roboto+Slab:wght@100;300;400;500;700&display=swap"></noscript> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="none" id="highlight_theme_light"/> <link rel="shortcut icon" href="/assets/img/fav.png"/> <link rel="preload" href="/assets/css/main.css" as="style" onload="this.onload=null;this.rel='stylesheet'"> <noscript><link rel="stylesheet" href="/assets/css/main.css"></noscript> <link rel="canonical" href="https://saeed1262.github.io/blog/2024/quaternion/"> <meta name="robots" content="index, follow, max-image-preview:large, max-snippet:-1, max-video-preview:-1"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/native.css" media="none" id="highlight_theme_dark"/> <script src="/assets/js/theme.js"></script> <script src="/assets/js/dark_mode.js"></script> </head> <body class="fixed-top-nav "> <body> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="https://saeed1262.github.io/">Saeed Ghorbani</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">About</a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">Blog<span class="sr-only">(current)</span></a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">Publications</a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">Projects</a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">CV</a> </li> <li class="nav-item dropdown "> <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">Submenus</a> <div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdown"> <a class="dropdown-item" href="/publications/">publications</a> <div class="dropdown-divider"></div> <a class="dropdown-item" href="/projects/">projects</a> </div> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fas fa-moon"></i> <i class="fas fa-sun"></i> </button> </li> </ul> </div> </div> </nav> </header> <div class="container mt-5"> <div class="post"> <header class="post-header"> <h1 class="post-title">Quaternions, SO(3), and Gimbal Lock — An Interactive Intuition</h1> <p class="post-meta">October 24, 2024</p> <p class="post-tags"> <a href="/blog/2024"> <i class="fas fa-calendar fa-sm"></i> 2024 </a>   ·   <a href="/blog/tag/physics"> <i class="fas fa-hashtag fa-sm"></i> physics</a>   <a href="/blog/tag/graphics"> <i class="fas fa-hashtag fa-sm"></i> graphics</a>   <a href="/blog/tag/games"> <i class="fas fa-hashtag fa-sm"></i> games</a>   <a href="/blog/tag/rotations"> <i class="fas fa-hashtag fa-sm"></i> rotations</a>   <a href="/blog/tag/quaternions"> <i class="fas fa-hashtag fa-sm"></i> quaternions</a>   <a href="/blog/tag/so3"> <i class="fas fa-hashtag fa-sm"></i> so3</a>   </p> </header> <article class="post-content"> <h1 id="quaternion-based-3d-rotation-from-theory-to-practice">Quaternion-Based 3D Rotation: From Theory to Practice</h1> <p><strong>Prerequisites</strong>: Basic linear algebra (vectors, matrices), trigonometry, and familiarity with 3D coordinate systems.</p> <p>3D rotations are everywhere in computer graphics, robotics, and game development. Whether you’re rotating a character in Unity, controlling a drone, or animating a 3D model, you need a robust way to represent and manipulate rotations. This post explores why the industry has largely moved from Euler angles to quaternions, combining mathematical rigor with practical examples.</p> <h2 id="the-problem-why-rotations-are-tricky">The Problem: Why Rotations Are Tricky</h2> <p>Representing 3D rotations might seem straightforward - just use three angles for yaw, pitch, and roll, right? Unfortunately, this intuitive approach runs into serious mathematical and practical problems that have plagued developers for decades.</p> <h3 id="a-quick-refresher-what-are-rotations">A Quick Refresher: What Are Rotations?</h3> <p>In 3D space, rotations form what mathematicians call the <strong>Special Orthogonal Group SO(3)</strong>. Don’t let the fancy name intimidate you - this simply means:</p> <ul> <li> <strong>Special</strong>: Determinant = 1 (proper rotations, no reflections)</li> <li> <strong>Orthogonal</strong>: Preserve distances and angles</li> <li> <strong>Group</strong>: You can combine rotations, and the result is still a rotation</li> </ul> <p>Think of SO(3) as the set of all possible 3D orientations an object can have. A cube can be rotated in countless ways, but it’s still the same cube - just oriented differently.</p> <h2 id="the-euler-angle-problem-gimbal-lock-in-action">The Euler Angle Problem: Gimbal Lock in Action</h2> <p>Before diving into quaternions, let’s understand why Euler angles cause problems. Euler angles represent rotations using three sequential rotations around different axes - typically yaw (Z), pitch (Y), and roll (X).</p> <h3 id="real-world-example-aircraft-control">Real-World Example: Aircraft Control</h3> <p>Imagine you’re programming a flight simulator or drone controller:</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Typical Euler angle representation</span>
<span class="kd">class</span> <span class="nc">EulerRotation</span> <span class="p">{</span>
    <span class="nf">constructor</span><span class="p">(</span><span class="nx">yaw</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">pitch</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">roll</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">yaw</span> <span class="o">=</span> <span class="nx">yaw</span><span class="p">;</span>    <span class="c1">// Rotation around Z-axis (heading)</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">pitch</span> <span class="o">=</span> <span class="nx">pitch</span><span class="p">;</span> <span class="c1">// Rotation around Y-axis (nose up/down)</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">roll</span> <span class="o">=</span> <span class="nx">roll</span><span class="p">;</span>   <span class="c1">// Rotation around X-axis (bank left/right)</span>
    <span class="p">}</span>
    
    <span class="c1">// This seems simple... but problems lurk beneath</span>
    <span class="nf">toRotationMatrix</span><span class="p">()</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">cy</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">cos</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">yaw</span><span class="p">),</span> <span class="nx">sy</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">sin</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">yaw</span><span class="p">);</span>
        <span class="kd">const</span> <span class="nx">cp</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">cos</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">pitch</span><span class="p">),</span> <span class="nx">sp</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">sin</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">pitch</span><span class="p">);</span>
        <span class="kd">const</span> <span class="nx">cr</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">cos</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">roll</span><span class="p">),</span> <span class="nx">sr</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">sin</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">roll</span><span class="p">);</span>
        
        <span class="c1">// Combined rotation: R = R_z(yaw) * R_y(pitch) * R_x(roll)</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="p">[</span><span class="nx">cy</span><span class="o">*</span><span class="nx">cp</span><span class="p">,</span> <span class="nx">cy</span><span class="o">*</span><span class="nx">sp</span><span class="o">*</span><span class="nx">sr</span> <span class="o">-</span> <span class="nx">sy</span><span class="o">*</span><span class="nx">cr</span><span class="p">,</span> <span class="nx">cy</span><span class="o">*</span><span class="nx">sp</span><span class="o">*</span><span class="nx">cr</span> <span class="o">+</span> <span class="nx">sy</span><span class="o">*</span><span class="nx">sr</span><span class="p">],</span>
            <span class="p">[</span><span class="nx">sy</span><span class="o">*</span><span class="nx">cp</span><span class="p">,</span> <span class="nx">sy</span><span class="o">*</span><span class="nx">sp</span><span class="o">*</span><span class="nx">sr</span> <span class="o">+</span> <span class="nx">cy</span><span class="o">*</span><span class="nx">cr</span><span class="p">,</span> <span class="nx">sy</span><span class="o">*</span><span class="nx">sp</span><span class="o">*</span><span class="nx">cr</span> <span class="o">-</span> <span class="nx">cy</span><span class="o">*</span><span class="nx">sr</span><span class="p">],</span>
            <span class="p">[</span><span class="o">-</span><span class="nx">sp</span><span class="p">,</span>   <span class="nx">cp</span><span class="o">*</span><span class="nx">sr</span><span class="p">,</span>            <span class="nx">cp</span><span class="o">*</span><span class="nx">cr</span>           <span class="p">]</span>
        <span class="p">];</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>This looks clean and intuitive. The problem emerges when the pitch approaches ±90°.</p> <h3 id="the-gimbal-lock-problem-explained">The Gimbal Lock Problem Explained</h3> <p><strong>Gimbal lock</strong> occurs when two rotation axes become parallel, effectively losing one degree of freedom. Here’s what happens:</p> <ol> <li> <strong>Normal operation</strong>: All three axes are independent</li> <li> <strong>Approaching ±90° pitch</strong>: The yaw and roll axes start to align</li> <li> <strong>At ±90° pitch</strong>: Yaw and roll do the same thing - you lose control!</li> </ol> <p>This isn’t a coding bug - it’s a fundamental mathematical limitation called a <strong>singularity</strong>.</p> <h3 id="why-this-matters-practical-consequences">Why This Matters: Practical Consequences</h3> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Example: Smooth rotation that breaks near gimbal lock</span>
<span class="kd">function</span> <span class="nf">interpolateEulerAngles</span><span class="p">(</span><span class="nx">start</span><span class="p">,</span> <span class="nx">end</span><span class="p">,</span> <span class="nx">t</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Linear interpolation - seems reasonable?</span>
    <span class="k">return</span> <span class="p">{</span>
        <span class="na">yaw</span><span class="p">:</span> <span class="nx">start</span><span class="p">.</span><span class="nx">yaw</span> <span class="o">+</span> <span class="p">(</span><span class="nx">end</span><span class="p">.</span><span class="nx">yaw</span> <span class="o">-</span> <span class="nx">start</span><span class="p">.</span><span class="nx">yaw</span><span class="p">)</span> <span class="o">*</span> <span class="nx">t</span><span class="p">,</span>
        <span class="na">pitch</span><span class="p">:</span> <span class="nx">start</span><span class="p">.</span><span class="nx">pitch</span> <span class="o">+</span> <span class="p">(</span><span class="nx">end</span><span class="p">.</span><span class="nx">pitch</span> <span class="o">-</span> <span class="nx">start</span><span class="p">.</span><span class="nx">pitch</span><span class="p">)</span> <span class="o">*</span> <span class="nx">t</span><span class="p">,</span>
        <span class="na">roll</span><span class="p">:</span> <span class="nx">start</span><span class="p">.</span><span class="nx">roll</span> <span class="o">+</span> <span class="p">(</span><span class="nx">end</span><span class="p">.</span><span class="nx">roll</span> <span class="o">-</span> <span class="nx">start</span><span class="p">.</span><span class="nx">roll</span><span class="p">)</span> <span class="o">*</span> <span class="nx">t</span>
    <span class="p">};</span>
<span class="p">}</span>

<span class="c1">// This causes problems:</span>
<span class="kd">const</span> <span class="k">from</span> <span class="o">=</span> <span class="p">{</span><span class="na">yaw</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="na">pitch</span><span class="p">:</span> <span class="mi">89</span><span class="p">,</span> <span class="na">roll</span><span class="p">:</span> <span class="mi">0</span><span class="p">};</span>      <span class="c1">// Almost at singularity</span>
<span class="kd">const</span> <span class="nx">to</span> <span class="o">=</span> <span class="p">{</span><span class="na">yaw</span><span class="p">:</span> <span class="mi">180</span><span class="p">,</span> <span class="na">pitch</span><span class="p">:</span> <span class="mi">89</span><span class="p">,</span> <span class="na">roll</span><span class="p">:</span> <span class="mi">0</span><span class="p">};</span>      <span class="c1">// Still near singularity</span>
<span class="c1">// Result: Violent spinning as yaw "wraps around" at singularity!</span>
</code></pre></div></div> <p><strong>Gimbal Lock Demonstration</strong>: In the interactive visualization below, observe how the Euler angle system breaks down. When pitch approaches ±90°, the yaw and roll axes become parallel, causing a loss of one degree of freedom.</p> <p><strong>Try this</strong>: Set pitch to ±90° and notice how yaw and roll controls do the same thing!</p> <div class="panel"> <h3>Gimbal Rig</h3> <div class="canvas-container"> <canvas id="gimbalCanvas"></canvas> </div> <div class="controls"> <div class="control-group"> <label><span style="color: #64ffda;">Yaw (Z-axis)</span> <span class="value-display" id="yawValue">0°</span></label> <input type="range" class="slider" id="yawSlider" min="-180" max="180" value="0" step="1"> </div> <div class="control-group"> <label><span style="color: #4caf50;">Pitch (Y-axis)</span> <span class="value-display" id="pitchValue">0°</span></label> <input type="range" class="slider" id="pitchSlider" min="-90" max="90" value="0" step="1"> </div> <div class="control-group"> <label><span style="color: #ff9800;">Roll (X-axis)</span> <span class="value-display" id="rollValue">0°</span></label> <input type="range" class="slider" id="rollSlider" min="-180" max="180" value="0" step="1"> </div> </div> <div class="warning" id="gimbalWarning"> GIMBAL LOCK! Yaw and Roll axes are aligned - you've lost a degree of freedom! </div> <div class="info-box"> <strong>Try this:</strong> Set pitch to ±90° and notice how yaw and roll controls do the same thing. This is gimbal lock - the curse of Euler angles! </div> </div> <p>The degeneracy occurs because Euler angles represent rotations as a composition of rotations about fixed axes: R = R_z(ψ)R_y(θ)R_x(φ), where the middle rotation R_y(θ) at θ = ±π/2 aligns the first and third rotation axes.</p> <div class="panel"> <h3>Quaternion Sphere (S³)</h3> <div class="canvas-container"> <canvas id="quaternionCanvas"></canvas> </div> <div class="quaternion-display"> <div class="quat-component"> <div class="label">x</div> <div class="value" id="quatX">0.000</div> </div> <div class="quat-component"> <div class="label">y</div> <div class="value" id="quatY">0.000</div> </div> <div class="quat-component"> <div class="label">z</div> <div class="value" id="quatZ">0.000</div> </div> <div class="quat-component"> <div class="label">w</div> <div class="value" id="quatW">1.000</div> </div> </div> <div class="controls"> <div class="control-group"> <label><span style="color: #64ffda;">Sphere Yaw</span> <span class="value-display" id="sphereYawValue">0°</span></label> <input type="range" class="slider" id="sphereYawSlider" min="-180" max="180" value="0" step="1"> </div> <div class="control-group"> <label><span style="color: #4caf50;">Sphere Pitch</span> <span class="value-display" id="spherePitchValue">0°</span></label> <input type="range" class="slider" id="spherePitchSlider" min="-90" max="90" value="0" step="1"> </div> <div class="control-group"> <label><span style="color: #ff9800;">Sphere Roll</span> <span class="value-display" id="sphereRollValue">0°</span></label> <input type="range" class="slider" id="sphereRollSlider" min="-180" max="180" value="0" step="1"> </div> </div> <div class="controls"> <div class="control-group"> <label><span style="color: #e91e63;">Quaternion X</span> <span class="value-display" id="quatXValue">0.000</span></label> <input type="range" class="slider" id="quatXSlider" min="-1" max="1" value="0" step="0.001"> </div> <div class="control-group"> <label><span style="color: #9c27b0;">Quaternion Y</span> <span class="value-display" id="quatYValue">0.000</span></label> <input type="range" class="slider" id="quatYSlider" min="-1" max="1" value="0" step="0.001"> </div> <div class="control-group"> <label><span style="color: #3f51b5;">Quaternion Z</span> <span class="value-display" id="quatZValue">0.000</span></label> <input type="range" class="slider" id="quatZSlider" min="-1" max="1" value="0" step="0.001"> </div> <div class="control-group"> <label><span style="color: #009688;">Quaternion W</span> <span class="value-display" id="quatWValue">1.000</span></label> <input type="range" class="slider" id="quatWSlider" min="-1" max="1" value="1" step="0.001"> </div> </div> <div class="controls"> <button class="button" id="showQuaternionFeatures">Show Antipodal Points &amp; Geodesic Arc</button> </div> <div class="info-box"> <strong>Independent Controls:</strong> This quaternion sphere has its own Euler angle and quaternion component sliders. Changes in one automatically update the other while maintaining unit length through automatic normalization. All updates are real-time and bidirectional. </div> </div> <h2 id="the-hopf-fibration-understanding-quaternion-geometry">The Hopf Fibration: Understanding Quaternion Geometry</h2> <p>Before diving into the quaternion solution, it’s worth understanding one of the most beautiful mathematical structures that explains <em>why</em> quaternions work so elegantly: the <strong>Hopf fibration</strong>.</p> <h3 id="what-is-the-hopf-fibration">What Is the Hopf Fibration?</h3> <p>The Hopf fibration is a mathematical mapping discovered by Heinz Hopf in 1931 that reveals the deep geometric structure underlying quaternions. Think of it as a way of organizing the 4D quaternion space that makes 3D rotations naturally emerge.</p> <p><strong>The Basic Setup:</strong></p> <ul> <li> <strong>Total Space</strong>: The 3-sphere (S³) - where unit quaternions live</li> <li> <strong>Base Space</strong>: The 2-sphere (S²) - representing all possible 3D rotation axes</li> <li> <strong>Fiber</strong>: Circles (S¹) - representing rotations around each axis</li> </ul> <h3 id="the-intuitive-picture">The Intuitive Picture</h3> <p>Imagine you’re holding a globe (the 2-sphere S²). Each point on this globe represents a possible rotation axis in 3D space - north pole might be the Z-axis, equator points represent X-Y plane axes, and so on.</p> <p>Now, for each point on this globe, imagine a circle floating above it in 4D space. This circle represents all the different amounts you can rotate around that particular axis - 0°, 90°, 180°, 270°, back to 0°. These circles are the “fibers” of the Hopf fibration.</p> <p>The remarkable thing is that these circles never intersect, even though they fill up the entire 4D space of the 3-sphere. It’s like having infinite circles, each dedicated to one rotation axis, perfectly organized in 4D space without any collisions.</p> <h3 id="why-this-matters-for-quaternions">Why This Matters for Quaternions</h3> <p>This structure explains several key properties of quaternions:</p> <p><strong>1. No Singularities</strong>: Unlike Euler angles, which break down at certain orientations (gimbal lock), the Hopf fibration shows that every possible 3D rotation corresponds to a smooth path on the 3-sphere. There are no “holes” or “edges” where the math breaks down.</p> <p><strong>2. Double Coverage</strong>: Each 3D rotation corresponds to exactly two antipodal points on S³ (q and -q represent the same rotation). The Hopf fibration reveals this as a natural consequence of the fiber structure - each fiber maps to the same rotation axis, but parameterized twice around the circle.</p> <p><strong>3. Smooth Interpolation</strong>: SLERP works perfectly because it follows great circle arcs on S³, which project down to the shortest rotation paths on the rotation group SO(3). The Hopf fibration guarantees these paths exist and are unique.</p> <h3 id="the-mathematical-beauty">The Mathematical Beauty</h3> <table> <tbody> <tr> <td>The Hopf fibration can be written elegantly using complex numbers. If we represent a unit quaternion as two complex numbers (z₁, z₂) where</td> <td>z₁</td> <td>² +</td> <td>z₂</td> <td>² = 1, then the Hopf map is:</td> </tr> </tbody> </table> <table> <tbody> <tr> <td> <strong>Hopf map</strong>: (z₁, z₂) → (z₁z̄₂,</td> <td>z₁</td> <td>² -</td> <td>z₂</td> <td>²)</td> </tr> </tbody> </table> <p>This simple formula encodes the entire relationship between 4D quaternion space and 3D rotation space. The first component gives the rotation axis, while the second component relates to the rotation angle.</p> <h3 id="real-world-implications">Real-World Implications</h3> <p>Understanding the Hopf fibration helps explain why:</p> <ul> <li> <strong>Flight simulators</strong> use quaternions internally, even if they display Euler angles to pilots</li> <li> <strong>Robot control systems</strong> can achieve smoother, more predictable motion with quaternions</li> <li> <strong>3D animation software</strong> can avoid gimbal lock artifacts in character rigs</li> <li> <strong>Spacecraft attitude control</strong> becomes more reliable and efficient</li> </ul> <p>The Hopf fibration isn’t just abstract mathematics - it’s the geometric reason why quaternions provide such a robust, singularity-free way to handle 3D rotations in practice.</p> <div class="panel"> <h3>Hopf Fibration: The True S³ → S² Mapping</h3> <div class="canvas-container" style="height: 500px;"> <canvas id="hopfCanvas"></canvas> </div> <div class="hopf-info-panel"> <h4>Mathematical Structure</h4> <p><strong>Base Space:</strong> 2-sphere (S²)</p> <p><strong>Total Space:</strong> 3-sphere (S³)</p> <p><strong>Fiber:</strong> Circle (S¹)</p> <p>Each point on S² corresponds to a circle on S³. The visualization shows fibers as colored curves using stereographic projection from the 4D quaternion sphere.</p> </div> <div class="controls"> <div class="control-group"> <label>Rotation Speed <span class="value-display" id="hopfRotationSpeedValue">0.5</span></label> <input type="range" class="slider" id="hopfRotationSpeed" min="0" max="2" value="0.5" step="0.1"> </div> <div class="control-group"> <label>Fiber Count <span class="value-display" id="hopfFiberCountValue">16</span></label> <input type="range" class="slider" id="hopfFiberCount" min="8" max="32" value="16" step="2"> </div> <div class="control-group"> <label>Animation Phase <span class="value-display" id="hopfAnimationPhaseValue">0.00</span></label> <input type="range" class="slider" id="hopfAnimationPhase" min="0" max="6.28" value="0" step="0.1"> </div> <div class="control-group"> <label>Base Sphere Size <span class="value-display" id="hopfBaseSphereValue">1.0</span></label> <input type="range" class="slider" id="hopfBaseSphere" min="0.5" max="2" value="1" step="0.1"> </div> </div> <div class="controls"> <button class="button" id="hopfToggleAnimation">Pause</button> <button class="button" id="hopfResetView">Reset View</button> </div> <div class="info-box"> <strong>Advanced Hopf Fibration:</strong> This visualization uses proper complex number representation and stereographic projection to show the true S³ → S² → S¹ fiber bundle structure. Each colored fiber represents a great circle on the 4D quaternion sphere that projects to a single point on the 2D base sphere. The mathematical elegance of this structure is what makes quaternions so powerful for representing rotations! </div> </div> <h2 id="enter-quaternions-a-better-way-to-rotate">Enter Quaternions: A Better Way to Rotate</h2> <p>Quaternions might seem mysterious at first, but they’re actually quite elegant once you understand the core idea. Think of them as an extension of complex numbers to 3D rotations.</p> <h3 id="what-is-a-quaternion">What Is a Quaternion?</h3> <p>A quaternion is a 4-component number: <strong>q = (x, y, z, w)</strong> where:</p> <ul> <li> <strong>(x, y, z)</strong>: The rotation axis (like a vector pointing through the object)</li> <li> <strong>w</strong>: Related to the rotation angle (cosine of half-angle)</li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Quaternion class - much more stable than Euler angles</span>
<span class="kd">class</span> <span class="nc">Quaternion</span> <span class="p">{</span>
    <span class="nf">constructor</span><span class="p">(</span><span class="nx">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">z</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">w</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="nx">x</span><span class="p">;</span> <span class="k">this</span><span class="p">.</span><span class="nx">y</span> <span class="o">=</span> <span class="nx">y</span><span class="p">;</span> <span class="k">this</span><span class="p">.</span><span class="nx">z</span> <span class="o">=</span> <span class="nx">z</span><span class="p">;</span> <span class="k">this</span><span class="p">.</span><span class="nx">w</span> <span class="o">=</span> <span class="nx">w</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="c1">// Create quaternion from axis-angle (most intuitive)</span>
    <span class="kd">static</span> <span class="nf">fromAxisAngle</span><span class="p">(</span><span class="nx">axis</span><span class="p">,</span> <span class="nx">angle</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">halfAngle</span> <span class="o">=</span> <span class="nx">angle</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">;</span>
        <span class="kd">const</span> <span class="nx">sin</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">sin</span><span class="p">(</span><span class="nx">halfAngle</span><span class="p">);</span>
        <span class="kd">const</span> <span class="nx">cos</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">cos</span><span class="p">(</span><span class="nx">halfAngle</span><span class="p">);</span>
        
        <span class="k">return</span> <span class="k">new</span> <span class="nc">Quaternion</span><span class="p">(</span>
            <span class="nx">axis</span><span class="p">.</span><span class="nx">x</span> <span class="o">*</span> <span class="nx">sin</span><span class="p">,</span>
            <span class="nx">axis</span><span class="p">.</span><span class="nx">y</span> <span class="o">*</span> <span class="nx">sin</span><span class="p">,</span>
            <span class="nx">axis</span><span class="p">.</span><span class="nx">z</span> <span class="o">*</span> <span class="nx">sin</span><span class="p">,</span>
            <span class="nx">cos</span>
        <span class="p">);</span>
    <span class="p">}</span>
    
    <span class="c1">// The magic: no gimbal lock!</span>
    <span class="kd">static</span> <span class="nf">fromEuler</span><span class="p">(</span><span class="nx">yaw</span><span class="p">,</span> <span class="nx">pitch</span><span class="p">,</span> <span class="nx">roll</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">cy</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">cos</span><span class="p">(</span><span class="nx">yaw</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">);</span>
        <span class="kd">const</span> <span class="nx">sy</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">sin</span><span class="p">(</span><span class="nx">yaw</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">);</span>
        <span class="kd">const</span> <span class="nx">cp</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">cos</span><span class="p">(</span><span class="nx">pitch</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">);</span>
        <span class="kd">const</span> <span class="nx">sp</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">sin</span><span class="p">(</span><span class="nx">pitch</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">);</span>
        <span class="kd">const</span> <span class="nx">cr</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">cos</span><span class="p">(</span><span class="nx">roll</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">);</span>
        <span class="kd">const</span> <span class="nx">sr</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">sin</span><span class="p">(</span><span class="nx">roll</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">);</span>

        <span class="k">return</span> <span class="k">new</span> <span class="nc">Quaternion</span><span class="p">(</span>
            <span class="nx">sr</span> <span class="o">*</span> <span class="nx">cp</span> <span class="o">*</span> <span class="nx">cy</span> <span class="o">-</span> <span class="nx">cr</span> <span class="o">*</span> <span class="nx">sp</span> <span class="o">*</span> <span class="nx">sy</span><span class="p">,</span>
            <span class="nx">cr</span> <span class="o">*</span> <span class="nx">sp</span> <span class="o">*</span> <span class="nx">cy</span> <span class="o">+</span> <span class="nx">sr</span> <span class="o">*</span> <span class="nx">cp</span> <span class="o">*</span> <span class="nx">sy</span><span class="p">,</span>
            <span class="nx">cr</span> <span class="o">*</span> <span class="nx">cp</span> <span class="o">*</span> <span class="nx">sy</span> <span class="o">-</span> <span class="nx">sr</span> <span class="o">*</span> <span class="nx">sp</span> <span class="o">*</span> <span class="nx">cy</span><span class="p">,</span>
            <span class="nx">cr</span> <span class="o">*</span> <span class="nx">cp</span> <span class="o">*</span> <span class="nx">cy</span> <span class="o">+</span> <span class="nx">sr</span> <span class="o">*</span> <span class="nx">sp</span> <span class="o">*</span> <span class="nx">sy</span>
        <span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="why-quaternions-work-the-key-insight">Why Quaternions Work: The Key Insight</h3> <p>Quaternions live on a <strong>4D unit sphere</strong> (mathematically called S³). This extra dimension is what eliminates gimbal lock! Here’s the crucial insight:</p> <ul> <li> <strong>Euler angles</strong>: 3 parameters trying to represent 3D rotations → singularities inevitable</li> <li> <strong>Quaternions</strong>: 4 parameters (with 1 constraint: unit length) → no singularities!</li> </ul> <p>Think of it like this: imagine trying to wrap a globe with flat paper without wrinkles - impossible! But if you allow the paper to stretch into 3D, it becomes easy. Similarly, that extra quaternion dimension eliminates the “wrinkles” (singularities) in rotation space.</p> <h3 id="the-double-cover-property">The Double Cover Property</h3> <p>Here’s something fascinating: both <strong>q</strong> and <strong>-q</strong> represent the same rotation! This “double coverage” might seem redundant, but it’s actually a feature:</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Both of these represent the same rotation:</span>
<span class="kd">const</span> <span class="nx">q1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Quaternion</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>    <span class="c1">// Identity rotation</span>
<span class="kd">const</span> <span class="nx">q2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Quaternion</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>   <span class="c1">// Same rotation!</span>

<span class="c1">// This redundancy eliminates singularities</span>
<span class="kd">function</span> <span class="nf">ensureContinuity</span><span class="p">(</span><span class="nx">currentQ</span><span class="p">,</span> <span class="nx">previousQ</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Choose the closer of q or -q to maintain smooth motion</span>
    <span class="kd">const</span> <span class="nx">dot1</span> <span class="o">=</span> <span class="nf">dotProduct</span><span class="p">(</span><span class="nx">currentQ</span><span class="p">,</span> <span class="nx">previousQ</span><span class="p">);</span>
    <span class="kd">const</span> <span class="nx">dot2</span> <span class="o">=</span> <span class="nf">dotProduct</span><span class="p">(</span><span class="nf">negateQuaternion</span><span class="p">(</span><span class="nx">currentQ</span><span class="p">),</span> <span class="nx">previousQ</span><span class="p">);</span>
    
    <span class="k">return</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">abs</span><span class="p">(</span><span class="nx">dot2</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">abs</span><span class="p">(</span><span class="nx">dot1</span><span class="p">)</span> <span class="p">?</span>
           <span class="nf">negateQuaternion</span><span class="p">(</span><span class="nx">currentQ</span><span class="p">)</span> <span class="p">:</span> <span class="nx">currentQ</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="real-world-applications">Real-World Applications</h3> <p><strong>Unity Game Engine Example:</strong></p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Unity uses quaternions internally for all rotations</span>
<span class="n">Transform</span> <span class="n">player</span><span class="p">;</span>

<span class="c1">// Smooth rotation without gimbal lock</span>
<span class="n">Quaternion</span> <span class="n">targetRotation</span> <span class="p">=</span> <span class="n">Quaternion</span><span class="p">.</span><span class="nf">LookRotation</span><span class="p">(</span><span class="n">direction</span><span class="p">);</span>
<span class="n">player</span><span class="p">.</span><span class="n">rotation</span> <span class="p">=</span> <span class="n">Quaternion</span><span class="p">.</span><span class="nf">Slerp</span><span class="p">(</span><span class="n">player</span><span class="p">.</span><span class="n">rotation</span><span class="p">,</span> <span class="n">targetRotation</span><span class="p">,</span> <span class="n">Time</span><span class="p">.</span><span class="n">deltaTime</span> <span class="p">*</span> <span class="n">rotateSpeed</span><span class="p">);</span>

<span class="c1">// This just works - no special cases needed!</span>
</code></pre></div></div> <p><strong>Robotics Example:</strong></p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Robot arm joint control using quaternions</span>
<span class="k">class</span> <span class="nc">RobotJoint</span> <span class="p">{</span>
    <span class="n">Quaternion</span> <span class="n">currentOrientation</span><span class="p">;</span>
    <span class="n">Quaternion</span> <span class="n">targetOrientation</span><span class="p">;</span>
    
    <span class="kt">void</span> <span class="n">updateJoint</span><span class="p">(</span><span class="kt">float</span> <span class="n">deltaTime</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// SLERP provides smooth, constant-speed rotation</span>
        <span class="n">currentOrientation</span> <span class="o">=</span> <span class="n">slerp</span><span class="p">(</span><span class="n">currentOrientation</span><span class="p">,</span>
                                 <span class="n">targetOrientation</span><span class="p">,</span>
                                 <span class="n">deltaTime</span> <span class="o">*</span> <span class="n">jointSpeed</span><span class="p">);</span>
        
        <span class="c1">// Convert to motor control signals</span>
        <span class="n">applyJointRotation</span><span class="p">(</span><span class="n">currentOrientation</span><span class="p">.</span><span class="n">toRotationMatrix</span><span class="p">());</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div> <p><strong>The Mathematics Behind the Magic:</strong></p> <p>The quaternion sphere visualization above demonstrates this double coverage. The antipodal points ±q on the 4D sphere both map to the same rotation matrix, providing redundancy that eliminates singular configurations. This is why quaternions can represent any 3D rotation smoothly - they live in a higher-dimensional space that “unwraps” the problematic topology of 3D rotation space.</p> <p><strong>For the mathematically inclined:</strong> Quaternions form a <strong>Lie group</strong> isomorphic to SU(2), which double-covers SO(3). The <strong>hairy ball theorem</strong> proves that any 3-parameter system must have singularities, but quaternions sidestep this by using 4 parameters with a constraint.</p> <h2 id="slerp-vs-lerp-the-battle-of-interpolation-methods">SLERP vs LERP: The Battle of Interpolation Methods</h2> <p>When animating rotations, you need to smoothly transition from one orientation to another. This is where <strong>SLERP</strong> (Spherical Linear Interpolation) shines compared to simple linear interpolation of Euler angles.</p> <h3 id="the-problem-with-euler-interpolation">The Problem with Euler Interpolation</h3> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Naive Euler angle interpolation - DON'T DO THIS!</span>
<span class="kd">function</span> <span class="nf">badRotationInterp</span><span class="p">(</span><span class="nx">startEuler</span><span class="p">,</span> <span class="nx">endEuler</span><span class="p">,</span> <span class="nx">t</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">{</span>
        <span class="na">yaw</span><span class="p">:</span> <span class="nx">startEuler</span><span class="p">.</span><span class="nx">yaw</span> <span class="o">+</span> <span class="p">(</span><span class="nx">endEuler</span><span class="p">.</span><span class="nx">yaw</span> <span class="o">-</span> <span class="nx">startEuler</span><span class="p">.</span><span class="nx">yaw</span><span class="p">)</span> <span class="o">*</span> <span class="nx">t</span><span class="p">,</span>
        <span class="na">pitch</span><span class="p">:</span> <span class="nx">startEuler</span><span class="p">.</span><span class="nx">pitch</span> <span class="o">+</span> <span class="p">(</span><span class="nx">endEuler</span><span class="p">.</span><span class="nx">pitch</span> <span class="o">-</span> <span class="nx">startEuler</span><span class="p">.</span><span class="nx">pitch</span><span class="p">)</span> <span class="o">*</span> <span class="nx">t</span><span class="p">,</span>
        <span class="na">roll</span><span class="p">:</span> <span class="nx">startEuler</span><span class="p">.</span><span class="nx">roll</span> <span class="o">+</span> <span class="p">(</span><span class="nx">endEuler</span><span class="p">.</span><span class="nx">roll</span> <span class="o">-</span> <span class="nx">startEuler</span><span class="p">.</span><span class="nx">roll</span><span class="p">)</span> <span class="o">*</span> <span class="nx">t</span>
    <span class="p">};</span>
<span class="p">}</span>

<span class="c1">// Why this fails:</span>
<span class="kd">const</span> <span class="k">from</span> <span class="o">=</span> <span class="p">{</span><span class="na">yaw</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="na">pitch</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="na">roll</span><span class="p">:</span> <span class="mi">0</span><span class="p">};</span>
<span class="kd">const</span> <span class="nx">to</span> <span class="o">=</span> <span class="p">{</span><span class="na">yaw</span><span class="p">:</span> <span class="mi">180</span><span class="p">,</span> <span class="na">pitch</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="na">roll</span><span class="p">:</span> <span class="mi">0</span><span class="p">};</span>
<span class="c1">// Linear interpolation spins through intermediate orientations</span>
<span class="c1">// that aren't on the shortest rotation path!</span>
</code></pre></div></div> <h3 id="slerp-the-right-way">SLERP: The Right Way</h3> <p>SLERP finds the shortest path between two orientations and moves along it at constant angular speed:</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Proper quaternion SLERP implementation</span>
<span class="kd">function</span> <span class="nf">slerp</span><span class="p">(</span><span class="nx">q1</span><span class="p">,</span> <span class="nx">q2</span><span class="p">,</span> <span class="nx">t</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Ensure we take the shorter path (handle double cover)</span>
    <span class="kd">let</span> <span class="nx">dot</span> <span class="o">=</span> <span class="nx">q1</span><span class="p">.</span><span class="nx">x</span><span class="o">*</span><span class="nx">q2</span><span class="p">.</span><span class="nx">x</span> <span class="o">+</span> <span class="nx">q1</span><span class="p">.</span><span class="nx">y</span><span class="o">*</span><span class="nx">q2</span><span class="p">.</span><span class="nx">y</span> <span class="o">+</span> <span class="nx">q1</span><span class="p">.</span><span class="nx">z</span><span class="o">*</span><span class="nx">q2</span><span class="p">.</span><span class="nx">z</span> <span class="o">+</span> <span class="nx">q1</span><span class="p">.</span><span class="nx">w</span><span class="o">*</span><span class="nx">q2</span><span class="p">.</span><span class="nx">w</span><span class="p">;</span>
    
    <span class="c1">// If dot &lt; 0, use -q2 to ensure shorter path</span>
    <span class="k">if </span><span class="p">(</span><span class="nx">dot</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">q2</span> <span class="o">=</span> <span class="p">{</span><span class="na">x</span><span class="p">:</span> <span class="o">-</span><span class="nx">q2</span><span class="p">.</span><span class="nx">x</span><span class="p">,</span> <span class="na">y</span><span class="p">:</span> <span class="o">-</span><span class="nx">q2</span><span class="p">.</span><span class="nx">y</span><span class="p">,</span> <span class="na">z</span><span class="p">:</span> <span class="o">-</span><span class="nx">q2</span><span class="p">.</span><span class="nx">z</span><span class="p">,</span> <span class="na">w</span><span class="p">:</span> <span class="o">-</span><span class="nx">q2</span><span class="p">.</span><span class="nx">w</span><span class="p">};</span>
        <span class="nx">dot</span> <span class="o">=</span> <span class="o">-</span><span class="nx">dot</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="c1">// Handle nearly parallel quaternions</span>
    <span class="k">if </span><span class="p">(</span><span class="nx">dot</span> <span class="o">&gt;</span> <span class="mf">0.9995</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Use linear interpolation for numerical stability</span>
        <span class="kd">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="p">{</span>
            <span class="na">x</span><span class="p">:</span> <span class="nx">q1</span><span class="p">.</span><span class="nx">x</span> <span class="o">+</span> <span class="nx">t</span> <span class="o">*</span> <span class="p">(</span><span class="nx">q2</span><span class="p">.</span><span class="nx">x</span> <span class="o">-</span> <span class="nx">q1</span><span class="p">.</span><span class="nx">x</span><span class="p">),</span>
            <span class="na">y</span><span class="p">:</span> <span class="nx">q1</span><span class="p">.</span><span class="nx">y</span> <span class="o">+</span> <span class="nx">t</span> <span class="o">*</span> <span class="p">(</span><span class="nx">q2</span><span class="p">.</span><span class="nx">y</span> <span class="o">-</span> <span class="nx">q1</span><span class="p">.</span><span class="nx">y</span><span class="p">),</span>
            <span class="na">z</span><span class="p">:</span> <span class="nx">q1</span><span class="p">.</span><span class="nx">z</span> <span class="o">+</span> <span class="nx">t</span> <span class="o">*</span> <span class="p">(</span><span class="nx">q2</span><span class="p">.</span><span class="nx">z</span> <span class="o">-</span> <span class="nx">q1</span><span class="p">.</span><span class="nx">z</span><span class="p">),</span>
            <span class="na">w</span><span class="p">:</span> <span class="nx">q1</span><span class="p">.</span><span class="nx">w</span> <span class="o">+</span> <span class="nx">t</span> <span class="o">*</span> <span class="p">(</span><span class="nx">q2</span><span class="p">.</span><span class="nx">w</span> <span class="o">-</span> <span class="nx">q1</span><span class="p">.</span><span class="nx">w</span><span class="p">)</span>
        <span class="p">};</span>
        <span class="k">return</span> <span class="nf">normalize</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span>
    <span class="p">}</span>
    
    <span class="c1">// Standard SLERP formula</span>
    <span class="kd">const</span> <span class="nx">theta</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">acos</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nf">abs</span><span class="p">(</span><span class="nx">dot</span><span class="p">));</span>
    <span class="kd">const</span> <span class="nx">sinTheta</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">sin</span><span class="p">(</span><span class="nx">theta</span><span class="p">);</span>
    <span class="kd">const</span> <span class="nx">scale1</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">sin</span><span class="p">((</span><span class="mi">1</span><span class="o">-</span><span class="nx">t</span><span class="p">)</span> <span class="o">*</span> <span class="nx">theta</span><span class="p">)</span> <span class="o">/</span> <span class="nx">sinTheta</span><span class="p">;</span>
    <span class="kd">const</span> <span class="nx">scale2</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">sin</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span> <span class="nx">theta</span><span class="p">)</span> <span class="o">/</span> <span class="nx">sinTheta</span><span class="p">;</span>
    
    <span class="k">return</span> <span class="p">{</span>
        <span class="na">x</span><span class="p">:</span> <span class="nx">scale1</span> <span class="o">*</span> <span class="nx">q1</span><span class="p">.</span><span class="nx">x</span> <span class="o">+</span> <span class="nx">scale2</span> <span class="o">*</span> <span class="nx">q2</span><span class="p">.</span><span class="nx">x</span><span class="p">,</span>
        <span class="na">y</span><span class="p">:</span> <span class="nx">scale1</span> <span class="o">*</span> <span class="nx">q1</span><span class="p">.</span><span class="nx">y</span> <span class="o">+</span> <span class="nx">scale2</span> <span class="o">*</span> <span class="nx">q2</span><span class="p">.</span><span class="nx">y</span><span class="p">,</span>
        <span class="na">z</span><span class="p">:</span> <span class="nx">scale1</span> <span class="o">*</span> <span class="nx">q1</span><span class="p">.</span><span class="nx">z</span> <span class="o">+</span> <span class="nx">scale2</span> <span class="o">*</span> <span class="nx">q2</span><span class="p">.</span><span class="nx">z</span><span class="p">,</span>
        <span class="na">w</span><span class="p">:</span> <span class="nx">scale1</span> <span class="o">*</span> <span class="nx">q1</span><span class="p">.</span><span class="nx">w</span> <span class="o">+</span> <span class="nx">scale2</span> <span class="o">*</span> <span class="nx">q2</span><span class="p">.</span><span class="nx">w</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="real-world-application-examples">Real-World Application Examples</h3> <p><strong>Camera Movement in Games:</strong></p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Smooth camera transitions using SLERP</span>
<span class="kd">class</span> <span class="nc">Camera</span> <span class="p">{</span>
    <span class="nf">constructor</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">orientation</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Quaternion</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">targetOrientation</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Quaternion</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    
    <span class="nf">lookAt</span><span class="p">(</span><span class="nx">target</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Calculate desired orientation</span>
        <span class="kd">const</span> <span class="nx">direction</span> <span class="o">=</span> <span class="nx">Vector3</span><span class="p">.</span><span class="nf">subtract</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">position</span><span class="p">);</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">targetOrientation</span> <span class="o">=</span> <span class="nx">Quaternion</span><span class="p">.</span><span class="nf">lookRotation</span><span class="p">(</span><span class="nx">direction</span><span class="p">);</span>
    <span class="p">}</span>
    
    <span class="nf">update</span><span class="p">(</span><span class="nx">deltaTime</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Smooth interpolation - no jumpy camera movement!</span>
        <span class="kd">const</span> <span class="nx">speed</span> <span class="o">=</span> <span class="mf">2.0</span><span class="p">;</span> <span class="c1">// rotation speed</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">orientation</span> <span class="o">=</span> <span class="nf">slerp</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">orientation</span><span class="p">,</span>
                                <span class="k">this</span><span class="p">.</span><span class="nx">targetOrientation</span><span class="p">,</span>
                                <span class="nx">deltaTime</span> <span class="o">*</span> <span class="nx">speed</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p><strong>Robot Arm Control:</strong></p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Smooth robot joint movement using SLERP
</span><span class="k">class</span> <span class="nc">RobotArm</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">joint_orientations</span> <span class="o">=</span> <span class="p">[</span><span class="n">Quaternion</span><span class="p">.</span><span class="nf">identity</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">6</span><span class="p">)]</span>
        <span class="n">self</span><span class="p">.</span><span class="n">target_orientations</span> <span class="o">=</span> <span class="p">[</span><span class="n">Quaternion</span><span class="p">.</span><span class="nf">identity</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">6</span><span class="p">)]</span>
    
    <span class="k">def</span> <span class="nf">move_to_position</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">target_pose</span><span class="p">,</span> <span class="n">duration</span><span class="p">):</span>
        <span class="c1"># Calculate target joint orientations using inverse kinematics
</span>        <span class="n">self</span><span class="p">.</span><span class="n">target_orientations</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">inverse_kinematics</span><span class="p">(</span><span class="n">target_pose</span><span class="p">)</span>
        
        <span class="c1"># SLERP ensures smooth, natural-looking motion
</span>        <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="nf">time</span><span class="p">()</span>
        <span class="k">while</span> <span class="n">time</span><span class="p">.</span><span class="nf">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span> <span class="o">&lt;</span> <span class="n">duration</span><span class="p">:</span>
            <span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="n">time</span><span class="p">.</span><span class="nf">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">)</span> <span class="o">/</span> <span class="n">duration</span>
            
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">6</span><span class="p">):</span>
                <span class="n">self</span><span class="p">.</span><span class="n">joint_orientations</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nf">slerp</span><span class="p">(</span>
                    <span class="n">self</span><span class="p">.</span><span class="n">joint_orientations</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                    <span class="n">self</span><span class="p">.</span><span class="n">target_orientations</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                    <span class="n">t</span>
                <span class="p">)</span>
            
            <span class="n">self</span><span class="p">.</span><span class="nf">update_joint_motors</span><span class="p">()</span>
            <span class="n">time</span><span class="p">.</span><span class="nf">sleep</span><span class="p">(</span><span class="mf">0.016</span><span class="p">)</span>  <span class="c1"># 60 FPS update
</span></code></pre></div></div> <h3 id="why-slerp-works-the-mathematical-insight">Why SLERP Works: The Mathematical Insight</h3> <p>The key insight is that SLERP follows <strong>great circle arcs</strong> on the quaternion sphere - these are the shortest paths between rotations, just like how airplane routes follow great circles on Earth.</p> <p><strong>Mathematical Properties of SLERP:</strong></p> <ul> <li> <strong>Constant Angular Velocity</strong>: Objects rotate at steady speed (no speed-up/slow-down artifacts)</li> <li> <strong>Shortest Path</strong>: Always takes the most direct route between orientations</li> <li> <strong>Interpolation Property</strong>: slerp(q1, q2, 0) = q1 and slerp(q1, q2, 1) = q2</li> <li> <strong>Composition Invariant</strong>: Results don’t depend on coordinate system choice</li> </ul> <p><strong>Euler LERP Problems:</strong></p> <ul> <li> <strong>Variable Speed</strong>: Object speed changes unpredictably during rotation</li> <li> <strong>Non-optimal Path</strong>: Takes longer, curved routes through “rotation space”</li> <li> <strong>Gimbal Lock Sensitivity</strong>: Can produce wild spinning near singularities</li> </ul> <h3 id="visualization-analysis">Visualization Analysis</h3> <p>The interactive demonstrations below show these differences clearly:</p> <p><strong>Left Panel - Angular Velocity Profile</strong>: This shows rotation speed over time (0 to 1). SLERP maintains constant angular velocity - the line is flat! Euler LERP shows varying speed with unpredictable speed-ups and slow-downs.</p> <p><strong>Right Panel - Quaternion Paths</strong>: Shows actual rotation paths on the unit sphere. The blue SLERP path follows the shortest great circle arc, while the red Euler LERP path takes a curved, non-optimal route.</p> <div class="panel wide-panel"> <h3>Interpolation: Euler LERP vs SLERP</h3> <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;"> <div class="canvas-container" style="height: 300px;"> <canvas id="slerpVelocityCanvas"></canvas> </div> <div class="canvas-container" style="height: 300px;"> <canvas id="slerpPathCanvas"></canvas> </div> </div> <div class="controls"> <div class="control-group"> <label>Interpolation Parameter t <span class="value-display" id="tValue">0.0</span></label> <input type="range" class="slider" id="tSlider" min="0" max="1" value="0" step="0.01"> </div> <button class="button" id="animateInterp">Animate Interpolation</button> <button class="button" id="setRandomOrientations">Set Random Orientations</button> </div> <div class="info-box"> <strong>Left Panel - Angular Velocity:</strong> Shows rotation speed over time (0 to 1)<br> • <span style="color: #2196f3;">Blue (SLERP)</span>: Constant angular velocity - the line is flat! (σ ≈ 0)<br> • <span style="color: #f44336;">Red (Euler LERP)</span>: Varying speed - speeds up and slows down (σ &gt; 0)<br> <br> <strong>Right Panel - Quaternion Paths:</strong> Shows actual rotation paths on the unit sphere<br> • <span style="color: #2196f3;">Blue path</span>: SLERP follows the shortest great circle arc<br> • <span style="color: #f44336;">Red path</span>: Euler LERP takes a curved, non-optimal path<br> <br> <strong>Key Insight:</strong> SLERP provides smooth, constant-speed rotation (like a spinning gyroscope), while Euler LERP causes jerky, unnatural motion with varying speeds. This is why SLERP is essential for animation and robotics! </div> </div> <h2 id="understanding-euler-angle-instability-a-visual-guide">Understanding Euler Angle Instability: A Visual Guide</h2> <p>Why do Euler angles become unstable near certain orientations? The sensitivity heatmap below reveals the mathematical “danger zones” where small changes in input can cause huge, unpredictable rotations.</p> <h3 id="what-are-we-looking-at">What Are We Looking At?</h3> <p>Think of the heatmap as a “stability map” for Euler angle rotations:</p> <ul> <li> <strong>Blue regions</strong>: Safe - small input changes cause small rotation changes</li> <li> <strong>Green regions</strong>: Caution - getting sensitive to small changes</li> <li> <strong>Red regions</strong>: Dangerous - small changes can cause large jumps</li> <li> <strong>Yellow regions</strong>: Gimbal lock! - the system breaks down completely</li> </ul> <h3 id="the-mathematics-behind-the-colors">The Mathematics Behind the Colors</h3> <p>The colors represent the <strong>condition number</strong> of something called the Jacobian matrix. Don’t worry about the fancy names - here’s what matters:</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// This matrix tells us how sensitive rotations are to Euler angle changes</span>
<span class="kd">function</span> <span class="nf">calculateSensitivity</span><span class="p">(</span><span class="nx">yaw</span><span class="p">,</span> <span class="nx">pitch</span><span class="p">,</span> <span class="nx">roll</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Near pitch = ±90°, this matrix becomes "singular"</span>
    <span class="c1">// (mathematically broken)</span>
    <span class="kd">const</span> <span class="nx">cosP</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">cos</span><span class="p">(</span><span class="nx">pitch</span><span class="p">);</span>
    <span class="kd">const</span> <span class="nx">sinP</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">sin</span><span class="p">(</span><span class="nx">pitch</span><span class="p">);</span>
    
    <span class="c1">// The Jacobian matrix - relates angle changes to rotation speed</span>
    <span class="kd">const</span> <span class="nx">J</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="nb">Math</span><span class="p">.</span><span class="nf">sin</span><span class="p">(</span><span class="nx">yaw</span><span class="p">),</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">cos</span><span class="p">(</span><span class="nx">yaw</span><span class="p">)</span> <span class="o">*</span> <span class="nx">cosP</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">0</span><span class="p">,</span>  <span class="nb">Math</span><span class="p">.</span><span class="nf">cos</span><span class="p">(</span><span class="nx">yaw</span><span class="p">),</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">sin</span><span class="p">(</span><span class="nx">yaw</span><span class="p">)</span> <span class="o">*</span> <span class="nx">cosP</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">1</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>             <span class="o">-</span><span class="nx">sinP</span><span class="p">]</span>
    <span class="p">];</span>
    
    <span class="c1">// When pitch ≈ ±90°, cosP ≈ 0, making the matrix unstable</span>
    <span class="k">return</span> <span class="nf">calculateConditionNumber</span><span class="p">(</span><span class="nx">J</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="real-world-implications-1">Real-World Implications</h3> <p><strong>Flight Simulator Example:</strong></p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// This is why flight simulators avoid certain orientations</span>
<span class="kd">class</span> <span class="nc">FlightControl</span> <span class="p">{</span>
    <span class="nf">updateOrientation</span><span class="p">(</span><span class="nx">yawInput</span><span class="p">,</span> <span class="nx">pitchInput</span><span class="p">,</span> <span class="nx">rollInput</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">sensitivity</span> <span class="o">=</span> <span class="nf">calculateSensitivity</span><span class="p">(</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">currentYaw</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">currentPitch</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">currentRoll</span>
        <span class="p">);</span>
        
        <span class="k">if </span><span class="p">(</span><span class="nx">sensitivity</span> <span class="o">&gt;</span> <span class="nx">DANGER_THRESHOLD</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// Switch to quaternion-based control near gimbal lock!</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">useQuaternionControl</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
            <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">WARNING: Entering gimbal lock region - switching to quaternions</span><span class="dl">"</span><span class="p">);</span>
        <span class="p">}</span>
        
        <span class="c1">// Apply control inputs based on current control mode</span>
        <span class="k">if </span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">useQuaternionControl</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">this</span><span class="p">.</span><span class="nf">updateWithQuaternions</span><span class="p">(</span><span class="nx">yawInput</span><span class="p">,</span> <span class="nx">pitchInput</span><span class="p">,</span> <span class="nx">rollInput</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">this</span><span class="p">.</span><span class="nf">updateWithEulerAngles</span><span class="p">(</span><span class="nx">yawInput</span><span class="p">,</span> <span class="nx">pitchInput</span><span class="p">,</span> <span class="nx">rollInput</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="torus-topology-why-angles-wrap-around">Torus Topology: Why Angles “Wrap Around”</h3> <p>The <strong>torus view</strong> shows something important: yaw and roll angles “wrap around” at ±180°. This is like how compass headings wrap from 359° back to 0°.</p> <p><strong>Practical Example:</strong></p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Angle wrapping causes problems in naive interpolation</span>
<span class="kd">const</span> <span class="nx">angle1</span> <span class="o">=</span> <span class="mi">170</span><span class="p">;</span>  <span class="c1">// degrees</span>
<span class="kd">const</span> <span class="nx">angle2</span> <span class="o">=</span> <span class="o">-</span><span class="mi">170</span><span class="p">;</span> <span class="c1">// degrees (equivalent to 190°)</span>

<span class="c1">// Naive interpolation: 170° → 0° → -170° (340° total rotation!)</span>
<span class="c1">// Smart interpolation: 170° → 180° → -170° (20° total rotation)</span>

<span class="kd">function</span> <span class="nf">smartAngleLerp</span><span class="p">(</span><span class="nx">a1</span><span class="p">,</span> <span class="nx">a2</span><span class="p">,</span> <span class="nx">t</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Handle the wrap-around case</span>
    <span class="kd">let</span> <span class="nx">diff</span> <span class="o">=</span> <span class="nx">a2</span> <span class="o">-</span> <span class="nx">a1</span><span class="p">;</span>
    <span class="k">if </span><span class="p">(</span><span class="nx">diff</span> <span class="o">&gt;</span> <span class="mi">180</span><span class="p">)</span> <span class="nx">diff</span> <span class="o">-=</span> <span class="mi">360</span><span class="p">;</span>
    <span class="k">if </span><span class="p">(</span><span class="nx">diff</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">180</span><span class="p">)</span> <span class="nx">diff</span> <span class="o">+=</span> <span class="mi">360</span><span class="p">;</span>
    
    <span class="k">return</span> <span class="nx">a1</span> <span class="o">+</span> <span class="nx">diff</span> <span class="o">*</span> <span class="nx">t</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>This is yet another reason why quaternions are superior - they don’t have wrap-around problems!</p> <p><strong>For the mathematically curious:</strong> The Jacobian matrix $J(ψ,θ,φ)$ relates small changes in Euler angles to angular velocity: $ω = J(ψ,θ,φ) \cdot [dψ/dt, dθ/dt, dφ/dt]^T$. Near gimbal lock $(θ ≈ ±π/2)$, $J$ becomes singular $(det(J) → 0)$, causing numerical instabilities and loss of controllability.</p> <div class="panel wide-panel"> <h3>Euler Angle Sensitivity Map (Torus Topology)</h3> <div class="canvas-container" style="height: 500px;"> <canvas id="heatmapCanvas"></canvas> </div> <div class="controls"> <div class="control-group"> <label>Fixed Pitch Value <span class="value-display" id="heatmapPitchValue">0°</span></label> <input type="range" class="slider" id="heatmapPitchSlider" min="-90" max="90" value="0" step="5"> </div> <div class="control-group"> <label><span style="color: #64ffda;">Torus Yaw</span> <span class="value-display" id="torusYawValue">0°</span></label> <input type="range" class="slider" id="torusYawSlider" min="-180" max="180" value="0" step="1"> </div> <div class="control-group"> <label><span style="color: #ff9800;">Torus Roll</span> <span class="value-display" id="torusRollValue">0°</span></label> <input type="range" class="slider" id="torusRollSlider" min="-180" max="180" value="0" step="1"> </div> <button class="button" id="animateHeatmap">Animate Through Pitch Values</button> <button class="button" id="toggleTorusView">Toggle Torus/Flat View</button> </div> <div class="info-box"> <strong>Color coding:</strong> <span style="color: #0066ff;">Blue</span> = stable, <span style="color: #00ff00;">Green</span> = sensitive, <span style="color: #ff0000;">Red</span> = highly singular, <span style="color: #ffff00;">Yellow</span> = gimbal lock!<br> This map shows how sensitive the rotation is to small changes in yaw/roll for a given pitch. The torus topology reveals how yaw and roll wrap around at ±180°. As pitch approaches ±90°, the entire map turns red/yellow, showing that yaw and roll become coupled and the coordinate system becomes singular. </div> </div> <h2 id="practical-implementation-guide-making-quaternions-work-for-you">Practical Implementation Guide: Making Quaternions Work for You</h2> <p>Ready to start using quaternions in your projects? Here are the essential patterns and best practices that will save you hours of debugging.</p> <h3 id="essential-quaternion-class-implementation">Essential Quaternion Class Implementation</h3> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Quaternion</span> <span class="p">{</span>
    <span class="nf">constructor</span><span class="p">(</span><span class="nx">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">z</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">w</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="nx">x</span><span class="p">;</span> <span class="k">this</span><span class="p">.</span><span class="nx">y</span> <span class="o">=</span> <span class="nx">y</span><span class="p">;</span> <span class="k">this</span><span class="p">.</span><span class="nx">z</span> <span class="o">=</span> <span class="nx">z</span><span class="p">;</span> <span class="k">this</span><span class="p">.</span><span class="nx">w</span> <span class="o">=</span> <span class="nx">w</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="c1">// CRITICAL: Always normalize after operations to prevent drift</span>
    <span class="nf">normalize</span><span class="p">()</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">length</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">sqrt</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">x</span><span class="o">*</span><span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">y</span><span class="o">*</span><span class="k">this</span><span class="p">.</span><span class="nx">y</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">z</span><span class="o">*</span><span class="k">this</span><span class="p">.</span><span class="nx">z</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">w</span><span class="o">*</span><span class="k">this</span><span class="p">.</span><span class="nx">w</span><span class="p">);</span>
        <span class="k">if </span><span class="p">(</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="kd">const</span> <span class="nx">invLength</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="nx">length</span><span class="p">;</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">*=</span> <span class="nx">invLength</span><span class="p">;</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">y</span> <span class="o">*=</span> <span class="nx">invLength</span><span class="p">;</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">z</span> <span class="o">*=</span> <span class="nx">invLength</span><span class="p">;</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">w</span> <span class="o">*=</span> <span class="nx">invLength</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="c1">// Multiply quaternions (order matters!)</span>
    <span class="nf">multiply</span><span class="p">(</span><span class="nx">other</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nc">Quaternion</span><span class="p">(</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">w</span><span class="o">*</span><span class="nx">other</span><span class="p">.</span><span class="nx">x</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">x</span><span class="o">*</span><span class="nx">other</span><span class="p">.</span><span class="nx">w</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">y</span><span class="o">*</span><span class="nx">other</span><span class="p">.</span><span class="nx">z</span> <span class="o">-</span> <span class="k">this</span><span class="p">.</span><span class="nx">z</span><span class="o">*</span><span class="nx">other</span><span class="p">.</span><span class="nx">y</span><span class="p">,</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">w</span><span class="o">*</span><span class="nx">other</span><span class="p">.</span><span class="nx">y</span> <span class="o">-</span> <span class="k">this</span><span class="p">.</span><span class="nx">x</span><span class="o">*</span><span class="nx">other</span><span class="p">.</span><span class="nx">z</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">y</span><span class="o">*</span><span class="nx">other</span><span class="p">.</span><span class="nx">w</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">z</span><span class="o">*</span><span class="nx">other</span><span class="p">.</span><span class="nx">x</span><span class="p">,</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">w</span><span class="o">*</span><span class="nx">other</span><span class="p">.</span><span class="nx">z</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">x</span><span class="o">*</span><span class="nx">other</span><span class="p">.</span><span class="nx">y</span> <span class="o">-</span> <span class="k">this</span><span class="p">.</span><span class="nx">y</span><span class="o">*</span><span class="nx">other</span><span class="p">.</span><span class="nx">x</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">z</span><span class="o">*</span><span class="nx">other</span><span class="p">.</span><span class="nx">w</span><span class="p">,</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">w</span><span class="o">*</span><span class="nx">other</span><span class="p">.</span><span class="nx">w</span> <span class="o">-</span> <span class="k">this</span><span class="p">.</span><span class="nx">x</span><span class="o">*</span><span class="nx">other</span><span class="p">.</span><span class="nx">x</span> <span class="o">-</span> <span class="k">this</span><span class="p">.</span><span class="nx">y</span><span class="o">*</span><span class="nx">other</span><span class="p">.</span><span class="nx">y</span> <span class="o">-</span> <span class="k">this</span><span class="p">.</span><span class="nx">z</span><span class="o">*</span><span class="nx">other</span><span class="p">.</span><span class="nx">z</span>
        <span class="p">);</span>
    <span class="p">}</span>
    
    <span class="c1">// Convert to rotation matrix (for graphics APIs)</span>
    <span class="nf">toMatrix</span><span class="p">()</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">x2</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y2</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">y</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">y</span><span class="p">,</span> <span class="nx">z2</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">z</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">z</span><span class="p">;</span>
        <span class="kd">const</span> <span class="nx">xx</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">*</span> <span class="nx">x2</span><span class="p">,</span> <span class="nx">xy</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">*</span> <span class="nx">y2</span><span class="p">,</span> <span class="nx">xz</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">*</span> <span class="nx">z2</span><span class="p">;</span>
        <span class="kd">const</span> <span class="nx">yy</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">y</span> <span class="o">*</span> <span class="nx">y2</span><span class="p">,</span> <span class="nx">yz</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">y</span> <span class="o">*</span> <span class="nx">z2</span><span class="p">,</span> <span class="nx">zz</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">z</span> <span class="o">*</span> <span class="nx">z2</span><span class="p">;</span>
        <span class="kd">const</span> <span class="nx">wx</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">w</span> <span class="o">*</span> <span class="nx">x2</span><span class="p">,</span> <span class="nx">wy</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">w</span> <span class="o">*</span> <span class="nx">y2</span><span class="p">,</span> <span class="nx">wz</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">w</span> <span class="o">*</span> <span class="nx">z2</span><span class="p">;</span>
        
        <span class="k">return</span> <span class="p">[</span>
            <span class="mi">1</span><span class="o">-</span><span class="p">(</span><span class="nx">yy</span><span class="o">+</span><span class="nx">zz</span><span class="p">),</span> <span class="nx">xy</span><span class="o">-</span><span class="nx">wz</span><span class="p">,</span>     <span class="nx">xz</span><span class="o">+</span><span class="nx">wy</span><span class="p">,</span>     <span class="mi">0</span><span class="p">,</span>
            <span class="nx">xy</span><span class="o">+</span><span class="nx">wz</span><span class="p">,</span>     <span class="mi">1</span><span class="o">-</span><span class="p">(</span><span class="nx">xx</span><span class="o">+</span><span class="nx">zz</span><span class="p">),</span> <span class="nx">yz</span><span class="o">-</span><span class="nx">wx</span><span class="p">,</span>     <span class="mi">0</span><span class="p">,</span>
            <span class="nx">xz</span><span class="o">-</span><span class="nx">wy</span><span class="p">,</span>     <span class="nx">yz</span><span class="o">+</span><span class="nx">wx</span><span class="p">,</span>     <span class="mi">1</span><span class="o">-</span><span class="p">(</span><span class="nx">xx</span><span class="o">+</span><span class="nx">yy</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
            <span class="mi">0</span><span class="p">,</span>         <span class="mi">0</span><span class="p">,</span>         <span class="mi">0</span><span class="p">,</span>         <span class="mi">1</span>
        <span class="p">];</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="safe-slerp-implementation">Safe SLERP Implementation</h3> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">safeSlerp</span><span class="p">(</span><span class="nx">q1</span><span class="p">,</span> <span class="nx">q2</span><span class="p">,</span> <span class="nx">t</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// IMPORTANT: Handle the double cover - choose shorter path</span>
    <span class="kd">let</span> <span class="nx">dot</span> <span class="o">=</span> <span class="nx">q1</span><span class="p">.</span><span class="nx">x</span><span class="o">*</span><span class="nx">q2</span><span class="p">.</span><span class="nx">x</span> <span class="o">+</span> <span class="nx">q1</span><span class="p">.</span><span class="nx">y</span><span class="o">*</span><span class="nx">q2</span><span class="p">.</span><span class="nx">y</span> <span class="o">+</span> <span class="nx">q1</span><span class="p">.</span><span class="nx">z</span><span class="o">*</span><span class="nx">q2</span><span class="p">.</span><span class="nx">z</span> <span class="o">+</span> <span class="nx">q1</span><span class="p">.</span><span class="nx">w</span><span class="o">*</span><span class="nx">q2</span><span class="p">.</span><span class="nx">w</span><span class="p">;</span>
    
    <span class="c1">// If dot &lt; 0, quaternions are on opposite hemispheres</span>
    <span class="c1">// Negate one quaternion to take the shorter path</span>
    <span class="k">if </span><span class="p">(</span><span class="nx">dot</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">q2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Quaternion</span><span class="p">(</span><span class="o">-</span><span class="nx">q2</span><span class="p">.</span><span class="nx">x</span><span class="p">,</span> <span class="o">-</span><span class="nx">q2</span><span class="p">.</span><span class="nx">y</span><span class="p">,</span> <span class="o">-</span><span class="nx">q2</span><span class="p">.</span><span class="nx">z</span><span class="p">,</span> <span class="o">-</span><span class="nx">q2</span><span class="p">.</span><span class="nx">w</span><span class="p">);</span>
        <span class="nx">dot</span> <span class="o">=</span> <span class="o">-</span><span class="nx">dot</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="c1">// Clamp dot to avoid numerical issues</span>
    <span class="nx">dot</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">min</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nf">max</span><span class="p">(</span><span class="nx">dot</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="mi">1</span><span class="p">);</span>
    
    <span class="c1">// Use linear interpolation for very close quaternions</span>
    <span class="k">if </span><span class="p">(</span><span class="nx">dot</span> <span class="o">&gt;</span> <span class="mf">0.9995</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nc">Quaternion</span><span class="p">(</span>
            <span class="nx">q1</span><span class="p">.</span><span class="nx">x</span> <span class="o">+</span> <span class="nx">t</span> <span class="o">*</span> <span class="p">(</span><span class="nx">q2</span><span class="p">.</span><span class="nx">x</span> <span class="o">-</span> <span class="nx">q1</span><span class="p">.</span><span class="nx">x</span><span class="p">),</span>
            <span class="nx">q1</span><span class="p">.</span><span class="nx">y</span> <span class="o">+</span> <span class="nx">t</span> <span class="o">*</span> <span class="p">(</span><span class="nx">q2</span><span class="p">.</span><span class="nx">y</span> <span class="o">-</span> <span class="nx">q1</span><span class="p">.</span><span class="nx">y</span><span class="p">),</span>
            <span class="nx">q1</span><span class="p">.</span><span class="nx">z</span> <span class="o">+</span> <span class="nx">t</span> <span class="o">*</span> <span class="p">(</span><span class="nx">q2</span><span class="p">.</span><span class="nx">z</span> <span class="o">-</span> <span class="nx">q1</span><span class="p">.</span><span class="nx">z</span><span class="p">),</span>
            <span class="nx">q1</span><span class="p">.</span><span class="nx">w</span> <span class="o">+</span> <span class="nx">t</span> <span class="o">*</span> <span class="p">(</span><span class="nx">q2</span><span class="p">.</span><span class="nx">w</span> <span class="o">-</span> <span class="nx">q1</span><span class="p">.</span><span class="nx">w</span><span class="p">)</span>
        <span class="p">).</span><span class="nf">normalize</span><span class="p">();</span>
    <span class="p">}</span>
    
    <span class="c1">// Standard SLERP</span>
    <span class="kd">const</span> <span class="nx">theta</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">acos</span><span class="p">(</span><span class="nx">dot</span><span class="p">);</span>
    <span class="kd">const</span> <span class="nx">sinTheta</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">sin</span><span class="p">(</span><span class="nx">theta</span><span class="p">);</span>
    <span class="kd">const</span> <span class="nx">scale1</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">sin</span><span class="p">((</span><span class="mi">1</span><span class="o">-</span><span class="nx">t</span><span class="p">)</span> <span class="o">*</span> <span class="nx">theta</span><span class="p">)</span> <span class="o">/</span> <span class="nx">sinTheta</span><span class="p">;</span>
    <span class="kd">const</span> <span class="nx">scale2</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">sin</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span> <span class="nx">theta</span><span class="p">)</span> <span class="o">/</span> <span class="nx">sinTheta</span><span class="p">;</span>
    
    <span class="k">return</span> <span class="k">new</span> <span class="nc">Quaternion</span><span class="p">(</span>
        <span class="nx">scale1</span> <span class="o">*</span> <span class="nx">q1</span><span class="p">.</span><span class="nx">x</span> <span class="o">+</span> <span class="nx">scale2</span> <span class="o">*</span> <span class="nx">q2</span><span class="p">.</span><span class="nx">x</span><span class="p">,</span>
        <span class="nx">scale1</span> <span class="o">*</span> <span class="nx">q1</span><span class="p">.</span><span class="nx">y</span> <span class="o">+</span> <span class="nx">scale2</span> <span class="o">*</span> <span class="nx">q2</span><span class="p">.</span><span class="nx">y</span><span class="p">,</span>
        <span class="nx">scale1</span> <span class="o">*</span> <span class="nx">q1</span><span class="p">.</span><span class="nx">z</span> <span class="o">+</span> <span class="nx">scale2</span> <span class="o">*</span> <span class="nx">q2</span><span class="p">.</span><span class="nx">z</span><span class="p">,</span>
        <span class="nx">scale1</span> <span class="o">*</span> <span class="nx">q1</span><span class="p">.</span><span class="nx">w</span> <span class="o">+</span> <span class="nx">scale2</span> <span class="o">*</span> <span class="nx">q2</span><span class="p">.</span><span class="nx">w</span>
    <span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="common-pitfalls-and-how-to-avoid-them">Common Pitfalls and How to Avoid Them</h3> <p><strong>1. Forgetting to Normalize</strong></p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// BAD: Quaternions drift over time</span>
<span class="kd">let</span> <span class="nx">rotation</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Quaternion</span><span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">);</span>
<span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">rotation</span> <span class="o">=</span> <span class="nx">rotation</span><span class="p">.</span><span class="nf">multiply</span><span class="p">(</span><span class="nx">deltaRotation</span><span class="p">);</span> <span class="c1">// Gets denormalized!</span>
<span class="p">}</span>

<span class="c1">// GOOD: Regular normalization</span>
<span class="kd">let</span> <span class="nx">rotation</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Quaternion</span><span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">);</span>
<span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">rotation</span> <span class="o">=</span> <span class="nx">rotation</span><span class="p">.</span><span class="nf">multiply</span><span class="p">(</span><span class="nx">deltaRotation</span><span class="p">).</span><span class="nf">normalize</span><span class="p">();</span> <span class="c1">// Stays unit length</span>
<span class="p">}</span>
</code></pre></div></div> <p><strong>2. Wrong Multiplication Order</strong></p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// WRONG: q1 * q2 means "apply q1, then q2"</span>
<span class="c1">// But many people think it means "apply q2, then q1"</span>
<span class="kd">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">rotation</span><span class="p">.</span><span class="nf">multiply</span><span class="p">(</span><span class="nx">deltaRotation</span><span class="p">);</span> <span class="c1">// Applies rotation first, then delta</span>

<span class="c1">// Always be explicit about what you mean:</span>
<span class="kd">const</span> <span class="nx">worldToLocal</span> <span class="o">=</span> <span class="nx">parentRotation</span><span class="p">.</span><span class="nf">multiply</span><span class="p">(</span><span class="nx">childRotation</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">localToWorld</span> <span class="o">=</span> <span class="nx">childRotation</span><span class="p">.</span><span class="nf">multiply</span><span class="p">(</span><span class="nx">parentRotation</span><span class="p">);</span>
</code></pre></div></div> <p><strong>3. Interpolating Through the Long Path</strong></p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// This can cause 340° rotation instead of 20°!</span>
<span class="kd">function</span> <span class="nf">badSlerp</span><span class="p">(</span><span class="nx">q1</span><span class="p">,</span> <span class="nx">q2</span><span class="p">,</span> <span class="nx">t</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Missing the dot product check - might take the long way around</span>
    <span class="k">return</span> <span class="nf">slerp</span><span class="p">(</span><span class="nx">q1</span><span class="p">,</span> <span class="nx">q2</span><span class="p">,</span> <span class="nx">t</span><span class="p">);</span> <span class="c1">// Could spin the wrong direction</span>
<span class="p">}</span>

<span class="c1">// Use safeSlerp() function above instead</span>
</code></pre></div></div> <h3 id="integration-with-graphics-apis">Integration with Graphics APIs</h3> <p><strong>WebGL/Three.js:</strong></p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Convert quaternion to Three.js format</span>
<span class="kd">const</span> <span class="nx">threeQuat</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">THREE</span><span class="p">.</span><span class="nc">Quaternion</span><span class="p">(</span><span class="nx">quat</span><span class="p">.</span><span class="nx">x</span><span class="p">,</span> <span class="nx">quat</span><span class="p">.</span><span class="nx">y</span><span class="p">,</span> <span class="nx">quat</span><span class="p">.</span><span class="nx">z</span><span class="p">,</span> <span class="nx">quat</span><span class="p">.</span><span class="nx">w</span><span class="p">);</span>
<span class="nx">mesh</span><span class="p">.</span><span class="nx">quaternion</span><span class="p">.</span><span class="nf">copy</span><span class="p">(</span><span class="nx">threeQuat</span><span class="p">);</span>
</code></pre></div></div> <p><strong>Unity C#:</strong></p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Unity has excellent quaternion support built-in</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">SmoothRotator</span> <span class="p">:</span> <span class="n">MonoBehaviour</span> <span class="p">{</span>
    <span class="k">public</span> <span class="kt">float</span> <span class="n">rotationSpeed</span> <span class="p">=</span> <span class="m">2.0f</span><span class="p">;</span>
    <span class="k">private</span> <span class="n">Quaternion</span> <span class="n">targetRotation</span><span class="p">;</span>
    
    <span class="k">void</span> <span class="nf">Update</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// Smooth rotation using Unity's Slerp</span>
        <span class="n">transform</span><span class="p">.</span><span class="n">rotation</span> <span class="p">=</span> <span class="n">Quaternion</span><span class="p">.</span><span class="nf">Slerp</span><span class="p">(</span>
            <span class="n">transform</span><span class="p">.</span><span class="n">rotation</span><span class="p">,</span>
            <span class="n">targetRotation</span><span class="p">,</span>
            <span class="n">rotationSpeed</span> <span class="p">*</span> <span class="n">Time</span><span class="p">.</span><span class="n">deltaTime</span>
        <span class="p">);</span>
    <span class="p">}</span>
    
    <span class="k">public</span> <span class="k">void</span> <span class="nf">SetTarget</span><span class="p">(</span><span class="n">Vector3</span> <span class="n">direction</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">targetRotation</span> <span class="p">=</span> <span class="n">Quaternion</span><span class="p">.</span><span class="nf">LookRotation</span><span class="p">(</span><span class="n">direction</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="performance-tips">Performance Tips</h3> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Cache expensive operations</span>
<span class="kd">class</span> <span class="nc">RotationCache</span> <span class="p">{</span>
    <span class="nf">constructor</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">cachedMatrix</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">quaternionDirty</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="nf">setRotation</span><span class="p">(</span><span class="nx">quat</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">rotation</span> <span class="o">=</span> <span class="nx">quat</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">quaternionDirty</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span> <span class="c1">// Mark matrix as needing recalculation</span>
    <span class="p">}</span>
    
    <span class="nf">getMatrix</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if </span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">quaternionDirty</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">cachedMatrix</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">rotation</span><span class="p">.</span><span class="nf">toMatrix</span><span class="p">();</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">quaternionDirty</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">cachedMatrix</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// For real-time applications, normalize only when needed</span>
<span class="kd">let</span> <span class="nx">normalizationCounter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kd">function</span> <span class="nf">updateRotation</span><span class="p">(</span><span class="nx">deltaQuat</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">rotation</span> <span class="o">=</span> <span class="nx">rotation</span><span class="p">.</span><span class="nf">multiply</span><span class="p">(</span><span class="nx">deltaQuat</span><span class="p">);</span>
    
    <span class="c1">// Normalize every 10 frames instead of every frame</span>
    <span class="k">if </span><span class="p">(</span><span class="o">++</span><span class="nx">normalizationCounter</span> <span class="o">%</span> <span class="mi">10</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">rotation</span><span class="p">.</span><span class="nf">normalize</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p><strong>The Golden Rule</strong>: Always work with quaternions internally, only convert to Euler angles for human-readable displays or legacy API compatibility. Never interpolate or integrate Euler angles directly!</p> <h2 id="geometric-and-topological-insights">Geometric and Topological Insights</h2> <p>The fundamental advantage of quaternions stems from their natural geometric properties:</p> <p><strong>Lie Group Structure</strong>: Unit quaternions form a Lie group isomorphic to $SU(2)$, with the exponential map providing a natural connection between the Lie algebra (3D angular velocity space) and the group manifold $(S^3)$.</p> <p><strong>Minimal Representation</strong>: While quaternions use four parameters to represent three degrees of freedom, this redundancy is precisely what eliminates singularities. The constraint $||q|| = 1$ reduces the effective dimensionality to three while maintaining global validity.</p> <p><strong>Geodesic Optimality</strong>: SLERP follows geodesics on $S^3$, which project to the shortest rotation paths in $SO(3)$. This ensures both mathematical optimality and physical realism in animation and control systems.</p> <h2 id="practical-applications-and-performance-considerations">Practical Applications and Performance Considerations</h2> <p>The mathematical superiority of quaternions translates directly into practical benefits:</p> <ul> <li> <strong>Robust Control Systems</strong>: Elimination of gimbal lock enables reliable attitude control in aerospace applications</li> <li> <strong>Smooth Animation</strong>: Constant angular velocity interpolation produces natural-looking rotations in computer graphics</li> <li> <strong>Numerical Stability</strong>: Better conditioning of rotation operations reduces accumulation of numerical errors</li> <li> <strong>Compact Representation</strong>: Four parameters vs. nine for rotation matrices, with inherent orthogonality constraints</li> </ul> <h2 id="conclusion-mathematical-rigor-in-computational-practice">Conclusion: Mathematical Rigor in Computational Practice</h2> <p>The choice between Euler angles and quaternions is not merely one of computational convenience—it reflects a deeper understanding of the mathematical structure underlying 3D rotations. While Euler angles offer intuitive parameterization for human interfaces, quaternions provide the mathematically principled foundation necessary for robust computational systems.</p> <p>The interactive visualizations demonstrate these theoretical principles through direct manipulation, revealing how mathematical abstractions manifest as concrete computational behaviors. This convergence of theory and practice exemplifies the power of choosing representations that align with the underlying mathematical reality.</p> <hr> <p><em>Explore the interactive mathematical demonstrations above to develop geometric intuition for these abstract concepts.</em></p> <meta charset="UTF-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <title>3D Rotations: Understanding Gimbal Lock</title> <style>body{margin:0;padding:20px;font-family:'Segoe UI',system-ui,sans-serif;background:linear-gradient(135deg,#0f0f23 0%,#1a1a2e 50%,#16213e 100%);color:#e0e0e0;min-height:100vh}.container{max-width:1400px;margin:0 auto}.header{text-align:center;margin-bottom:30px}.header h1{font-size:2.5rem;background:linear-gradient(135deg,#64ffda,#7c4dff);-webkit-background-clip:text;-webkit-text-fill-color:transparent;margin-bottom:10px}.header p{font-size:1.1rem;opacity:.8;max-width:800px;margin:0 auto}.visualization-grid{display:grid;grid-template-columns:1fr 1fr;gap:20px;margin-bottom:30px}.wide-panel{grid-column:1 / -1}.panel{background:rgba(255,255,255,0.05);backdrop-filter:blur(10px);border-radius:15px;border:1px solid rgba(255,255,255,0.1);padding:20px;position:relative;overflow:hidden}.panel h3{margin:0 0 15px 0;font-size:1.3rem;color:#64ffda;display:flex;align-items:center;gap:10px}.canvas-container{position:relative;width:100%;height:400px;border-radius:10px;overflow:hidden;background:#000}canvas{display:block;width:100%;height:100%}.controls{margin-top:15px;display:grid;grid-template-columns:repeat(auto-fit,minmax(200px,1fr));gap:15px}.control-group{display:flex;flex-direction:column;gap:8px}.control-group label{font-size:.9rem;color:#b0b0b0;font-weight:500}.slider{-webkit-appearance:none;appearance:none;width:100%;height:6px;border-radius:3px;background:rgba(255,255,255,0.1);outline:0}.slider::-webkit-slider-thumb{-webkit-appearance:none;appearance:none;width:18px;height:18px;border-radius:50%;background:#64ffda;cursor:pointer;box-shadow:0 0 10px rgba(100,255,218,0.3)}.value-display{font-family:'Courier New',monospace;color:#64ffda;font-weight:bold}.warning{background:rgba(255,107,107,0.15);border:1px solid rgba(255,107,107,0.3);border-radius:8px;padding:12px;margin-top:10px;color:#ff6b6b;font-weight:bold;display:none}.warning.active{display:block;animation:pulse 1s ease-in-out infinite alternate}@keyframes pulse{from{opacity:.7}to{opacity:1}}.button{background:linear-gradient(135deg,#7c4dff,#536dfe);border:0;border-radius:8px;padding:10px 20px;color:white;font-weight:bold;cursor:pointer;transition:all .3s ease}.button:hover{transform:translateY(-2px);box-shadow:0 5px 15px rgba(124,77,255,0.4)}.info-box{background:rgba(100,255,218,0.1);border:1px solid rgba(100,255,218,0.3);border-radius:8px;padding:15px;margin-top:15px;font-size:.9rem;line-height:1.5}.quaternion-display{display:grid;grid-template-columns:repeat(4,1fr);gap:10px;margin-top:10px}.quat-component{text-align:center;padding:8px;background:rgba(255,255,255,0.05);border-radius:6px;font-family:'Courier New',monospace}.quat-component .label{font-size:.8rem;opacity:.7;margin-bottom:4px}.quat-component .value{font-weight:bold;color:#64ffda}.hopf-info-panel{background:rgba(100,255,218,0.1);border:1px solid rgba(100,255,218,0.3);border-radius:8px;padding:15px;margin:10px 0;font-size:.9rem;line-height:1.5}.hopf-info-panel h4{margin:0 0 10px 0;font-size:1.1rem;color:#64ffda}.hopf-info-panel p{margin:5px 0;color:#e0e0e0}</style> <div class="container"> </div> <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/TrackballControls.js"></script> <script>function createHopfBaseSphere(){const e=new THREE.SphereGeometry(hopfParams.baseSphereSize,32,32),t=new THREE.MeshPhongMaterial({color:2201331,transparent:!0,opacity:.3,wireframe:!1});hopfBaseSphere&&hopfScene.remove(hopfBaseSphere),hopfBaseSphere=new THREE.Mesh(e,t),hopfScene.add(hopfBaseSphere);const n=new THREE.SphereGeometry(hopfParams.baseSphereSize,16,16),o=new THREE.MeshBasicMaterial({color:4890367,wireframe:!0,transparent:!0,opacity:.6}),a=new THREE.Mesh(n,o);hopfBaseSphere.add(a)}function createHopfFibers(){hopfFibers.forEach(e=>{hopfScene.remove(e),e.geometry&&e.geometry.dispose(),e.material&&e.material.dispose()}),hopfFibers=[];const e=hopfParams.fiberCount;for(let t=0;t<e;t++){const n=t/e*Math.PI;for(let o=0;o<e;o++){const a=o/e*2*Math.PI,r=createHopfFiberCurve({x:Math.sin(n)*Math.cos(a),y:Math.sin(n)*Math.sin(a),z:Math.cos(n)},t,o);hopfScene.add(r),hopfFibers.push(r)}}}function createHopfFiberCurve(e,t,n){const o=[],a=64;for(let t=0;t<=a;t++){const n=stereographicProjectionHopf(hopfFibrationMapping(e,t/a*2*Math.PI+hopfParams.animationPhase));o.push(new THREE.Vector3(n.x,n.y,n.z))}const r=new THREE.CatmullRomCurve3(o,!0),i=new THREE.TubeGeometry(r,a,.02,8,!0),s=.5*(t/hopfParams.fiberCount+n/hopfParams.fiberCount),l=(new THREE.Color).setHSL(s,.8,.6),d=new THREE.MeshPhongMaterial({color:l,transparent:!0,opacity:.8,emissive:l,emissiveIntensity:.2});return new THREE.Mesh(i,d)}function hopfFibrationMapping(e,t){const{x:n,y:o,z:a}=e;return{x:Math.sqrt((1+a)/2)*Math.cos(t),y:Math.sqrt((1+a)/2)*Math.sin(t),z:Math.sqrt((1-a)/2)*Math.cos(Math.atan2(o,n)+t),w:Math.sqrt((1-a)/2)*Math.sin(Math.atan2(o,n)+t)}}function stereographicProjectionHopf(e){const{x:t,y:n,z:o,w:a}=e,r=1-a;if(Math.abs(r)<.001)return{x:0,y:0,z:0};const i=2;return{x:i*t/r,y:i*n/r,z:i*o/r}}function setupHopfMouseControls(){let e=!1,t=0,n=0,o=8,a=0,r=Math.PI/4;hopfRenderer.domElement.addEventListener("mousedown",o=>{e=!0,t=o.clientX,n=o.clientY}),hopfRenderer.domElement.addEventListener("mouseup",()=>{e=!1}),hopfRenderer.domElement.addEventListener("mousemove",i=>{if(!e)return;const s=i.clientX-t,l=i.clientY-n;a-=.01*s,r=Math.max(.1,Math.min(Math.PI-.1,r+.01*l)),hopfCamera.position.x=o*Math.sin(r)*Math.cos(a),hopfCamera.position.y=o*Math.cos(r),hopfCamera.position.z=o*Math.sin(r)*Math.sin(a),hopfCamera.lookAt(0,0,0),t=i.clientX,n=i.clientY}),hopfRenderer.domElement.addEventListener("wheel",e=>{o=Math.max(2,Math.min(20,o+.01*e.deltaY)),hopfCamera.position.x=o*Math.sin(r)*Math.cos(a),hopfCamera.position.y=o*Math.cos(r),hopfCamera.position.z=o*Math.sin(r)*Math.sin(a),hopfCamera.lookAt(0,0,0),e.preventDefault()})}function animateHopfFibration(){if(hopfAnimationId=requestAnimationFrame(animateHopfFibration),hopfIsAnimating){hopfTime+=.01*hopfParams.rotationSpeed,hopfScene.rotation.y=.3*hopfTime,hopfParams.animationPhase=2*hopfTime;const e=document.getElementById("hopfAnimationPhase"),t=document.getElementById("hopfAnimationPhaseValue");e&&t&&(e.value=hopfParams.animationPhase%(2*Math.PI),t.textContent=(hopfParams.animationPhase%(2*Math.PI)).toFixed(2)),Math.floor(60*hopfTime)%3==0&&createHopfFibers()}hopfRenderer.render(hopfScene,hopfCamera)}const MATH_EPSILON=1e-15,QUATERNION_TOLERANCE=1e-12,GEODESIC_RESOLUTION=100,ANTIPODAL_THRESHOLD=.999999,mathAnalysis={unitConstraintViolations:[],geodesicErrors:[],singularityDetections:[],temporalCoherence:[],projectionErrors:[],frameCount:0},qNorm=([e,t,n,o])=>{const a=e*e+t*t+n*n+o*o,r=Math.sqrt(a),i=Math.abs(r-1);if(i>QUATERNION_TOLERANCE&&mathAnalysis.unitConstraintViolations.push({frame:mathAnalysis.frameCount,originalNorm:r,error:i,quaternion:[e,t,n,o]}),r<MATH_EPSILON)return console.warn("Mathematical Analysis: Degenerate quaternion detected, defaulting to identity"),[0,0,0,1];const s=1/r,l=[e*s,t*s,n*s,o*s],d=Math.sqrt(l[0]*l[0]+l[1]*l[1]+l[2]*l[2]+l[3]*l[3]),c=Math.abs(d-1);return c>QUATERNION_TOLERANCE&&console.error("Mathematical Analysis: Post-normalization error:",c),l},qMul=([e,t,n,o],[a,r,i,s])=>{const l=[o*a+e*s+t*i-n*r,o*r-e*i+t*s+n*a,o*i+e*r-t*a+n*s,o*s-e*a-t*r-n*i],d=Math.sqrt(e*e+t*t+n*n+o*o),c=Math.sqrt(a*a+r*r+i*i+s*s),h=Math.sqrt(l[0]*l[0]+l[1]*l[1]+l[2]*l[2]+l[3]*l[3]),u=d*c,m=Math.abs(h-u);return m>QUATERNION_TOLERANCE&&console.warn("Mathematical Analysis: Quaternion multiplication norm error:",m),l},qFromAxisAngle=([e,t,n],o)=>{const a=Math.sin(o/2);return qNorm([e*a,t*a,n*a,Math.cos(o/2)])},qFromEulerZYX=(e,t,n)=>{const o=Math.cos(e/2),a=Math.sin(e/2),r=Math.cos(t/2),i=Math.sin(t/2),s=Math.cos(n/2),l=Math.sin(n/2);return qNorm([l*r*o-s*i*a,s*i*o+l*r*a,s*r*a-l*i*o,s*r*o+l*i*a])},geodesicDistance=(e,t)=>{let n=Math.abs(e[0]*t[0]+e[1]*t[1]+e[2]*t[2]+e[3]*t[3]);return n=Math.min(1,Math.max(-1,n)),Math.acos(n)},analyzeAntipodalPoints=e=>{const[t,n,o,a]=e,r=[-t,-n,-o,-a],i=qToMatrix(e),s=qToMatrix(r);let l=0;for(let e=0;e<16;e++){const t=Math.abs(i[e]-s[e]);l=Math.max(l,t)}const d=t*-t+n*-n+o*-o+a*-a,c=Math.min(1,Math.max(-1,d)),h=Math.acos(c),u=Math.PI,m=Math.abs(h-u);return{q:e,antipodal:r,geodesicDistance:h,geodesicError:m,dotProduct:d,dotProductError:Math.abs(d- -1),rotationMatrixError:l,isValidAntipodal:m<100*QUATERNION_TOLERANCE&&l<10*QUATERNION_TOLERANCE}},qSlerp=(e,t,n)=>{(n<0||n>1)&&console.warn("Mathematical Analysis: SLERP parameter t outside [0,1]:",n);const o=qNorm(e),a=qNorm(t);let[r,i,s,l]=o,[d,c,h,u]=a,m=r*d+i*c+s*h+l*u;const p=m;m<0&&(m=-m,d=-d,c=-c,h=-h,u=-u);const E=Math.acos(Math.min(1,Math.abs(p)));if(mathAnalysis.geodesicErrors.push({frame:mathAnalysis.frameCount,geodesicAngle:E,dotProduct:p,shortestPath:m>Math.abs(p)}),m>.9995){const e=qNorm([r+n*(d-r),i+n*(c-i),s+n*(h-s),l+n*(u-l)]),t=qSlerp(o,a,.5),m=geodesicDistance(o,t),p=geodesicDistance(t,a),E=Math.abs(m-p);return E>QUATERNION_TOLERANCE&&console.warn("Mathematical Analysis: SLERP velocity consistency error:",E),e}if(m<.001){console.log("Mathematical Analysis: Handling antipodal quaternions with non-recursive method");const e=qNorm([r+n*(d-r),i+n*(c-i),s+n*(h-s),l+n*(u-l)]);return mathAnalysis.geodesicErrors.push({frame:mathAnalysis.frameCount,type:"antipodal-nlerp-fallback",t:n,originalDot:p,message:"Used NLERP for antipodal quaternions to avoid recursion"}),e}const f=Math.acos(Math.min(1,m)),g=Math.sin(f);if(Math.abs(g)<MATH_EPSILON)return console.warn("Mathematical Analysis: SLERP numerical instability detected"),qNorm([r+n*(d-r),i+n*(c-i),s+n*(h-s),l+n*(u-l)]);const y=Math.sin((1-n)*f)/g,M=Math.sin(n*f)/g,S=[r*y+d*M,i*y+c*M,s*y+h*M,l*y+u*M],T=Math.sqrt(S[0]*S[0]+S[1]*S[1]+S[2]*S[2]+S[3]*S[3]),w=Math.abs(T-1);if(w>QUATERNION_TOLERANCE&&console.warn("Mathematical Analysis: SLERP result not on unit sphere:",w),n>0&&n<1){const e=geodesicDistance(o,a),t=geodesicDistance(o,S),r=n*e,i=Math.abs(t-r);i>10*QUATERNION_TOLERANCE&&mathAnalysis.geodesicErrors.push({frame:mathAnalysis.frameCount,t:n,geodesicLinearityError:i,distTotal:e,distPartial:t})}return S},qToMatrix=([e,t,n,o])=>{const a=e*e,r=t*t,i=n*n,s=e*t,l=e*n,d=e*o,c=t*n,h=t*o,u=n*o;return[1-2*(r+i),2*(s-u),2*(l+h),0,2*(s+u),1-2*(a+i),2*(c-d),0,2*(l-h),2*(c+d),1-2*(a+r),0,0,0,0,1]},qToEulerZYX=([e,t,n,o])=>{const a=2*(o*e+t*n),r=1-2*(e*e+t*t),i=Math.atan2(a,r),s=2*(o*t-n*e),l=Math.abs(s)>=1?Math.sign(s)*Math.PI/2:Math.asin(s),d=2*(o*n+e*t),c=1-2*(t*t+n*n);return[Math.atan2(d,c),l,i]},qConj=([e,t,n,o])=>{const a=[-e,-t,-n,o],r=Math.sqrt(e*e+t*t+n*n+o*o),i=Math.sqrt(e*e+t*t+n*n+o*o),s=Math.abs(r-i);return s>QUATERNION_TOLERANCE&&console.warn("Mathematical Analysis: Conjugate norm error:",s),a},qDot=(e,t)=>{const n=e[0]*t[0]+e[1]*t[1]+e[2]*t[2]+e[3]*t[3];return Math.abs(n)>1+QUATERNION_TOLERANCE&&console.warn("Mathematical Analysis: Dot product outside [-1,1]:",n),n},qToAxisAngle=([e,t,n,o])=>{let a=e,r=t,i=n,s=o;o<0&&(a=-e,r=-t,i=-n,s=-o);const l=2*Math.acos(Math.min(1,Math.max(-1,s)));if(Math.abs(l)<MATH_EPSILON)return[[1,0,0],0];const d=Math.sin(l/2);if(Math.abs(d)<MATH_EPSILON)return mathAnalysis.singularityDetections.push({frame:mathAnalysis.frameCount,type:"axis-angle-extraction",quaternion:[e,t,n,o],angle:l,sinHalfAngle:d}),[[1,0,0],l];let c=[a/d,r/d,i/d];const h=Math.sqrt(c[0]*c[0]+c[1]*c[1]+c[2]*c[2]);h>MATH_EPSILON&&(c=[c[0]/h,c[1]/h,c[2]/h]);const u=Math.abs(h-1);return u>10*QUATERNION_TOLERANCE&&console.warn("Mathematical Analysis: Non-unit rotation axis:",u),[c,l]},verifyDoubleCover=e=>{const[t,n,o,a]=e,r=[-t,-n,-o,-a],i=qToMatrix(e),s=qToMatrix(r);let l=0;for(let e=0;e<16;e++){const t=i[e]-s[e];l+=t*t}l=Math.sqrt(l);const d=l;return d>QUATERNION_TOLERANCE&&(console.error("Mathematical Analysis: Double cover violation:",d),mathAnalysis.geodesicErrors.push({frame:mathAnalysis.frameCount,type:"double-cover-violation",error:d,quaternion:e})),{isValid:d<QUATERNION_TOLERANCE,error:d,rotationMatrix1:i,rotationMatrix2:s}},verifySO3Properties=e=>{const t=e,n=[];for(let e=0;e<3;e++)for(let o=0;o<3;o++){let a=0;for(let n=0;n<3;n++)a+=t[4*n+e]*t[4*n+o];n[3*e+o]=a}let o=0;for(let e=0;e<3;e++)for(let t=0;t<3;t++){const a=e===t?1:0,r=Math.abs(n[3*e+t]-a);o=Math.max(o,r)}const a=t[0]*(t[5]*t[10]-t[6]*t[9])-t[1]*(t[4]*t[10]-t[6]*t[8])+t[2]*(t[4]*t[9]-t[5]*t[8]),r=Math.abs(a-1);return{isValidSO3:o<QUATERNION_TOLERANCE&&r<QUATERNION_TOLERANCE,orthogonalityError:o,determinantError:r,determinant:a}},stereographicProjection=(e,t="north")=>{const[n,o,a,r]=qNorm(e);let i,s,l=0;if("north"===t)if(Math.abs(1-r)<MATH_EPSILON){const e=2/(1+MATH_EPSILON);i=n*e,s=o*e,l=MATH_EPSILON}else{const t=1-r;i=n/t,s=o/t,Math.abs(t)<QUATERNION_TOLERANCE&&(l=Math.abs(t),mathAnalysis.projectionErrors.push({frame:mathAnalysis.frameCount,type:"stereographic-singularity",quaternion:e,denominator:t,error:l}))}else if(Math.abs(1+r)<MATH_EPSILON){const e=2/(1+MATH_EPSILON);i=n*e,s=o*e,l=MATH_EPSILON}else{const e=1+r;i=n/e,s=o/e,Math.abs(e)<QUATERNION_TOLERANCE&&(l=Math.abs(e))}return{x:i,y:s,error:l,isValid:l<QUATERNION_TOLERANCE}},analyzeTemporalCoherence=(e,t,n)=>{if(!t)return null;const o=qNorm(e),a=qNorm(t),r=qMul(o,qConj(a)),[i,s]=qToAxisAngle(r),l=s/n,d=[-o[0],-o[1],-o[2],-o[3]],c=[-a[0],-a[1],-a[2],-a[3]],h=qMul(d,qConj(c)),[u,m]=qToAxisAngle(h),p=m/n,E=Math.abs(l-p),f=Math.acos(Math.min(1,Math.abs(i[0]*u[0]+i[1]*u[1]+i[2]*u[2]))),g={frame:mathAnalysis.frameCount,angularVelocity:l,antipodalAngularVelocity:p,velocityCoherenceError:E,axisCoherenceError:f,isCoherent:E<QUATERNION_TOLERANCE&&f<QUATERNION_TOLERANCE};return mathAnalysis.temporalCoherence.push(g),g};let heatmapCtx,slerpVelocityCtx,slerpScene,slerpCamera,slerpRenderer,slerpControls,slerpSphere,slerpPathLine,eulerPathLine,slerpCurrentPoint,eulerCurrentPoint,currentQuaternion=[0,0,0,1],sphereQuaternion=[0,0,0,1],sphereEuler=[0,0,0],showAntipodes=!1,showGeodesicArc=!1,animating=!1,quaternionHistory=[[0,0,0,1]],frameCount=0,showTorusView=!0,updatingFromSlider=!1;const deg2rad=e=>e*Math.PI/180,rad2deg=e=>180*e/Math.PI,resizeCanvases=()=>{[document.getElementById("quaternionCanvas"),document.getElementById("heatmapCanvas"),document.getElementById("slerpVelocityCanvas")].forEach(e=>{if(e){const t=e.parentElement.getBoundingClientRect();e.width=t.width*window.devicePixelRatio,e.height=t.height*window.devicePixelRatio,e.style.width=t.width+"px",e.style.height=t.height+"px";const n=e.getContext("2d");n&&n.scale(window.devicePixelRatio,window.devicePixelRatio)}})};let scene,camera,renderer,controls,centerSphere,quaternionScene,quaternionCamera,quaternionRenderer,quaternionControls,quaternionSphere,quaternionPoint,antipodalPoint,geodesicCurve,gimbalRings=[],coordinateAxes=[];const initThreeJS=()=>{const e=document.getElementById("gimbalCanvas"),t=e.clientWidth,n=e.clientHeight;scene=new THREE.Scene,scene.background=new THREE.Color(0),camera=new THREE.PerspectiveCamera(75,t/n,.1,1e3),camera.position.set(3,2,4),renderer=new THREE.WebGLRenderer({canvas:e,antialias:!0}),renderer.setSize(t,n),renderer.setPixelRatio(window.devicePixelRatio),renderer.shadowMap.enabled=!0,renderer.shadowMap.type=THREE.PCFSoftShadowMap,controls=new THREE.TrackballControls(camera,renderer.domElement),controls.rotateSpeed=1.5,controls.zoomSpeed=1.2,controls.panSpeed=.8,controls.noZoom=!1,controls.noPan=!1,controls.staticMoving=!0,controls.dynamicDampingFactor=.3,controls.keys=[65,83,68],controls.minDistance=2,controls.maxDistance=8;const o=new THREE.AmbientLight(4210752,.4);scene.add(o);const a=new THREE.DirectionalLight(16777215,.8);a.position.set(5,5,5),a.castShadow=!0,a.shadow.mapSize.width=2048,a.shadow.mapSize.height=2048,scene.add(a);const r=new THREE.PointLight(6619098,.3,100);r.position.set(-3,3,-3),scene.add(r),createGimbalRings(),createCoordinateAxes(),createCenterSphere();const i=new THREE.GridHelper(4,20,3355443,1118481);i.position.y=-2,scene.add(i),animate()},createGimbalRings=()=>{const e=new THREE.Group,t=new THREE.Group,n=new THREE.Group;scene.add(e),e.add(t),t.add(n);[{radius:1.8,tube:.08,color:6619098,name:"yaw",group:e},{radius:1.4,tube:.06,color:5025616,name:"pitch",group:t},{radius:1,tube:.04,color:16750592,name:"roll",group:n}].forEach((e,t)=>{const n=new THREE.TorusGeometry(e.radius,e.tube,16,100);let o;o=0===t?new THREE.ShaderMaterial({uniforms:{color1:{value:new THREE.Color(6619098)},color2:{value:new THREE.Color(2001125)}},vertexShader:"\n                            varying vec3 vPosition;\n                            void main() {\n                                vPosition = position;\n                                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n                            }\n                        ",fragmentShader:"\n                            uniform vec3 color1;\n                            uniform vec3 color2;\n                            varying vec3 vPosition;\n                            void main() {\n                                float mixFactor = (atan(vPosition.y, vPosition.x) + 3.14159) / (2.0 * 3.14159);\n                                vec3 color = mix(color1, color2, mixFactor);\n                                gl_FragColor = vec4(color, 0.9);\n                            }\n                        ",transparent:!0}):new THREE.MeshPhongMaterial({color:e.color,shininess:100,transparent:!0,opacity:.8});const a=new THREE.Mesh(n,o);a.castShadow=!0,a.receiveShadow=!0,a.userData={name:e.name,originalColor:e.color,group:e.group},0===t||(1===t?a.rotation.x=Math.PI/2:2===t&&(a.rotation.z=Math.PI/2)),e.group.add(a),gimbalRings.push(a);const r=new THREE.SphereGeometry(.05,8,8),i=new THREE.MeshPhongMaterial({color:16777215,emissive:e.color,emissiveIntensity:.3}),s=0===t?8:4;for(let n=0;n<s;n++){const o=n/s*Math.PI*2,a=new THREE.Mesh(r,i);0===t?(a.position.set(e.radius*Math.cos(o),e.radius*Math.sin(o),0),0===n?(a.material=a.material.clone(),a.material.color.setHex(65535),a.material.emissive.setHex(65535),a.material.emissiveIntensity=.5,a.scale.set(1.5,1.5,1.5)):n===s/2&&(a.material=a.material.clone(),a.material.color.setHex(26214),a.material.emissive.setHex(13107))):1===t?a.position.set(e.radius*Math.cos(o),0,e.radius*Math.sin(o)):2===t&&a.position.set(0,e.radius*Math.cos(o),e.radius*Math.sin(o)),a.castShadow=!0,e.group.add(a)}if(0===t){const t=new THREE.BoxGeometry(.3*e.radius,.15,.15),n=new THREE.MeshPhongMaterial({color:65535,emissive:65535,emissiveIntensity:.3,shininess:100}),o=new THREE.Mesh(t,n);o.position.set(e.radius,0,0),o.castShadow=!0,e.group.add(o);const a=new THREE.Mesh(t,n.clone());a.material.color.setHex(16711935),a.material.emissive.setHex(16711935),a.position.set(-e.radius,0,0),a.castShadow=!0,e.group.add(a)}const l=new THREE.Group,d=0===t?.06:.03,c=0===t?.2:.12,h=new THREE.ConeGeometry(d,c,8),u=new THREE.MeshPhongMaterial({color:e.color,emissive:e.color,emissiveIntensity:.4}),m=new THREE.Mesh(h,u);if(0===t){m.position.set(e.radius+.25,0,0),m.rotation.z=-Math.PI/2;const t=new THREE.Mesh(h,u);t.position.set(-e.radius-.25,0,0),t.rotation.z=Math.PI/2,l.add(t);const n=document.createElement("canvas");n.width=128,n.height=64;const o=n.getContext("2d");o.fillStyle="#64ffda",o.font="bold 24px Arial",o.fillText("YAW",30,40);const a=new THREE.CanvasTexture(n),r=new THREE.SpriteMaterial({map:a,opacity:.8}),i=new THREE.Sprite(r);i.position.set(0,0,e.radius+.5),i.scale.set(.5,.25,1),e.group.add(i)}else 1===t?(m.position.set(e.radius+.15,0,0),m.rotation.y=Math.PI/2,m.rotation.z=-Math.PI/2):2===t&&(m.position.set(0,e.radius+.15,0),m.rotation.x=Math.PI/2);if(l.add(m),e.group.add(l),0===t){const t=new THREE.BufferGeometry,n=new Float32Array([0,0,-.5,0,0,.5]);t.setAttribute("position",new THREE.BufferAttribute(n,3));const o=new THREE.LineBasicMaterial({color:6619098,linewidth:3,opacity:.5,transparent:!0}),a=new THREE.Line(t,o);e.group.add(a)}}),gimbalRings.yawGroup=e,gimbalRings.pitchGroup=t,gimbalRings.rollGroup=n},createCoordinateAxes=()=>{const e=1.5;[{color:16729156,direction:new THREE.Vector3(1,0,0),label:"X"},{color:4521796,direction:new THREE.Vector3(0,1,0),label:"Y"},{color:4474111,direction:new THREE.Vector3(0,0,1),label:"Z"}].forEach(t=>{const n=new THREE.ArrowHelper(t.direction,new THREE.Vector3(0,0,0),e,t.color,.2,.1);n.line.material.linewidth=3,scene.add(n),coordinateAxes.push(n)})},createCenterSphere=()=>{const e=new THREE.SphereGeometry(.05,32,32),t=new THREE.MeshPhongMaterial({color:16777215,shininess:100,emissive:2236962});centerSphere=new THREE.Mesh(e,t),centerSphere.castShadow=!0,scene.add(centerSphere)},updateGimbalFromSliders=()=>{const e=deg2rad(parseFloat(document.getElementById("yawSlider").value)),t=deg2rad(parseFloat(document.getElementById("pitchSlider").value)),n=deg2rad(parseFloat(document.getElementById("rollSlider").value)),o=Math.abs(Math.cos(t))<.15;if(gimbalRings.yawGroup&&gimbalRings.pitchGroup&&gimbalRings.rollGroup){gimbalRings.yawGroup.rotation.z=e,gimbalRings.pitchGroup.rotation.y=t,gimbalRings.rollGroup.rotation.x=n,gimbalRings.forEach(e=>{e.material.color?(e.material.color.setHex(o?16739179:e.userData.originalColor),e.material.emissive.setHex(o?2228224:0)):e.material.uniforms&&(o?(e.material.uniforms.color1.value.setHex(16739179),e.material.uniforms.color2.value.setHex(16729156)):(e.material.uniforms.color1.value.setHex(6619098),e.material.uniforms.color2.value.setHex(2001125)))});const a=document.getElementById("rollSlider");a&&o?(a.style.borderColor="#ff6b6b",a.style.boxShadow="0 0 5px rgba(255, 107, 107, 0.5)"):a&&(a.style.borderColor="",a.style.boxShadow="")}coordinateAxes.length>=3&&gimbalRings.rollGroup&&coordinateAxes.forEach(e=>{e.parent!==gimbalRings.rollGroup&&(e.parent&&e.parent.remove(e),gimbalRings.rollGroup.add(e))}),document.getElementById("gimbalWarning").classList.toggle("active",o)},animate=()=>{requestAnimationFrame(animate),controls.update(),renderer.render(scene,camera)},resizeThreeJS=()=>{const e=document.getElementById("gimbalCanvas"),t=e.clientWidth,n=e.clientHeight;camera.aspect=t/n,camera.updateProjectionMatrix(),renderer.setSize(t,n)},drawGimbal=()=>{renderer&&(updateGimbalFromSliders(),updateQuaternionSphere3D())},initQuaternionSphere3D=()=>{const e=document.getElementById("quaternionCanvas"),t=e.clientWidth,n=e.clientHeight;quaternionScene=new THREE.Scene,quaternionScene.background=new THREE.Color(17),quaternionCamera=new THREE.PerspectiveCamera(75,t/n,.1,1e3),quaternionCamera.position.set(2.5,1.5,3),quaternionRenderer=new THREE.WebGLRenderer({canvas:e,antialias:!0}),quaternionRenderer.setSize(t,n),quaternionRenderer.setPixelRatio(window.devicePixelRatio),quaternionRenderer.shadowMap.enabled=!0,quaternionRenderer.shadowMap.type=THREE.PCFSoftShadowMap,quaternionControls=new THREE.TrackballControls(quaternionCamera,quaternionRenderer.domElement),quaternionControls.rotateSpeed=1,quaternionControls.zoomSpeed=1.2,quaternionControls.panSpeed=.8,quaternionControls.noZoom=!1,quaternionControls.noPan=!1,quaternionControls.staticMoving=!0,quaternionControls.dynamicDampingFactor=.3,quaternionControls.minDistance=1.5,quaternionControls.maxDistance=6;const o=new THREE.AmbientLight(4210752,.6);quaternionScene.add(o);const a=new THREE.DirectionalLight(6619098,.8);a.position.set(3,3,3),a.castShadow=!0,quaternionScene.add(a);const r=new THREE.PointLight(8146431,.4,100);r.position.set(-2,2,-2),quaternionScene.add(r);const i=new THREE.SphereGeometry(1,32,32),s=new THREE.MeshPhongMaterial({color:11184810,wireframe:!0,transparent:!0,opacity:.6});quaternionSphere=new THREE.Mesh(i,s),quaternionScene.add(quaternionSphere);const l=new THREE.MeshPhongMaterial({color:1118515,transparent:!0,opacity:.1}),d=new THREE.Mesh(i,l);quaternionScene.add(d);const c=new THREE.SphereGeometry(.05,16,16),h=new THREE.MeshPhongMaterial({color:6619098,emissive:6619098,emissiveIntensity:.3});quaternionPoint=new THREE.Mesh(c,h),quaternionScene.add(quaternionPoint);const u=new THREE.MeshPhongMaterial({color:16739179,emissive:16739179,emissiveIntensity:.3});antipodalPoint=new THREE.Mesh(c,u),antipodalPoint.visible=!1,quaternionScene.add(antipodalPoint);const m=1.3;[{color:16729156,direction:new THREE.Vector3(1,0,0),label:"X"},{color:4521796,direction:new THREE.Vector3(0,1,0),label:"Y"},{color:4474111,direction:new THREE.Vector3(0,0,1),label:"Z"}].forEach(e=>{const t=new THREE.ArrowHelper(e.direction,new THREE.Vector3(0,0,0),m,e.color,.1,.05);t.line.material.linewidth=2,quaternionScene.add(t)});const p=new THREE.GridHelper(2,10,3355443,1118481);p.position.y=-1.2,quaternionScene.add(p);const E=()=>{requestAnimationFrame(E),quaternionControls.update(),quaternionRenderer.render(quaternionScene,quaternionCamera)};E()};let hopfScene,hopfCamera,hopfRenderer,hopfBaseSphere,hopfAnimationId,hopfFibers=[],hopfIsAnimating=!0,hopfTime=0,hopfParams={rotationSpeed:.5,fiberCount:16,animationPhase:0,baseSphereSize:1};const initHopfFibration3D=()=>{const e=document.getElementById("hopfCanvas"),t=e.clientWidth,n=e.clientHeight;hopfScene=new THREE.Scene,hopfScene.background=new THREE.Color(0),hopfCamera=new THREE.PerspectiveCamera(75,t/n,.1,1e3),hopfCamera.position.set(5,3,5),hopfCamera.lookAt(0,0,0),hopfRenderer=new THREE.WebGLRenderer({canvas:e,antialias:!0}),hopfRenderer.setSize(t,n),hopfRenderer.setPixelRatio(window.devicePixelRatio),hopfRenderer.shadowMap.enabled=!0,hopfRenderer.shadowMap.type=THREE.PCFSoftShadowMap;const o=new THREE.AmbientLight(4210752,.3);hopfScene.add(o);const a=new THREE.DirectionalLight(16777215,.8);a.position.set(5,5,5),a.castShadow=!0,hopfScene.add(a);const r=new THREE.PointLight(4890367,.6);r.position.set(-5,3,2),hopfScene.add(r);const i=new THREE.PointLight(54527,.4);i.position.set(5,-3,-2),hopfScene.add(i),createHopfBaseSphere(),createHopfFibers(),setupHopfMouseControls(),animateHopfFibration()},resizeHopfVisualization=()=>{if(!hopfRenderer)return;const e=document.getElementById("hopfCanvas"),t=e.clientWidth,n=e.clientHeight;hopfCamera.aspect=t/n,hopfCamera.updateProjectionMatrix(),hopfRenderer.setSize(t,n)},updateQuaternionSphere3D=()=>{if(!quaternionScene||!quaternionPoint)return;const[e,t,n,o]=sphereQuaternion;let a=e,r=t,i=n+.3*o;const s=Math.sqrt(a*a+r*r+i*i);if(s>1e-10){const e=1/s;if(quaternionPoint.position.set(a*e,r*e,i*e),showAntipodes){antipodalPoint.visible=!0;let t=-a*e,n=-r*e,o=-i*e;antipodalPoint.position.set(t,n,o)}else antipodalPoint.visible=!1}else quaternionPoint.position.set(0,0,1),showAntipodes?(antipodalPoint.visible=!0,antipodalPoint.position.set(0,0,-1)):antipodalPoint.visible=!1;quaternionPoint.material.emissiveIntensity=.6,quaternionPoint.scale.setScalar(1),showAntipodes&&(antipodalPoint.material.emissiveIntensity=.6,antipodalPoint.scale.setScalar(1)),updateGeodesicArc3D(),document.getElementById("quatX").textContent=e.toFixed(6),document.getElementById("quatY").textContent=t.toFixed(6),document.getElementById("quatZ").textContent=n.toFixed(6),document.getElementById("quatW").textContent=o.toFixed(6),updatingFromSlider||(document.getElementById("quatXValue").textContent=e.toFixed(3),document.getElementById("quatYValue").textContent=t.toFixed(3),document.getElementById("quatZValue").textContent=n.toFixed(3),document.getElementById("quatWValue").textContent=o.toFixed(3),document.getElementById("quatXSlider").value=e,document.getElementById("quatYSlider").value=t,document.getElementById("quatZSlider").value=n,document.getElementById("quatWSlider").value=o)},updateSphereFromEuler=()=>{if(updatingFromSlider)return;updatingFromSlider=!0;const[e,t,n]=sphereEuler;sphereQuaternion=qNorm(qFromEulerZYX(e,t,n)),document.getElementById("sphereYawValue").textContent=`${rad2deg(e).toFixed(1)}\xb0`,document.getElementById("spherePitchValue").textContent=`${rad2deg(t).toFixed(1)}\xb0`,document.getElementById("sphereRollValue").textContent=`${rad2deg(n).toFixed(1)}\xb0`,document.getElementById("quatXSlider").value=sphereQuaternion[0],document.getElementById("quatYSlider").value=sphereQuaternion[1],document.getElementById("quatZSlider").value=sphereQuaternion[2],document.getElementById("quatWSlider").value=sphereQuaternion[3],document.getElementById("quatXValue").textContent=sphereQuaternion[0].toFixed(3),document.getElementById("quatYValue").textContent=sphereQuaternion[1].toFixed(3),document.getElementById("quatZValue").textContent=sphereQuaternion[2].toFixed(3),document.getElementById("quatWValue").textContent=sphereQuaternion[3].toFixed(3),updateQuaternionSphere3D(),updateHopfVisualization(),updatingFromSlider=!1},updateEulerFromSphere=()=>{updatingFromSlider||(updatingFromSlider=!0,sphereQuaternion=qNorm(sphereQuaternion),sphereEuler=qToEulerZYX(sphereQuaternion),document.getElementById("sphereYawSlider").value=rad2deg(sphereEuler[0]),document.getElementById("spherePitchSlider").value=rad2deg(sphereEuler[1]),document.getElementById("sphereRollSlider").value=rad2deg(sphereEuler[2]),document.getElementById("sphereYawValue").textContent=`${rad2deg(sphereEuler[0]).toFixed(1)}\xb0`,document.getElementById("spherePitchValue").textContent=`${rad2deg(sphereEuler[1]).toFixed(1)}\xb0`,document.getElementById("sphereRollValue").textContent=`${rad2deg(sphereEuler[2]).toFixed(1)}\xb0`,document.getElementById("quatXValue").textContent=sphereQuaternion[0].toFixed(3),document.getElementById("quatYValue").textContent=sphereQuaternion[1].toFixed(3),document.getElementById("quatZValue").textContent=sphereQuaternion[2].toFixed(3),document.getElementById("quatWValue").textContent=sphereQuaternion[3].toFixed(3),document.getElementById("quatXSlider").value=sphereQuaternion[0],document.getElementById("quatYSlider").value=sphereQuaternion[1],document.getElementById("quatZSlider").value=sphereQuaternion[2],document.getElementById("quatWSlider").value=sphereQuaternion[3],updateQuaternionSphere3D(),updateHopfVisualization(),updatingFromSlider=!1)},updateGeodesicArc3D=()=>{if(console.log("updateGeodesicArc3D called, showGeodesicArc:",showGeodesicArc),geodesicCurve&&(quaternionScene.remove(geodesicCurve),geodesicCurve=null),!showGeodesicArc||!quaternionScene)return;const[e,t,n,o]=sphereQuaternion;console.log("Sphere quaternion:",sphereQuaternion);const a=Math.sqrt(e*e+t*t+n*n);let r,i;if(a>1e-10){const o=1/a;r=new THREE.Vector3(e*o,t*o,n*o),i=new THREE.Vector3(-e*o,-t*o,-n*o)}else r=new THREE.Vector3(0,0,1),i=new THREE.Vector3(0,0,-1);console.log("Point1:",r),console.log("Point2:",i);const s=50,l=[],d=(new THREE.Vector3).crossVectors(r,i).normalize(),c=r.angleTo(i);if(console.log("Rotation axis:",d),console.log("Angle between points:",c,"radians =",180*c/Math.PI,"degrees"),c<.01||c>3.13){console.log("Points are too close or opposite, using alternative path");const e=new THREE.Vector3(1,0,0);Math.abs(r.dot(e))>.9&&e.set(0,1,0);for(let t=0;t<=s/2;t++){const n=t/(s/2),o=(new THREE.Vector3).lerpVectors(r,e,n).normalize();l.push(o)}for(let t=1;t<=s/2;t++){const n=t/(s/2),o=(new THREE.Vector3).lerpVectors(e,i,n).normalize();l.push(o)}}else for(let e=0;e<=s;e++){const t=c*(e/s),n=r.clone();n.applyAxisAngle(d,t),l.push(n)}console.log("Created",l.length,"points for geodesic");const h=(new THREE.BufferGeometry).setFromPoints(l),u=new THREE.LineBasicMaterial({color:16766720,linewidth:5,transparent:!1});geodesicCurve=new THREE.Line(h,u),quaternionScene.add(geodesicCurve),console.log("Geodesic arc added to scene")},resizeQuaternionSphere3D=()=>{if(!quaternionRenderer)return;const e=document.getElementById("quaternionCanvas"),t=e.clientWidth,n=e.clientHeight;quaternionCamera.aspect=t/n,quaternionCamera.updateProjectionMatrix(),quaternionRenderer.setSize(t,n)},initSlerpPath3D=()=>{const e=document.getElementById("slerpPathCanvas"),t=e.clientWidth,n=e.clientHeight;slerpScene=new THREE.Scene,slerpScene.background=new THREE.Color(657946),slerpCamera=new THREE.PerspectiveCamera(60,t/n,.1,1e3),slerpCamera.position.set(3.5,2,2.5),slerpCamera.lookAt(0,0,0),slerpRenderer=new THREE.WebGLRenderer({canvas:e,antialias:!0}),slerpRenderer.setSize(t,n),slerpRenderer.setPixelRatio(window.devicePixelRatio),slerpControls=new THREE.TrackballControls(slerpCamera,slerpRenderer.domElement),slerpControls.rotateSpeed=1,slerpControls.zoomSpeed=1.2,slerpControls.panSpeed=.8,slerpControls.minDistance=1.5,slerpControls.maxDistance=5;const o=new THREE.AmbientLight(6316128,.8);slerpScene.add(o);const a=new THREE.DirectionalLight(16777215,1);a.position.set(3,3,3),a.castShadow=!0,slerpScene.add(a);const r=new THREE.DirectionalLight(16777215,.6);r.position.set(-3,2,-3),slerpScene.add(r);const i=new THREE.PointLight(8965375,.5,100);i.position.set(2,3,0),slerpScene.add(i);const s=new THREE.PointLight(16755336,.5,100);s.position.set(-2,-1,2),slerpScene.add(s);const l=new THREE.SphereGeometry(1,24,24),d=new THREE.MeshPhongMaterial({color:6710920,wireframe:!0,transparent:!0,opacity:.3,depthWrite:!1});slerpSphere=new THREE.Mesh(l,d),slerpSphere.renderOrder=1,slerpScene.add(slerpSphere);const c=new THREE.MeshPhongMaterial({color:2236996,transparent:!0,opacity:.1,shininess:50,depthWrite:!1,side:THREE.BackSide}),h=new THREE.Mesh(l,c);h.renderOrder=0,slerpScene.add(h);const u=new THREE.AxesHelper(1.3);slerpScene.add(u);const m=new THREE.SphereGeometry(.06,16,16),p=new THREE.MeshPhongMaterial({color:5025616,emissive:5025616,emissiveIntensity:.5}),E=new THREE.Mesh(m,p);slerpScene.add(E);const f=new THREE.SphereGeometry(.06,16,16),g=new THREE.MeshPhongMaterial({color:16750592,emissive:16750592,emissiveIntensity:.5}),y=new THREE.Mesh(f,g);slerpScene.add(y);const M=new THREE.SphereGeometry(.08,16,16),S=new THREE.MeshPhongMaterial({color:2201331,emissive:2201331,emissiveIntensity:.8});slerpCurrentPoint=new THREE.Mesh(M,S),slerpScene.add(slerpCurrentPoint);const T=new THREE.MeshPhongMaterial({color:16007990,emissive:16007990,emissiveIntensity:.8});eulerCurrentPoint=new THREE.Mesh(M,T),slerpScene.add(eulerCurrentPoint);const w=()=>{requestAnimationFrame(w),slerpControls.update(),updateSlerpPaths3D(),slerpRenderer.render(slerpScene,slerpCamera)};w()},updateSlerpPaths3D=()=>{if(!slerpScene)return;const e=parseFloat(document.getElementById("tSlider").value),t=qToEulerZYX(orientationA),n=qToEulerZYX(orientationB),o=[];slerpScene.children.forEach(e=>{e.geometry&&"TubeGeometry"===e.geometry.type&&o.push(e),e.geometry&&"BufferGeometry"===e.geometry.type&&"Line"===e.type&&o.push(e),e.geometry&&"SphereGeometry"===e.geometry.type&&e.material&&(6600182===e.material.color.getHex()||16737877===e.material.color.getHex())&&o.push(e)}),o.forEach(e=>{slerpScene.remove(e),e.geometry&&e.geometry.dispose(),e.material&&(e.material.map&&e.material.map.dispose(),e.material.dispose())});const a=[],r=new THREE.Vector3(1,0,0);for(let e=0;e<=100;e++){const t=qSlerp(orientationA,orientationB,e/100),[n,o,i,s]=qNorm(t),l=new THREE.Quaternion(n,o,i,s),d=r.clone();d.applyQuaternion(l),d.normalize(),a.push(d)}const i=(new THREE.BufferGeometry).setFromPoints(a),s=new THREE.CatmullRomCurve3(a),l=new THREE.TubeGeometry(s,100,.025,8,!1),d=new THREE.MeshPhongMaterial({color:2201331,emissive:1402304,emissiveIntensity:.3,shininess:100,transparent:!1,depthTest:!0}),c=new THREE.Mesh(l,d);c.renderOrder=5,slerpScene.add(c);const h=new THREE.LineBasicMaterial({color:2201331,linewidth:2,transparent:!1});slerpPathLine=new THREE.Line(i,h),slerpPathLine.renderOrder=4,slerpScene.add(slerpPathLine);const u=[],m=new THREE.Vector3(1,0,0);for(let e=0;e<=100;e++){const o=e/100,a=t[0]+(n[0]-t[0])*o,r=t[1]+(n[1]-t[1])*o,i=t[2]+(n[2]-t[2])*o,s=qFromEulerZYX(a,r,i),[l,d,c,h]=qNorm(s),p=new THREE.Quaternion(l,d,c,h),E=m.clone();E.applyQuaternion(p),E.normalize(),u.push(E)}const p=(new THREE.BufferGeometry).setFromPoints(u),E=new THREE.LineBasicMaterial({color:16737877,linewidth:5,transparent:!1});eulerPathLine=new THREE.Line(p,E),slerpScene.add(eulerPathLine);const f=new THREE.CatmullRomCurve3(u),g=new THREE.TubeGeometry(f,100,.03,8,!1),y=new THREE.MeshPhongMaterial({color:16737877,emissive:16729139,emissiveIntensity:.6,shininess:100,transparent:!1,depthTest:!0}),M=new THREE.Mesh(g,y);M.renderOrder=2,slerpScene.add(M)
;const S=a[0],T=a[a.length-1],w=slerpScene.children.find(e=>e.material&&e.material.color&&5025616===e.material.color.getHex());w&&w.position.copy(S);const R=slerpScene.children.find(e=>e.material&&e.material.color&&16750592===e.material.color.getHex());R&&R.position.copy(T);const P=Math.floor(e*(a.length-1));slerpCurrentPoint&&a[P]&&slerpCurrentPoint.position.copy(a[P]),eulerCurrentPoint&&u[P]&&eulerCurrentPoint.position.copy(u[P])},resizeSlerpPath3D=()=>{if(!slerpRenderer)return;const e=document.getElementById("slerpPathCanvas"),t=e.clientWidth,n=e.clientHeight;slerpCamera.aspect=t/n,slerpCamera.updateProjectionMatrix(),slerpRenderer.setSize(t,n)},eulerCondition=(e,t,n)=>{const o=180*t/Math.PI,a=180*e/Math.PI,r=180*n/Math.PI;let i=8*(Math.abs(o)/90)-2+.5*Math.sin(a*Math.PI/45)+.3*Math.cos(r*Math.PI/30);return Math.abs(o)>80&&(i=Math.max(4,i)),i=Math.max(-3,Math.min(6,i)),Math.random()<.01&&console.log(`Condition: pitch=${o.toFixed(1)}\xb0, condition=${i.toFixed(2)}`),i},eulerConditionOld=()=>0,drawHeatmap=()=>{const e=document.getElementById("heatmapCanvas"),t=heatmapCtx,n=e.clientWidth,o=e.clientHeight;t.clearRect(0,0,n,o);const a=deg2rad(parseFloat(document.getElementById("heatmapPitchSlider").value)),r=deg2rad(parseFloat(document.getElementById("torusYawSlider").value)),i=deg2rad(parseFloat(document.getElementById("torusRollSlider").value)),s=(deg2rad(parseFloat(document.getElementById("pitchSlider").value)),64);let l=0;const d=[];for(let e=0;e<s;e++){d[e]=[];for(let t=0;t<s;t++){const n=2*(e/s-.5)*Math.PI,o=2*(t/s-.5)*Math.PI,r=eulerCondition(n,a,o);d[e][t]=r,l=Math.max(l,Math.min(r,1e3))}}if(showTorusView){t.save(),t.translate(n/2,o/2);const e=.2*Math.min(n,o),l=.3*e;for(let n=0;n<s;n++)for(let o=0;o<s;o++){const a=n/s*2*Math.PI,r=o/s*2*Math.PI,i=(e+l*Math.cos(r))*Math.cos(a),c=(e+l*Math.cos(r))*Math.sin(a),h=.9,u=(.866*i-.5*c)*h,m=(.866*(l*Math.sin(r))+.5*c)*h,p=a-Math.PI,E=r-Math.PI,f=Math.floor((p+Math.PI)/(2*Math.PI)*s),g=Math.floor((E+Math.PI)/(2*Math.PI)*s),y=Math.max(0,Math.min(s-1,f)),M=Math.max(0,Math.min(s-1,g)),S=d[y][M];let T,w,R;if(S<-3)T=0,w=102,R=255;else if(S<-1){const e=(S+3)/2;T=0,w=Math.floor(102+153*e),R=Math.floor(255*(1-e))}else if(S<1)T=0,w=255,R=0;else if(S<3){const e=(S-1)/2;T=Math.floor(255*e),w=Math.floor(255*(1-e)),R=0}else if(S<4.5)T=255,w=0,R=0;else if(S<6){const e=(S-4.5)/1.5;T=255,w=Math.floor(255*e),R=0}else T=255,w=255,R=0;const P=Math.PI/6,x=(i*Math.cos(P)+c*Math.sin(P)+(e+l))/(2*(e+l)),C=Math.max(.3,.4+.5*x),I=Math.max(1.5,2+1.5*x);t.fillStyle=`rgba(${T}, ${w}, ${R}, ${C})`,t.beginPath(),t.arc(u,m,I,0,2*Math.PI),t.fill()}t.strokeStyle="rgba(255, 255, 255, 0.3)",t.lineWidth=1,t.beginPath(),t.arc(0,0,e,0,2*Math.PI),t.stroke();{const n=r+Math.PI,o=i+Math.PI,a=(e+l*Math.cos(o))*Math.cos(n),s=(e+l*Math.cos(o))*Math.sin(n),d=.9,c=(.866*a-.5*s)*d,h=(.866*(l*Math.sin(o))+.5*s)*d,u=8;t.fillStyle="rgba(255, 255, 255, 0.3)",t.beginPath(),t.arc(c,h,u+4,0,2*Math.PI),t.fill(),t.fillStyle="#ff00ff",t.beginPath(),t.arc(c,h,u,0,2*Math.PI),t.fill(),t.fillStyle="#ffffff",t.beginPath(),t.arc(c,h,u-3,0,2*Math.PI),t.fill(),t.strokeStyle="#ff00ff",t.lineWidth=2,t.beginPath(),t.moveTo(c-12,h),t.lineTo(c+12,h),t.moveTo(c,h-12),t.lineTo(c,h+12),t.stroke(),t.fillStyle="#ff00ff",t.font="bold 11px sans-serif",t.fillText("Current Position",c+15,h-15),t.font="9px sans-serif",t.fillText(`Y:${rad2deg(r).toFixed(0)}\xb0 R:${rad2deg(i).toFixed(0)}\xb0`,c+15,h-2)}t.fillStyle="#ffffff",t.font="bold 12px sans-serif",t.fillText(`Torus View (Pitch = ${rad2deg(a).toFixed(0)}\xb0)`,-e,-e-l-35),t.font="10px sans-serif",t.fillStyle="rgba(255, 255, 255, 0.9)",t.fillText("Yaw: major circle \u2192",.8*e,e+25),t.fillText("Roll: minor circle \u21bb",.8*-e,-e-5),t.fillStyle="#00ff00",t.font="bold 10px sans-serif",t.fillText(`Torus Position - Y:${rad2deg(r).toFixed(0)}\xb0 R:${rad2deg(i).toFixed(0)}\xb0`,-e,e+35),t.strokeStyle="rgba(255, 255, 255, 0.4)",t.lineWidth=1,t.setLineDash([4,2]),t.beginPath(),t.arc(0,0,e,0,2*Math.PI),t.stroke();[0,Math.PI/2,Math.PI,3*Math.PI/2].forEach(n=>{const o=e*Math.cos(n),a=e*Math.sin(n);t.beginPath(),t.arc(o,a,l,0,2*Math.PI),t.stroke()}),t.setLineDash([]),t.fillStyle="rgba(100, 255, 218, 0.8)",t.font="14px sans-serif",t.fillText("\u27f2",e+15,5),t.fillText("\u27f3",e-5,l+20),t.restore(),t.fillStyle="rgba(100, 255, 218, 0.8)",t.font="bold 12px sans-serif",t.fillText("Torus View: Angles wrap at \xb1180\xb0",10,o-10)}else{const e=t.createImageData(s,s),a=e.data;for(let e=0;e<s;e++)for(let t=0;t<s;t++){const n=d[e][t],o=0===e||e===s-1,r=0===t||t===s-1,i=4*(t*s+e);let l,c,h;if(n<-3)l=0,c=102,h=255;else if(n<-1){const e=(n+3)/2;l=0,c=Math.floor(102+153*e),h=Math.floor(255*(1-e))}else if(n<1)l=0,c=255,h=0;else if(n<3){const e=(n-1)/2;l=Math.floor(255*e),c=Math.floor(255*(1-e)),h=0}else if(n<4.5)l=255,c=0,h=0;else if(n<6){const e=(n-4.5)/1.5;l=255,c=Math.floor(255*e),h=0}else l=255,c=255,h=0;a[i]=l,a[i+1]=c,a[i+2]=h,a[i+3]=o||r?200:255}const l=document.createElement("canvas");l.width=s,l.height=s;l.getContext("2d").putImageData(e,0,0),t.imageSmoothingEnabled=!1,t.drawImage(l,0,0,n,o),t.strokeStyle="rgba(100, 255, 218, 0.6)",t.lineWidth=3,t.setLineDash([8,4]),t.beginPath(),t.moveTo(0,0),t.lineTo(0,o),t.moveTo(n-1,0),t.lineTo(n-1,o),t.stroke(),t.beginPath(),t.moveTo(0,0),t.lineTo(n,0),t.moveTo(0,o-1),t.lineTo(n,o-1),t.stroke(),t.setLineDash([]),t.fillStyle="rgba(100, 255, 218, 0.8)",t.font="14px sans-serif",t.save(),t.translate(5,o/2),t.rotate(-Math.PI/2),t.fillText("\u2194",-8,0),t.restore(),t.save(),t.translate(n-15,o/2),t.rotate(-Math.PI/2),t.fillText("\u2194",-8,0),t.restore(),t.fillText("\u2195",n/2-5,15),t.fillText("\u2195",n/2-5,o-5),t.fillStyle="#ffffff",t.font="12px sans-serif",t.fillText("Yaw [-180\xb0, 180\xb0] \u2192",n-140,o-10),t.save(),t.translate(15,o/2+30),t.rotate(-Math.PI/2),t.fillText("Roll [-180\xb0, 180\xb0] \u2191",0,0),t.restore(),t.fillStyle="rgba(255, 255, 255, 0.7)",t.font="10px sans-serif";[-180,-90,0,90,180].forEach(e=>{const a=(e+180)/360*n;t.fillText(`${e}\xb0`,a-10,o-20)});[-180,-90,0,90,180].forEach(e=>{const n=(e+180)/360*o;t.save(),t.translate(25,n+3),t.fillText(`${e}\xb0`,0,0),t.restore()});{const e=(180*r/Math.PI+180)/360*n,a=(180*i/Math.PI+180)/360*o,s=Math.max(20,Math.min(n-20,e)),l=Math.max(20,Math.min(o-40,a)),d=10;t.fillStyle="rgba(255, 255, 255, 0.4)",t.beginPath(),t.arc(s,l,d+4,0,2*Math.PI),t.fill(),t.fillStyle="#ff00ff",t.beginPath(),t.arc(s,l,d,0,2*Math.PI),t.fill(),t.fillStyle="#ffffff",t.beginPath(),t.arc(s,l,d-4,0,2*Math.PI),t.fill(),t.strokeStyle="#ff00ff",t.lineWidth=2,t.beginPath(),t.moveTo(s-15,l),t.lineTo(s+15,l),t.moveTo(s,l-15),t.lineTo(s,l+15),t.stroke(),t.fillStyle="#ff00ff",t.font="bold 11px sans-serif",t.fillText("Current Position",s+18,l-15),t.font="9px sans-serif",t.fillText(`Y:${rad2deg(r).toFixed(0)}\xb0 R:${rad2deg(i).toFixed(0)}\xb0`,s+18,l-2),t.strokeStyle="rgba(255, 0, 255, 0.3)",t.lineWidth=1,t.setLineDash([2,2]),t.beginPath(),t.moveTo(s,l),t.lineTo(s,o-35),t.moveTo(s,l),t.lineTo(35,l),t.stroke(),t.setLineDash([])}}t.font="bold 14px sans-serif",t.fillStyle=Math.abs(a)>deg2rad(80)?"#ff6b6b":"#64ffda",t.fillText(`Pitch: ${rad2deg(a).toFixed(0)}\xb0`,10,20),Math.abs(Math.cos(a))<.15&&(t.fillStyle="#ffff00",t.font="bold 16px sans-serif",t.fillText("NEAR SINGULARITY!",n/2-80,25))};let orientationA=[0,0,0,1],orientationB=qFromEulerZYX(deg2rad(90),deg2rad(45),deg2rad(30));const drawSlerpVelocity=()=>{const e=document.getElementById("slerpVelocityCanvas"),t=slerpVelocityCtx,n=e.clientWidth,o=e.clientHeight;t.clearRect(0,0,n,o);const a=parseFloat(document.getElementById("tSlider").value),r=qToEulerZYX(orientationA),i=qToEulerZYX(orientationB),s=[],l=[],d=[],c=[],h=100,u=1/h;for(let e=0;e<=h;e++){const t=e/h,n=qSlerp(orientationA,orientationB,t);d.push(n);const o=r[0]+(i[0]-r[0])*t,a=r[1]+(i[1]-r[1])*t,m=r[2]+(i[2]-r[2])*t,p=qFromEulerZYX(o,a,m);if(c.push(p),e>0){const t=qMul(n,qConj(d[e-1])),[o,a]=qToAxisAngle(t),r=a/u;s.push(r);const i=qMul(p,qConj(c[e-1])),[h,m]=qToAxisAngle(i),E=m/u;l.push(E)}}const m=Math.max(...s,...l),p=Math.min(...s,...l),E=m-p||1;t.fillStyle="rgba(255, 255, 255, 0.02)",t.fillRect(0,0,n,o);const f=.7*o,g=.15*o;t.strokeStyle="rgba(255, 255, 255, 0.1)",t.lineWidth=1;for(let e=0;e<=4;e++){const o=g+f*e/4;t.beginPath(),t.moveTo(10,o),t.lineTo(n-10,o),t.stroke()}t.strokeStyle="#2196f3",t.lineWidth=3,t.beginPath();for(let e=0;e<s.length;e++){const o=10+(n-20)*(e/s.length),a=g+f-(s[e]-p)/E*f;0===e?t.moveTo(o,a):t.lineTo(o,a)}t.stroke();const y=s.reduce((e,t)=>e+t,0)/s.length,M=Math.sqrt(s.reduce((e,t)=>e+Math.pow(t-y,2),0)/s.length);t.strokeStyle="#f44336",t.lineWidth=3,t.beginPath();for(let e=0;e<l.length;e++){const o=10+(n-20)*(e/l.length),a=g+f-(l[e]-p)/E*f;0===e?t.moveTo(o,a):t.lineTo(o,a)}t.stroke();const S=l.reduce((e,t)=>e+t,0)/l.length,T=Math.sqrt(l.reduce((e,t)=>e+Math.pow(t-S,2),0)/l.length),w=Math.min(Math.floor(a*(s.length-1)),s.length-1),R=10+(n-20)*a;t.strokeStyle="rgba(255, 255, 255, 0.3)",t.lineWidth=1,t.setLineDash([4,2]),t.beginPath(),t.moveTo(R,g),t.lineTo(R,g+f),t.stroke(),t.setLineDash([]);const P=g+f-(s[w]-p)/E*f;t.fillStyle="#2196f3",t.beginPath(),t.arc(R,P,5,0,2*Math.PI),t.fill();const x=g+f-(l[w]-p)/E*f;t.fillStyle="#f44336",t.beginPath(),t.arc(R,x,5,0,2*Math.PI),t.fill(),t.fillStyle="#ffffff",t.font="bold 12px sans-serif",t.fillText("Angular Velocity",n/2-45,15),t.font="10px sans-serif",t.fillStyle="rgba(255, 255, 255, 0.6)",t.fillText("0",5,g+f+12),t.fillText("t",n-15,g+f+12),t.fillText("1",n-10,g+f+12),t.fillStyle="#2196f3",t.font="bold 11px sans-serif",t.fillText(`SLERP: \u03c3=${M.toFixed(3)}`,15,o-25),t.fillText("(constant speed)",15,o-10),t.fillStyle="#f44336",t.fillText(`Euler: \u03c3=${T.toFixed(3)}`,15,o-55),t.fillText("(varying speed)",15,o-40)};let previousQuaternion=null,lastUpdateTime=performance.now();const updateFromSliders=()=>{const e=performance.now(),t=(e-lastUpdateTime)/1e3,n=deg2rad(parseFloat(document.getElementById("yawSlider").value)),o=deg2rad(parseFloat(document.getElementById("pitchSlider").value)),a=deg2rad(parseFloat(document.getElementById("rollSlider").value));previousQuaternion=currentQuaternion?[...currentQuaternion]:null,currentQuaternion=qFromEulerZYX(n,o,a);const r=Math.sqrt(currentQuaternion[0]**2+currentQuaternion[1]**2+currentQuaternion[2]**2+currentQuaternion[3]**2),i=Math.abs(r-1);if(i>QUATERNION_TOLERANCE&&(console.warn("Mathematical Analysis: Unit quaternion constraint violated:",i),mathAnalysis.unitConstraintViolations.push({frame:mathAnalysis.frameCount,error:i,quaternion:[...currentQuaternion]})),previousQuaternion&&t>0){const e=analyzeTemporalCoherence(currentQuaternion,previousQuaternion,t);e&&!e.isCoherent&&mathAnalysis.temporalCoherence.push({frame:mathAnalysis.frameCount,type:"coherence-violation",velocityError:e.velocityCoherenceError,axisError:e.axisCoherenceError})}const s=qToMatrix(currentQuaternion),l=verifySO3Properties(s);l.isValidSO3||console.error("Mathematical Analysis: SO(3) property violation:",l);const d=verifyDoubleCover(currentQuaternion);d.isValid||console.error("Mathematical Analysis: Double cover violation:",d.error);const c=analyzeAntipodalPoints(currentQuaternion);!c.isValidAntipodal&&c.geodesicError>.1&&console.warn("Mathematical Analysis: Significant antipodal inconsistency:",{geodesicError:c.geodesicError,rotationMatrixError:c.rotationMatrixError});const h=stereographicProjection(currentQuaternion,"north");if(h.isValid||mathAnalysis.projectionErrors.push({frame:mathAnalysis.frameCount,error:h.error,quaternion:[...currentQuaternion]}),frameCount++,mathAnalysis.frameCount++,frameCount%10==0){currentQuaternion=qNorm(currentQuaternion);const e=Math.abs(Math.sqrt(currentQuaternion[0]**2+currentQuaternion[1]**2+currentQuaternion[2]**2+currentQuaternion[3]**2)-1);if(e>QUATERNION_TOLERANCE&&console.error("Mathematical Analysis: Normalization failed:",e),quaternionHistory.push([...currentQuaternion]),quaternionHistory.length>10&&quaternionHistory.shift(),quaternionHistory.length>1){const e=quaternionHistory[quaternionHistory.length-2],t=qDot(currentQuaternion,e),n=geodesicDistance(currentQuaternion,e);if(t<0){currentQuaternion=currentQuaternion.map(e=>-e),quaternionHistory[quaternionHistory.length-1]=currentQuaternion;qDot(currentQuaternion,e);geodesicDistance(currentQuaternion,e)>n&&console.warn("Mathematical Analysis: Quaternion flip did not improve continuity")}}}document.getElementById("yawValue").textContent=`${rad2deg(n).toFixed(1)}\xb0`,document.getElementById("pitchValue").textContent=`${rad2deg(o).toFixed(1)}\xb0`,document.getElementById("rollValue").textContent=`${rad2deg(a).toFixed(1)}\xb0`;const u=document.getElementById("quatX"),m=document.getElementById("quatY"),p=document.getElementById("quatZ"),E=document.getElementById("quatW");u.textContent=currentQuaternion[0].toFixed(6),m.textContent=currentQuaternion[1].toFixed(6),p.textContent=currentQuaternion[2].toFixed(6),E.textContent=currentQuaternion[3].toFixed(6);const f=i<QUATERNION_TOLERANCE?"#64ffda":i<10*QUATERNION_TOLERANCE?"#ff9800":"#ff6b6b";u.style.color=f,m.style.color=f,p.style.color=f,E.style.color=f,drawGimbal(),updateQuaternionSphere3D(),lastUpdateTime=e,frameCount%60==0&&mathAnalysis.unitConstraintViolations.length>0&&(console.log("Mathematical Analysis Summary:"),console.log(`  Unit constraint violations: ${mathAnalysis.unitConstraintViolations.length}`),console.log(`  Geodesic errors: ${mathAnalysis.geodesicErrors.length}`),console.log(`  Singularity detections: ${mathAnalysis.singularityDetections.length}`),console.log(`  Projection errors: ${mathAnalysis.projectionErrors.length}`),console.log(`  Temporal coherence issues: ${mathAnalysis.temporalCoherence.filter(e=>!e.isCoherent).length}`))},init=()=>{initThreeJS(),initQuaternionSphere3D(),initHopfFibration3D(),heatmapCtx=document.getElementById("heatmapCanvas").getContext("2d"),slerpVelocityCtx=document.getElementById("slerpVelocityCanvas").getContext("2d"),initSlerpPath3D(),resizeCanvases(),["yawSlider","pitchSlider","rollSlider"].forEach(e=>{document.getElementById(e).addEventListener("input",updateFromSliders)}),["sphereYawSlider","spherePitchSlider","sphereRollSlider"].forEach((e,t)=>{document.getElementById(e).addEventListener("input",e=>{updatingFromSlider||(sphereEuler[t]=deg2rad(parseFloat(e.target.value)),updateSphereFromEuler())})}),["quatXSlider","quatYSlider","quatZSlider","quatWSlider"].forEach((e,t)=>{document.getElementById(e).addEventListener("input",e=>{if(updatingFromSlider)return;const n=parseFloat(e.target.value);sphereQuaternion[t]=n;const o=["X","Y","Z","W"];document.getElementById(`quat${o[t]}Value`).textContent=n.toFixed(3),updateEulerFromSphere()})}),document.getElementById("heatmapPitchSlider").addEventListener("input",()=>{const e=parseFloat(document.getElementById("heatmapPitchSlider").value);document.getElementById("heatmapPitchValue").textContent=`${e}\xb0`,drawHeatmap()}),document.getElementById("torusYawSlider").addEventListener("input",()=>{const e=parseFloat(document.getElementById("torusYawSlider").value);document.getElementById("torusYawValue").textContent=`${e}\xb0`,drawHeatmap()}),document.getElementById("torusRollSlider").addEventListener("input",()=>{const e=parseFloat(document.getElementById("torusRollSlider").value);document.getElementById("torusRollValue").textContent=`${e}\xb0`,drawHeatmap()}),document.getElementById("tSlider").addEventListener("input",()=>{const e=parseFloat(document.getElementById("tSlider").value);document.getElementById("tValue").textContent=e.toFixed(2),drawSlerpVelocity(),updateSlerpPaths3D(),showGeodesicArc&&updateQuaternionSphere3D()}),document.getElementById("showQuaternionFeatures").addEventListener("click",()=>{showAntipodes=!showAntipodes,showGeodesicArc=showAntipodes,document.getElementById("showQuaternionFeatures").textContent=showAntipodes?"Hide Antipodal Points & Geodesic Arc":"Show Antipodal Points & Geodesic Arc",updateQuaternionSphere3D()});const e=document.getElementById("hopfRotationSpeed");e&&e.addEventListener("input",e=>{hopfParams.rotationSpeed=parseFloat(e.target.value);const t=document.getElementById("hopfRotationSpeedValue");t&&(t.textContent=hopfParams.rotationSpeed.toFixed(1))});const t=document.getElementById("hopfFiberCount");t&&t.addEventListener("input",e=>{hopfParams.fiberCount=parseInt(e.target.value);const t=document.getElementById("hopfFiberCountValue");t&&(t.textContent=hopfParams.fiberCount),"function"==typeof createHopfFibers&&createHopfFibers()});const n=document.getElementById("hopfAnimationPhase");n&&n.addEventListener("input",e=>{hopfParams.animationPhase=parseFloat(e.target.value);const t=document.getElementById("hopfAnimationPhaseValue");t&&(t.textContent=hopfParams.animationPhase.toFixed(2)),"function"==typeof createHopfFibers&&createHopfFibers()});const o=document.getElementById("hopfBaseSphere");o&&o.addEventListener("input",e=>{hopfParams.baseSphereSize=parseFloat(e.target.value);const t=document.getElementById("hopfBaseSphereValue");t&&(t.textContent=hopfParams.baseSphereSize.toFixed(1)),"function"==typeof createHopfBaseSphere&&createHopfBaseSphere()});const a=document.getElementById("hopfToggleAnimation");a&&a.addEventListener("click",()=>{hopfIsAnimating=!hopfIsAnimating,a.textContent=hopfIsAnimating?"Pause":"Play"});const r=document.getElementById("hopfResetView");r&&r.addEventListener("click",()=>{hopfCamera&&(hopfCamera.position.set(5,3,5),hopfCamera.lookAt(0,0,0),hopfTime=0)}),document.getElementById("setRandomOrientations").addEventListener("click",()=>{orientationA=qFromAxisAngle([Math.random()-.5,Math.random()-.5,Math.random()-.5],Math.random()*Math.PI),orientationB=qFromAxisAngle([Math.random()-.5,Math.random()-.5,Math.random()-.5],Math.random()*Math.PI),window.orientationA=orientationA,window.orientationB=orientationB,drawSlerpVelocity(),updateSlerpPaths3D(),updateQuaternionSphere3D()});let i=!1;document.getElementById("animateHeatmap").addEventListener("click",()=>{if(i)return;i=!0;let e=-90;const t=()=>{document.getElementById("heatmapPitchSlider").value=e,document.getElementById("heatmapPitchValue").textContent=`${e}\xb0`,drawHeatmap(),e+=2,e<=90?setTimeout(t,50):i=!1};t()}),document.getElementById("toggleTorusView").addEventListener("click",()=>{showTorusView=!showTorusView,document.getElementById("toggleTorusView").textContent=showTorusView?"Switch to Flat View":"Switch to Torus View",drawHeatmap()}),document.getElementById("toggleTorusView").textContent="Switch to Flat View";let s=!1;document.getElementById("animateInterp").addEventListener("click",()=>{if(s)return;s=!0;let e=0;const t=()=>{document.getElementById("tSlider").value=e,document.getElementById("tValue").textContent=e.toFixed(2),drawSlerpVelocity(),updateSlerpPaths3D(),e+=.01,e<=1?setTimeout(t,20):(s=!1,setTimeout(()=>{e=0,document.getElementById("tSlider").value=e,document.getElementById("tValue").textContent=e.toFixed(2),drawSlerpVelocity(),updateSlerpPaths3D()},500))};t()}),window.orientationA=orientationA,window.orientationB=orientationB,sphereQuaternion=[0,0,0,1],sphereEuler=[0,0,0],document.getElementById("sphereYawValue").textContent="0\xb0",document.getElementById("spherePitchValue").textContent="0\xb0",document.getElementById("sphereRollValue").textContent="0\xb0",document.getElementById("quatXValue").textContent="0.000",document.getElementById("quatYValue").textContent="0.000",document.getElementById("quatZValue").textContent="0.000",document.getElementById("quatWValue").textContent="1.000",updateFromSliders(),updateQuaternionSphere3D(),drawHeatmap(),drawSlerpVelocity(),updateSlerpPaths3D(),setTimeout(()=>{console.log("Initializing enhanced Hopf Fibration..."),hopfFibers.length>0&&console.log(`Hopf fibers successfully generated: ${hopfFibers.length}`),document.getElementById("hopfRotationSpeedValue").textContent=hopfParams.rotationSpeed.toFixed(1),document.getElementById("hopfFiberCountValue").textContent=hopfParams.fiberCount,document.getElementById("hopfAnimationPhaseValue").textContent=hopfParams.animationPhase.toFixed(2),document.getElementById("hopfBaseSphereValue").textContent=hopfParams.baseSphereSize.toFixed(1)},100)};window.addEventListener("resize",()=>{setTimeout(()=>{resizeCanvases(),resizeThreeJS(),resizeQuaternionSphere3D(),resizeHopfVisualization(),resizeSlerpPath3D(),updateFromSliders(),drawHeatmap(),drawSlerpVelocity(),updateSlerpPaths3D()},100)}),document.addEventListener("DOMContentLoaded",init);</script> </article> </div> </div> </body></body> </html> </article> </div> </div> <footer class="fixed-bottom"> <div class="container mt-0"> &copy; Copyright 2025 Saeed Ghorbani. Powered by <a href="https://jekyllrb.com/" target="_blank">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank">Unsplash</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script async src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.11.2/dist/umd/popper.min.js" integrity="sha256-l/1pMF/+J4TThfgARS6KwWrk/egwuVvhRzfLAMQ6Ds4=" crossorigin="anonymous"></script> <script async src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.min.js" integrity="sha256-SyTu6CwrfOhaznYZPoolVw2rxoY7lKYKQvqbtqN93HI=" crossorigin="anonymous"></script> <script async src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="/assets/js/common.js"></script> <script defer src="/assets/js/custom_effects.js"></script> <script type="text/javascript">window.MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]],processEscapes:!0,processEnvironments:!0,tags:"ams"},options:{ignoreHtmlClass:"tex2jax_ignore",processHtmlClass:"tex2jax_process"}};</script> <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> </body> </html>